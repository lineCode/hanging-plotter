/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const SOC_UART_NUM: u32 = 3;
pub const __NEWLIB__: u32 = 2;
pub const __NEWLIB_MINOR__: u32 = 1;
pub const _POSIX_THREADS: u32 = 1;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __int8_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"2.2.0\0";
pub const _WANT_REENT_SMALL: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _NANO_FORMATTED_IO: u32 = 1;
pub const XCHAL_HAVE_BE: u32 = 0;
pub const XCHAL_HAVE_WINDOWED: u32 = 1;
pub const XCHAL_NUM_AREGS: u32 = 64;
pub const XCHAL_NUM_AREGS_LOG2: u32 = 6;
pub const XCHAL_MAX_INSTRUCTION_SIZE: u32 = 3;
pub const XCHAL_HAVE_DEBUG: u32 = 1;
pub const XCHAL_HAVE_DENSITY: u32 = 1;
pub const XCHAL_HAVE_LOOPS: u32 = 1;
pub const XCHAL_LOOP_BUFFER_SIZE: u32 = 256;
pub const XCHAL_HAVE_NSA: u32 = 1;
pub const XCHAL_HAVE_MINMAX: u32 = 1;
pub const XCHAL_HAVE_SEXT: u32 = 1;
pub const XCHAL_HAVE_DEPBITS: u32 = 0;
pub const XCHAL_HAVE_CLAMPS: u32 = 1;
pub const XCHAL_HAVE_MUL16: u32 = 1;
pub const XCHAL_HAVE_MUL32: u32 = 1;
pub const XCHAL_HAVE_MUL32_HIGH: u32 = 1;
pub const XCHAL_HAVE_DIV32: u32 = 1;
pub const XCHAL_HAVE_L32R: u32 = 1;
pub const XCHAL_HAVE_ABSOLUTE_LITERALS: u32 = 0;
pub const XCHAL_HAVE_CONST16: u32 = 0;
pub const XCHAL_HAVE_ADDX: u32 = 1;
pub const XCHAL_HAVE_WIDE_BRANCHES: u32 = 0;
pub const XCHAL_HAVE_PREDICTED_BRANCHES: u32 = 0;
pub const XCHAL_HAVE_CALL4AND12: u32 = 1;
pub const XCHAL_HAVE_ABS: u32 = 1;
pub const XCHAL_HAVE_RELEASE_SYNC: u32 = 1;
pub const XCHAL_HAVE_S32C1I: u32 = 1;
pub const XCHAL_HAVE_SPECULATION: u32 = 0;
pub const XCHAL_HAVE_FULL_RESET: u32 = 1;
pub const XCHAL_NUM_CONTEXTS: u32 = 1;
pub const XCHAL_NUM_MISC_REGS: u32 = 4;
pub const XCHAL_HAVE_TAP_MASTER: u32 = 0;
pub const XCHAL_HAVE_PRID: u32 = 1;
pub const XCHAL_HAVE_EXTERN_REGS: u32 = 1;
pub const XCHAL_HAVE_MX: u32 = 0;
pub const XCHAL_HAVE_MP_INTERRUPTS: u32 = 0;
pub const XCHAL_HAVE_MP_RUNSTALL: u32 = 0;
pub const XCHAL_HAVE_PSO: u32 = 0;
pub const XCHAL_HAVE_PSO_CDM: u32 = 0;
pub const XCHAL_HAVE_PSO_FULL_RETENTION: u32 = 0;
pub const XCHAL_HAVE_THREADPTR: u32 = 1;
pub const XCHAL_HAVE_BOOLEANS: u32 = 1;
pub const XCHAL_HAVE_CP: u32 = 1;
pub const XCHAL_CP_MAXCFG: u32 = 8;
pub const XCHAL_HAVE_MAC16: u32 = 1;
pub const XCHAL_HAVE_FUSION: u32 = 0;
pub const XCHAL_HAVE_FUSION_FP: u32 = 0;
pub const XCHAL_HAVE_FUSION_LOW_POWER: u32 = 0;
pub const XCHAL_HAVE_FUSION_AES: u32 = 0;
pub const XCHAL_HAVE_FUSION_CONVENC: u32 = 0;
pub const XCHAL_HAVE_FUSION_LFSR_CRC: u32 = 0;
pub const XCHAL_HAVE_FUSION_BITOPS: u32 = 0;
pub const XCHAL_HAVE_FUSION_AVS: u32 = 0;
pub const XCHAL_HAVE_FUSION_16BIT_BASEBAND: u32 = 0;
pub const XCHAL_HAVE_FUSION_VITERBI: u32 = 0;
pub const XCHAL_HAVE_FUSION_SOFTDEMAP: u32 = 0;
pub const XCHAL_HAVE_HIFIPRO: u32 = 0;
pub const XCHAL_HAVE_HIFI4: u32 = 0;
pub const XCHAL_HAVE_HIFI4_VFPU: u32 = 0;
pub const XCHAL_HAVE_HIFI3: u32 = 0;
pub const XCHAL_HAVE_HIFI3_VFPU: u32 = 0;
pub const XCHAL_HAVE_HIFI2: u32 = 0;
pub const XCHAL_HAVE_HIFI2EP: u32 = 0;
pub const XCHAL_HAVE_HIFI_MINI: u32 = 0;
pub const XCHAL_HAVE_VECTORFPU2005: u32 = 0;
pub const XCHAL_HAVE_USER_DPFPU: u32 = 0;
pub const XCHAL_HAVE_USER_SPFPU: u32 = 0;
pub const XCHAL_HAVE_FP: u32 = 1;
pub const XCHAL_HAVE_FP_DIV: u32 = 1;
pub const XCHAL_HAVE_FP_RECIP: u32 = 1;
pub const XCHAL_HAVE_FP_SQRT: u32 = 1;
pub const XCHAL_HAVE_FP_RSQRT: u32 = 1;
pub const XCHAL_HAVE_DFP: u32 = 0;
pub const XCHAL_HAVE_DFP_DIV: u32 = 0;
pub const XCHAL_HAVE_DFP_RECIP: u32 = 0;
pub const XCHAL_HAVE_DFP_SQRT: u32 = 0;
pub const XCHAL_HAVE_DFP_RSQRT: u32 = 0;
pub const XCHAL_HAVE_DFP_ACCEL: u32 = 1;
pub const XCHAL_HAVE_DFP_accel: u32 = 1;
pub const XCHAL_HAVE_DFPU_SINGLE_ONLY: u32 = 1;
pub const XCHAL_HAVE_DFPU_SINGLE_DOUBLE: u32 = 0;
pub const XCHAL_HAVE_VECTRA1: u32 = 0;
pub const XCHAL_HAVE_VECTRALX: u32 = 0;
pub const XCHAL_HAVE_PDX4: u32 = 0;
pub const XCHAL_HAVE_CONNXD2: u32 = 0;
pub const XCHAL_HAVE_CONNXD2_DUALLSFLIX: u32 = 0;
pub const XCHAL_HAVE_BBE16: u32 = 0;
pub const XCHAL_HAVE_BBE16_RSQRT: u32 = 0;
pub const XCHAL_HAVE_BBE16_VECDIV: u32 = 0;
pub const XCHAL_HAVE_BBE16_DESPREAD: u32 = 0;
pub const XCHAL_HAVE_BBENEP: u32 = 0;
pub const XCHAL_HAVE_BSP3: u32 = 0;
pub const XCHAL_HAVE_BSP3_TRANSPOSE: u32 = 0;
pub const XCHAL_HAVE_SSP16: u32 = 0;
pub const XCHAL_HAVE_SSP16_VITERBI: u32 = 0;
pub const XCHAL_HAVE_TURBO16: u32 = 0;
pub const XCHAL_HAVE_BBP16: u32 = 0;
pub const XCHAL_HAVE_FLIX3: u32 = 0;
pub const XCHAL_HAVE_GRIVPEP: u32 = 0;
pub const XCHAL_HAVE_GRIVPEP_HISTOGRAM: u32 = 0;
pub const XCHAL_NUM_LOADSTORE_UNITS: u32 = 1;
pub const XCHAL_NUM_WRITEBUFFER_ENTRIES: u32 = 4;
pub const XCHAL_INST_FETCH_WIDTH: u32 = 4;
pub const XCHAL_DATA_WIDTH: u32 = 4;
pub const XCHAL_DATA_PIPE_DELAY: u32 = 2;
pub const XCHAL_CLOCK_GATING_GLOBAL: u32 = 1;
pub const XCHAL_CLOCK_GATING_FUNCUNIT: u32 = 1;
pub const XCHAL_UNALIGNED_LOAD_EXCEPTION: u32 = 0;
pub const XCHAL_UNALIGNED_STORE_EXCEPTION: u32 = 0;
pub const XCHAL_UNALIGNED_LOAD_HW: u32 = 1;
pub const XCHAL_UNALIGNED_STORE_HW: u32 = 1;
pub const XCHAL_SW_VERSION: u32 = 1100003;
pub const XCHAL_CORE_ID: &'static [u8; 17usize] = b"esp32_v3_49_prod\0";
pub const XCHAL_BUILD_UNIQUE_ID: u32 = 392854;
pub const XCHAL_HW_CONFIGID0: u32 = 3267166206;
pub const XCHAL_HW_CONFIGID1: u32 = 482737814;
pub const XCHAL_HW_VERSION_NAME: &'static [u8; 8usize] = b"LX6.0.3\0";
pub const XCHAL_HW_VERSION_MAJOR: u32 = 2600;
pub const XCHAL_HW_VERSION_MINOR: u32 = 3;
pub const XCHAL_HW_VERSION: u32 = 260003;
pub const XCHAL_HW_REL_LX6: u32 = 1;
pub const XCHAL_HW_REL_LX6_0: u32 = 1;
pub const XCHAL_HW_REL_LX6_0_3: u32 = 1;
pub const XCHAL_HW_CONFIGID_RELIABLE: u32 = 1;
pub const XCHAL_HW_MIN_VERSION_MAJOR: u32 = 2600;
pub const XCHAL_HW_MIN_VERSION_MINOR: u32 = 3;
pub const XCHAL_HW_MIN_VERSION: u32 = 260003;
pub const XCHAL_HW_MAX_VERSION_MAJOR: u32 = 2600;
pub const XCHAL_HW_MAX_VERSION_MINOR: u32 = 3;
pub const XCHAL_HW_MAX_VERSION: u32 = 260003;
pub const XCHAL_ICACHE_LINESIZE: u32 = 4;
pub const XCHAL_DCACHE_LINESIZE: u32 = 4;
pub const XCHAL_ICACHE_LINEWIDTH: u32 = 2;
pub const XCHAL_DCACHE_LINEWIDTH: u32 = 2;
pub const XCHAL_ICACHE_SIZE: u32 = 0;
pub const XCHAL_DCACHE_SIZE: u32 = 0;
pub const XCHAL_DCACHE_IS_WRITEBACK: u32 = 0;
pub const XCHAL_DCACHE_IS_COHERENT: u32 = 0;
pub const XCHAL_HAVE_PREFETCH: u32 = 0;
pub const XCHAL_HAVE_PREFETCH_L1: u32 = 0;
pub const XCHAL_PREFETCH_CASTOUT_LINES: u32 = 0;
pub const XCHAL_PREFETCH_ENTRIES: u32 = 0;
pub const XCHAL_PREFETCH_BLOCK_ENTRIES: u32 = 0;
pub const XCHAL_HAVE_CACHE_BLOCKOPS: u32 = 0;
pub const XCHAL_HAVE_ICACHE_TEST: u32 = 0;
pub const XCHAL_HAVE_DCACHE_TEST: u32 = 0;
pub const XCHAL_HAVE_ICACHE_DYN_WAYS: u32 = 0;
pub const XCHAL_HAVE_DCACHE_DYN_WAYS: u32 = 0;
pub const XCHAL_HAVE_PIF: u32 = 1;
pub const XCHAL_HAVE_AXI: u32 = 0;
pub const XCHAL_HAVE_PIF_WR_RESP: u32 = 0;
pub const XCHAL_HAVE_PIF_REQ_ATTR: u32 = 0;
pub const XCHAL_ICACHE_SETWIDTH: u32 = 0;
pub const XCHAL_DCACHE_SETWIDTH: u32 = 0;
pub const XCHAL_ICACHE_WAYS: u32 = 1;
pub const XCHAL_DCACHE_WAYS: u32 = 1;
pub const XCHAL_ICACHE_LINE_LOCKABLE: u32 = 0;
pub const XCHAL_DCACHE_LINE_LOCKABLE: u32 = 0;
pub const XCHAL_ICACHE_ECC_PARITY: u32 = 0;
pub const XCHAL_DCACHE_ECC_PARITY: u32 = 0;
pub const XCHAL_ICACHE_ACCESS_SIZE: u32 = 1;
pub const XCHAL_DCACHE_ACCESS_SIZE: u32 = 1;
pub const XCHAL_DCACHE_BANKS: u32 = 0;
pub const XCHAL_CA_BITS: u32 = 4;
pub const XCHAL_NUM_INSTROM: u32 = 1;
pub const XCHAL_NUM_INSTRAM: u32 = 2;
pub const XCHAL_NUM_DATAROM: u32 = 1;
pub const XCHAL_NUM_DATARAM: u32 = 2;
pub const XCHAL_NUM_URAM: u32 = 0;
pub const XCHAL_NUM_XLMI: u32 = 1;
pub const XCHAL_INSTROM0_VADDR: u32 = 1082130432;
pub const XCHAL_INSTROM0_PADDR: u32 = 1082130432;
pub const XCHAL_INSTROM0_SIZE: u32 = 4194304;
pub const XCHAL_INSTROM0_ECC_PARITY: u32 = 0;
pub const XCHAL_INSTRAM0_VADDR: u32 = 1073741824;
pub const XCHAL_INSTRAM0_PADDR: u32 = 1073741824;
pub const XCHAL_INSTRAM0_SIZE: u32 = 4194304;
pub const XCHAL_INSTRAM0_ECC_PARITY: u32 = 0;
pub const XCHAL_INSTRAM1_VADDR: u32 = 1077936128;
pub const XCHAL_INSTRAM1_PADDR: u32 = 1077936128;
pub const XCHAL_INSTRAM1_SIZE: u32 = 4194304;
pub const XCHAL_INSTRAM1_ECC_PARITY: u32 = 0;
pub const XCHAL_DATAROM0_VADDR: u32 = 1061158912;
pub const XCHAL_DATAROM0_PADDR: u32 = 1061158912;
pub const XCHAL_DATAROM0_SIZE: u32 = 4194304;
pub const XCHAL_DATAROM0_ECC_PARITY: u32 = 0;
pub const XCHAL_DATAROM0_BANKS: u32 = 1;
pub const XCHAL_DATARAM0_VADDR: u32 = 1073217536;
pub const XCHAL_DATARAM0_PADDR: u32 = 1073217536;
pub const XCHAL_DATARAM0_SIZE: u32 = 524288;
pub const XCHAL_DATARAM0_ECC_PARITY: u32 = 0;
pub const XCHAL_DATARAM0_BANKS: u32 = 1;
pub const XCHAL_DATARAM1_VADDR: u32 = 1065353216;
pub const XCHAL_DATARAM1_PADDR: u32 = 1065353216;
pub const XCHAL_DATARAM1_SIZE: u32 = 4194304;
pub const XCHAL_DATARAM1_ECC_PARITY: u32 = 0;
pub const XCHAL_DATARAM1_BANKS: u32 = 1;
pub const XCHAL_XLMI0_VADDR: u32 = 1072693248;
pub const XCHAL_XLMI0_PADDR: u32 = 1072693248;
pub const XCHAL_XLMI0_SIZE: u32 = 524288;
pub const XCHAL_XLMI0_ECC_PARITY: u32 = 0;
pub const XCHAL_HAVE_IMEM_LOADSTORE: u32 = 1;
pub const XCHAL_HAVE_INTERRUPTS: u32 = 1;
pub const XCHAL_HAVE_HIGHPRI_INTERRUPTS: u32 = 1;
pub const XCHAL_HAVE_NMI: u32 = 1;
pub const XCHAL_HAVE_CCOUNT: u32 = 1;
pub const XCHAL_NUM_TIMERS: u32 = 3;
pub const XCHAL_NUM_INTERRUPTS: u32 = 32;
pub const XCHAL_NUM_INTERRUPTS_LOG2: u32 = 5;
pub const XCHAL_NUM_EXTINTERRUPTS: u32 = 26;
pub const XCHAL_NUM_INTLEVELS: u32 = 6;
pub const XCHAL_EXCM_LEVEL: u32 = 3;
pub const XCHAL_INTLEVEL1_MASK: u32 = 407551;
pub const XCHAL_INTLEVEL2_MASK: u32 = 3670016;
pub const XCHAL_INTLEVEL3_MASK: u32 = 683706368;
pub const XCHAL_INTLEVEL4_MASK: u32 = 1392508928;
pub const XCHAL_INTLEVEL5_MASK: u32 = 2214658048;
pub const XCHAL_INTLEVEL6_MASK: u32 = 0;
pub const XCHAL_INTLEVEL7_MASK: u32 = 16384;
pub const XCHAL_INTLEVEL1_ANDBELOW_MASK: u32 = 407551;
pub const XCHAL_INTLEVEL2_ANDBELOW_MASK: u32 = 4077567;
pub const XCHAL_INTLEVEL3_ANDBELOW_MASK: u32 = 687783935;
pub const XCHAL_INTLEVEL4_ANDBELOW_MASK: u32 = 2080292863;
pub const XCHAL_INTLEVEL5_ANDBELOW_MASK: u32 = 4294950911;
pub const XCHAL_INTLEVEL6_ANDBELOW_MASK: u32 = 4294950911;
pub const XCHAL_INTLEVEL7_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INT0_LEVEL: u32 = 1;
pub const XCHAL_INT1_LEVEL: u32 = 1;
pub const XCHAL_INT2_LEVEL: u32 = 1;
pub const XCHAL_INT3_LEVEL: u32 = 1;
pub const XCHAL_INT4_LEVEL: u32 = 1;
pub const XCHAL_INT5_LEVEL: u32 = 1;
pub const XCHAL_INT6_LEVEL: u32 = 1;
pub const XCHAL_INT7_LEVEL: u32 = 1;
pub const XCHAL_INT8_LEVEL: u32 = 1;
pub const XCHAL_INT9_LEVEL: u32 = 1;
pub const XCHAL_INT10_LEVEL: u32 = 1;
pub const XCHAL_INT11_LEVEL: u32 = 3;
pub const XCHAL_INT12_LEVEL: u32 = 1;
pub const XCHAL_INT13_LEVEL: u32 = 1;
pub const XCHAL_INT14_LEVEL: u32 = 7;
pub const XCHAL_INT15_LEVEL: u32 = 3;
pub const XCHAL_INT16_LEVEL: u32 = 5;
pub const XCHAL_INT17_LEVEL: u32 = 1;
pub const XCHAL_INT18_LEVEL: u32 = 1;
pub const XCHAL_INT19_LEVEL: u32 = 2;
pub const XCHAL_INT20_LEVEL: u32 = 2;
pub const XCHAL_INT21_LEVEL: u32 = 2;
pub const XCHAL_INT22_LEVEL: u32 = 3;
pub const XCHAL_INT23_LEVEL: u32 = 3;
pub const XCHAL_INT24_LEVEL: u32 = 4;
pub const XCHAL_INT25_LEVEL: u32 = 4;
pub const XCHAL_INT26_LEVEL: u32 = 5;
pub const XCHAL_INT27_LEVEL: u32 = 3;
pub const XCHAL_INT28_LEVEL: u32 = 4;
pub const XCHAL_INT29_LEVEL: u32 = 3;
pub const XCHAL_INT30_LEVEL: u32 = 4;
pub const XCHAL_INT31_LEVEL: u32 = 5;
pub const XCHAL_DEBUGLEVEL: u32 = 6;
pub const XCHAL_HAVE_DEBUG_EXTERN_INT: u32 = 1;
pub const XCHAL_NMILEVEL: u32 = 7;
pub const XCHAL_INTTYPE_MASK_UNCONFIGURED: u32 = 0;
pub const XCHAL_INTTYPE_MASK_SOFTWARE: u32 = 536871040;
pub const XCHAL_INTTYPE_MASK_EXTERN_EDGE: u32 = 1346372608;
pub const XCHAL_INTTYPE_MASK_EXTERN_LEVEL: u32 = 2411606847;
pub const XCHAL_INTTYPE_MASK_TIMER: u32 = 98368;
pub const XCHAL_INTTYPE_MASK_NMI: u32 = 16384;
pub const XCHAL_INTTYPE_MASK_WRITE_ERROR: u32 = 0;
pub const XCHAL_INTTYPE_MASK_PROFILING: u32 = 2048;
pub const XCHAL_TIMER0_INTERRUPT: u32 = 6;
pub const XCHAL_TIMER1_INTERRUPT: u32 = 15;
pub const XCHAL_TIMER2_INTERRUPT: u32 = 16;
pub const XCHAL_NMI_INTERRUPT: u32 = 14;
pub const XCHAL_PROFILING_INTERRUPT: u32 = 11;
pub const XCHAL_INTLEVEL7_NUM: u32 = 14;
pub const XCHAL_EXTINT0_NUM: u32 = 0;
pub const XCHAL_EXTINT1_NUM: u32 = 1;
pub const XCHAL_EXTINT2_NUM: u32 = 2;
pub const XCHAL_EXTINT3_NUM: u32 = 3;
pub const XCHAL_EXTINT4_NUM: u32 = 4;
pub const XCHAL_EXTINT5_NUM: u32 = 5;
pub const XCHAL_EXTINT6_NUM: u32 = 8;
pub const XCHAL_EXTINT7_NUM: u32 = 9;
pub const XCHAL_EXTINT8_NUM: u32 = 10;
pub const XCHAL_EXTINT9_NUM: u32 = 12;
pub const XCHAL_EXTINT10_NUM: u32 = 13;
pub const XCHAL_EXTINT11_NUM: u32 = 14;
pub const XCHAL_EXTINT12_NUM: u32 = 17;
pub const XCHAL_EXTINT13_NUM: u32 = 18;
pub const XCHAL_EXTINT14_NUM: u32 = 19;
pub const XCHAL_EXTINT15_NUM: u32 = 20;
pub const XCHAL_EXTINT16_NUM: u32 = 21;
pub const XCHAL_EXTINT17_NUM: u32 = 22;
pub const XCHAL_EXTINT18_NUM: u32 = 23;
pub const XCHAL_EXTINT19_NUM: u32 = 24;
pub const XCHAL_EXTINT20_NUM: u32 = 25;
pub const XCHAL_EXTINT21_NUM: u32 = 26;
pub const XCHAL_EXTINT22_NUM: u32 = 27;
pub const XCHAL_EXTINT23_NUM: u32 = 28;
pub const XCHAL_EXTINT24_NUM: u32 = 30;
pub const XCHAL_EXTINT25_NUM: u32 = 31;
pub const XCHAL_INT0_EXTNUM: u32 = 0;
pub const XCHAL_INT1_EXTNUM: u32 = 1;
pub const XCHAL_INT2_EXTNUM: u32 = 2;
pub const XCHAL_INT3_EXTNUM: u32 = 3;
pub const XCHAL_INT4_EXTNUM: u32 = 4;
pub const XCHAL_INT5_EXTNUM: u32 = 5;
pub const XCHAL_INT8_EXTNUM: u32 = 6;
pub const XCHAL_INT9_EXTNUM: u32 = 7;
pub const XCHAL_INT10_EXTNUM: u32 = 8;
pub const XCHAL_INT12_EXTNUM: u32 = 9;
pub const XCHAL_INT13_EXTNUM: u32 = 10;
pub const XCHAL_INT14_EXTNUM: u32 = 11;
pub const XCHAL_INT17_EXTNUM: u32 = 12;
pub const XCHAL_INT18_EXTNUM: u32 = 13;
pub const XCHAL_INT19_EXTNUM: u32 = 14;
pub const XCHAL_INT20_EXTNUM: u32 = 15;
pub const XCHAL_INT21_EXTNUM: u32 = 16;
pub const XCHAL_INT22_EXTNUM: u32 = 17;
pub const XCHAL_INT23_EXTNUM: u32 = 18;
pub const XCHAL_INT24_EXTNUM: u32 = 19;
pub const XCHAL_INT25_EXTNUM: u32 = 20;
pub const XCHAL_INT26_EXTNUM: u32 = 21;
pub const XCHAL_INT27_EXTNUM: u32 = 22;
pub const XCHAL_INT28_EXTNUM: u32 = 23;
pub const XCHAL_INT30_EXTNUM: u32 = 24;
pub const XCHAL_INT31_EXTNUM: u32 = 25;
pub const XCHAL_XEA_VERSION: u32 = 2;
pub const XCHAL_HAVE_XEA1: u32 = 0;
pub const XCHAL_HAVE_XEA2: u32 = 1;
pub const XCHAL_HAVE_XEAX: u32 = 0;
pub const XCHAL_HAVE_EXCEPTIONS: u32 = 1;
pub const XCHAL_HAVE_HALT: u32 = 0;
pub const XCHAL_HAVE_BOOTLOADER: u32 = 0;
pub const XCHAL_HAVE_MEM_ECC_PARITY: u32 = 0;
pub const XCHAL_HAVE_VECTOR_SELECT: u32 = 1;
pub const XCHAL_HAVE_VECBASE: u32 = 1;
pub const XCHAL_VECBASE_RESET_VADDR: u32 = 1073741824;
pub const XCHAL_VECBASE_RESET_PADDR: u32 = 1073741824;
pub const XCHAL_RESET_VECBASE_OVERLAP: u32 = 0;
pub const XCHAL_RESET_VECTOR0_VADDR: u32 = 1342177280;
pub const XCHAL_RESET_VECTOR0_PADDR: u32 = 1342177280;
pub const XCHAL_RESET_VECTOR1_VADDR: u32 = 1073742848;
pub const XCHAL_RESET_VECTOR1_PADDR: u32 = 1073742848;
pub const XCHAL_RESET_VECTOR_VADDR: u32 = 1073742848;
pub const XCHAL_RESET_VECTOR_PADDR: u32 = 1073742848;
pub const XCHAL_USER_VECOFS: u32 = 832;
pub const XCHAL_USER_VECTOR_VADDR: u32 = 1073742656;
pub const XCHAL_USER_VECTOR_PADDR: u32 = 1073742656;
pub const XCHAL_KERNEL_VECOFS: u32 = 768;
pub const XCHAL_KERNEL_VECTOR_VADDR: u32 = 1073742592;
pub const XCHAL_KERNEL_VECTOR_PADDR: u32 = 1073742592;
pub const XCHAL_DOUBLEEXC_VECOFS: u32 = 960;
pub const XCHAL_DOUBLEEXC_VECTOR_VADDR: u32 = 1073742784;
pub const XCHAL_DOUBLEEXC_VECTOR_PADDR: u32 = 1073742784;
pub const XCHAL_WINDOW_OF4_VECOFS: u32 = 0;
pub const XCHAL_WINDOW_UF4_VECOFS: u32 = 64;
pub const XCHAL_WINDOW_OF8_VECOFS: u32 = 128;
pub const XCHAL_WINDOW_UF8_VECOFS: u32 = 192;
pub const XCHAL_WINDOW_OF12_VECOFS: u32 = 256;
pub const XCHAL_WINDOW_UF12_VECOFS: u32 = 320;
pub const XCHAL_WINDOW_VECTORS_VADDR: u32 = 1073741824;
pub const XCHAL_WINDOW_VECTORS_PADDR: u32 = 1073741824;
pub const XCHAL_INTLEVEL2_VECOFS: u32 = 384;
pub const XCHAL_INTLEVEL2_VECTOR_VADDR: u32 = 1073742208;
pub const XCHAL_INTLEVEL2_VECTOR_PADDR: u32 = 1073742208;
pub const XCHAL_INTLEVEL3_VECOFS: u32 = 448;
pub const XCHAL_INTLEVEL3_VECTOR_VADDR: u32 = 1073742272;
pub const XCHAL_INTLEVEL3_VECTOR_PADDR: u32 = 1073742272;
pub const XCHAL_INTLEVEL4_VECOFS: u32 = 512;
pub const XCHAL_INTLEVEL4_VECTOR_VADDR: u32 = 1073742336;
pub const XCHAL_INTLEVEL4_VECTOR_PADDR: u32 = 1073742336;
pub const XCHAL_INTLEVEL5_VECOFS: u32 = 576;
pub const XCHAL_INTLEVEL5_VECTOR_VADDR: u32 = 1073742400;
pub const XCHAL_INTLEVEL5_VECTOR_PADDR: u32 = 1073742400;
pub const XCHAL_INTLEVEL6_VECOFS: u32 = 640;
pub const XCHAL_INTLEVEL6_VECTOR_VADDR: u32 = 1073742464;
pub const XCHAL_INTLEVEL6_VECTOR_PADDR: u32 = 1073742464;
pub const XCHAL_DEBUG_VECOFS: u32 = 640;
pub const XCHAL_DEBUG_VECTOR_VADDR: u32 = 1073742464;
pub const XCHAL_DEBUG_VECTOR_PADDR: u32 = 1073742464;
pub const XCHAL_NMI_VECOFS: u32 = 704;
pub const XCHAL_NMI_VECTOR_VADDR: u32 = 1073742528;
pub const XCHAL_NMI_VECTOR_PADDR: u32 = 1073742528;
pub const XCHAL_INTLEVEL7_VECOFS: u32 = 704;
pub const XCHAL_INTLEVEL7_VECTOR_VADDR: u32 = 1073742528;
pub const XCHAL_INTLEVEL7_VECTOR_PADDR: u32 = 1073742528;
pub const XCHAL_HAVE_DEBUG_ERI: u32 = 1;
pub const XCHAL_HAVE_DEBUG_APB: u32 = 1;
pub const XCHAL_HAVE_DEBUG_JTAG: u32 = 1;
pub const XCHAL_HAVE_OCD: u32 = 1;
pub const XCHAL_NUM_IBREAK: u32 = 2;
pub const XCHAL_NUM_DBREAK: u32 = 2;
pub const XCHAL_HAVE_OCD_DIR_ARRAY: u32 = 0;
pub const XCHAL_HAVE_OCD_LS32DDR: u32 = 1;
pub const XCHAL_HAVE_TRAX: u32 = 1;
pub const XCHAL_TRAX_MEM_SIZE: u32 = 16384;
pub const XCHAL_TRAX_MEM_SHAREABLE: u32 = 1;
pub const XCHAL_TRAX_ATB_WIDTH: u32 = 32;
pub const XCHAL_TRAX_TIME_WIDTH: u32 = 0;
pub const XCHAL_NUM_PERF_COUNTERS: u32 = 2;
pub const XCHAL_HAVE_TLBS: u32 = 1;
pub const XCHAL_HAVE_SPANNING_WAY: u32 = 1;
pub const XCHAL_SPANNING_WAY: u32 = 0;
pub const XCHAL_HAVE_IDENTITY_MAP: u32 = 1;
pub const XCHAL_HAVE_CACHEATTR: u32 = 0;
pub const XCHAL_HAVE_MIMIC_CACHEATTR: u32 = 1;
pub const XCHAL_HAVE_XLT_CACHEATTR: u32 = 0;
pub const XCHAL_HAVE_PTP_MMU: u32 = 0;
pub const XCHAL_MMU_ASID_BITS: u32 = 0;
pub const XCHAL_MMU_RINGS: u32 = 1;
pub const XCHAL_MMU_RING_BITS: u32 = 0;
pub const __BUFSIZ__: u32 = 128;
pub const __RAND_MAX: u32 = 2147483647;
pub const BIT31: u32 = 2147483648;
pub const BIT30: u32 = 1073741824;
pub const BIT29: u32 = 536870912;
pub const BIT28: u32 = 268435456;
pub const BIT27: u32 = 134217728;
pub const BIT26: u32 = 67108864;
pub const BIT25: u32 = 33554432;
pub const BIT24: u32 = 16777216;
pub const BIT23: u32 = 8388608;
pub const BIT22: u32 = 4194304;
pub const BIT21: u32 = 2097152;
pub const BIT20: u32 = 1048576;
pub const BIT19: u32 = 524288;
pub const BIT18: u32 = 262144;
pub const BIT17: u32 = 131072;
pub const BIT16: u32 = 65536;
pub const BIT15: u32 = 32768;
pub const BIT14: u32 = 16384;
pub const BIT13: u32 = 8192;
pub const BIT12: u32 = 4096;
pub const BIT11: u32 = 2048;
pub const BIT10: u32 = 1024;
pub const BIT9: u32 = 512;
pub const BIT8: u32 = 256;
pub const BIT7: u32 = 128;
pub const BIT6: u32 = 64;
pub const BIT5: u32 = 32;
pub const BIT4: u32 = 16;
pub const BIT3: u32 = 8;
pub const BIT2: u32 = 4;
pub const BIT1: u32 = 2;
pub const BIT0: u32 = 1;
pub const PRO_CPU_NUM: u32 = 0;
pub const APP_CPU_NUM: u32 = 1;
pub const SOC_IROM_LOW: u32 = 1074593792;
pub const SOC_IROM_HIGH: u32 = 1077936128;
pub const SOC_DROM_LOW: u32 = 1061158912;
pub const SOC_DROM_HIGH: u32 = 1065353216;
pub const SOC_DRAM_LOW: u32 = 1073405952;
pub const SOC_DRAM_HIGH: u32 = 1073741824;
pub const SOC_RTC_IRAM_LOW: u32 = 1074528256;
pub const SOC_RTC_IRAM_HIGH: u32 = 1074536448;
pub const SOC_RTC_DATA_LOW: u32 = 1342177280;
pub const SOC_RTC_DATA_HIGH: u32 = 1342185472;
pub const SOC_EXTRAM_DATA_LOW: u32 = 1065353216;
pub const SOC_EXTRAM_DATA_HIGH: u32 = 1069547520;
pub const SOC_MAX_CONTIGUOUS_RAM_SIZE: u32 = 4194304;
pub const DR_REG_DPORT_BASE: u32 = 1072693248;
pub const DR_REG_AES_BASE: u32 = 1072697344;
pub const DR_REG_RSA_BASE: u32 = 1072701440;
pub const DR_REG_SHA_BASE: u32 = 1072705536;
pub const DR_REG_FLASH_MMU_TABLE_PRO: u32 = 1072758784;
pub const DR_REG_FLASH_MMU_TABLE_APP: u32 = 1072766976;
pub const DR_REG_DPORT_END: u32 = 1072775164;
pub const DR_REG_UART_BASE: u32 = 1072955392;
pub const DR_REG_SPI1_BASE: u32 = 1072963584;
pub const DR_REG_SPI0_BASE: u32 = 1072967680;
pub const DR_REG_GPIO_BASE: u32 = 1072971776;
pub const DR_REG_GPIO_SD_BASE: u32 = 1072975616;
pub const DR_REG_FE2_BASE: u32 = 1072975872;
pub const DR_REG_FE_BASE: u32 = 1072979968;
pub const DR_REG_FRC_TIMER_BASE: u32 = 1072984064;
pub const DR_REG_RTCCNTL_BASE: u32 = 1072988160;
pub const DR_REG_RTCIO_BASE: u32 = 1072989184;
pub const DR_REG_SENS_BASE: u32 = 1072990208;
pub const DR_REG_RTC_I2C_BASE: u32 = 1072991232;
pub const DR_REG_IO_MUX_BASE: u32 = 1072992256;
pub const DR_REG_HINF_BASE: u32 = 1073000448;
pub const DR_REG_UHCI1_BASE: u32 = 1073004544;
pub const DR_REG_I2S_BASE: u32 = 1073016832;
pub const DR_REG_UART1_BASE: u32 = 1073020928;
pub const DR_REG_BT_BASE: u32 = 1073025024;
pub const DR_REG_I2C_EXT_BASE: u32 = 1073033216;
pub const DR_REG_UHCI0_BASE: u32 = 1073037312;
pub const DR_REG_SLCHOST_BASE: u32 = 1073041408;
pub const DR_REG_RMT_BASE: u32 = 1073045504;
pub const DR_REG_PCNT_BASE: u32 = 1073049600;
pub const DR_REG_SLC_BASE: u32 = 1073053696;
pub const DR_REG_LEDC_BASE: u32 = 1073057792;
pub const DR_REG_EFUSE_BASE: u32 = 1073061888;
pub const DR_REG_SPI_ENCRYPT_BASE: u32 = 1073065984;
pub const DR_REG_NRX_BASE: u32 = 1073073152;
pub const DR_REG_BB_BASE: u32 = 1073074176;
pub const DR_REG_PWM_BASE: u32 = 1073078272;
pub const DR_REG_TIMERGROUP0_BASE: u32 = 1073082368;
pub const DR_REG_TIMERGROUP1_BASE: u32 = 1073086464;
pub const DR_REG_RTCMEM0_BASE: u32 = 1073090560;
pub const DR_REG_RTCMEM1_BASE: u32 = 1073094656;
pub const DR_REG_RTCMEM2_BASE: u32 = 1073098752;
pub const DR_REG_SPI2_BASE: u32 = 1073102848;
pub const DR_REG_SPI3_BASE: u32 = 1073106944;
pub const DR_REG_SYSCON_BASE: u32 = 1073111040;
pub const DR_REG_APB_CTRL_BASE: u32 = 1073111040;
pub const DR_REG_I2C1_EXT_BASE: u32 = 1073115136;
pub const DR_REG_SDMMC_BASE: u32 = 1073119232;
pub const DR_REG_EMAC_BASE: u32 = 1073123328;
pub const DR_REG_CAN_BASE: u32 = 1073131520;
pub const DR_REG_PWM1_BASE: u32 = 1073135616;
pub const DR_REG_I2S1_BASE: u32 = 1073139712;
pub const DR_REG_UART2_BASE: u32 = 1073143808;
pub const DR_REG_PWM2_BASE: u32 = 1073147904;
pub const DR_REG_PWM3_BASE: u32 = 1073152000;
pub const PERIPHS_SPI_ENCRYPT_BASEADDR: u32 = 1073065984;
pub const APB_CLK_FREQ_ROM: u32 = 26000000;
pub const CPU_CLK_FREQ_ROM: u32 = 26000000;
pub const APB_CLK_FREQ: u32 = 80000000;
pub const REF_CLK_FREQ: u32 = 1000000;
pub const UART_CLK_FREQ: u32 = 80000000;
pub const WDT_CLK_FREQ: u32 = 80000000;
pub const TIMER_CLK_FREQ: u32 = 5000000;
pub const SPI_CLK_DIV: u32 = 4;
pub const TICKS_PER_US_ROM: u32 = 26;
pub const GPIO_MATRIX_DELAY_NS: u32 = 25;
pub const SOC_IROM_MASK_LOW: u32 = 1073741824;
pub const SOC_IROM_MASK_HIGH: u32 = 1074200576;
pub const SOC_CACHE_PRO_LOW: u32 = 1074200576;
pub const SOC_CACHE_PRO_HIGH: u32 = 1074233344;
pub const SOC_CACHE_APP_LOW: u32 = 1074233344;
pub const SOC_CACHE_APP_HIGH: u32 = 1074266112;
pub const SOC_IRAM_LOW: u32 = 1074266112;
pub const SOC_IRAM_HIGH: u32 = 1074397184;
pub const SOC_RTC_DRAM_LOW: u32 = 1073217536;
pub const SOC_RTC_DRAM_HIGH: u32 = 1073225728;
pub const SOC_DIRAM_IRAM_LOW: u32 = 1074397184;
pub const SOC_DIRAM_IRAM_HIGH: u32 = 1074528252;
pub const SOC_DIRAM_DRAM_LOW: u32 = 1073610752;
pub const SOC_DIRAM_DRAM_HIGH: u32 = 1073741820;
pub const SOC_DMA_LOW: u32 = 1073405952;
pub const SOC_DMA_HIGH: u32 = 1073741824;
pub const SOC_BYTE_ACCESSIBLE_LOW: u32 = 1073283072;
pub const SOC_BYTE_ACCESSIBLE_HIGH: u32 = 1073741824;
pub const SOC_MEM_INTERNAL_LOW: u32 = 1073283072;
pub const SOC_MEM_INTERNAL_HIGH: u32 = 1074536448;
pub const ETS_WIFI_MAC_INTR_SOURCE: u32 = 0;
pub const ETS_WIFI_MAC_NMI_SOURCE: u32 = 1;
pub const ETS_WIFI_BB_INTR_SOURCE: u32 = 2;
pub const ETS_BT_MAC_INTR_SOURCE: u32 = 3;
pub const ETS_BT_BB_INTR_SOURCE: u32 = 4;
pub const ETS_BT_BB_NMI_SOURCE: u32 = 5;
pub const ETS_RWBT_INTR_SOURCE: u32 = 6;
pub const ETS_RWBLE_INTR_SOURCE: u32 = 7;
pub const ETS_RWBT_NMI_SOURCE: u32 = 8;
pub const ETS_RWBLE_NMI_SOURCE: u32 = 9;
pub const ETS_SLC0_INTR_SOURCE: u32 = 10;
pub const ETS_SLC1_INTR_SOURCE: u32 = 11;
pub const ETS_UHCI0_INTR_SOURCE: u32 = 12;
pub const ETS_UHCI1_INTR_SOURCE: u32 = 13;
pub const ETS_TG0_T0_LEVEL_INTR_SOURCE: u32 = 14;
pub const ETS_TG0_T1_LEVEL_INTR_SOURCE: u32 = 15;
pub const ETS_TG0_WDT_LEVEL_INTR_SOURCE: u32 = 16;
pub const ETS_TG0_LACT_LEVEL_INTR_SOURCE: u32 = 17;
pub const ETS_TG1_T0_LEVEL_INTR_SOURCE: u32 = 18;
pub const ETS_TG1_T1_LEVEL_INTR_SOURCE: u32 = 19;
pub const ETS_TG1_WDT_LEVEL_INTR_SOURCE: u32 = 20;
pub const ETS_TG1_LACT_LEVEL_INTR_SOURCE: u32 = 21;
pub const ETS_GPIO_INTR_SOURCE: u32 = 22;
pub const ETS_GPIO_NMI_SOURCE: u32 = 23;
pub const ETS_FROM_CPU_INTR0_SOURCE: u32 = 24;
pub const ETS_FROM_CPU_INTR1_SOURCE: u32 = 25;
pub const ETS_FROM_CPU_INTR2_SOURCE: u32 = 26;
pub const ETS_FROM_CPU_INTR3_SOURCE: u32 = 27;
pub const ETS_SPI0_INTR_SOURCE: u32 = 28;
pub const ETS_SPI1_INTR_SOURCE: u32 = 29;
pub const ETS_SPI2_INTR_SOURCE: u32 = 30;
pub const ETS_SPI3_INTR_SOURCE: u32 = 31;
pub const ETS_I2S0_INTR_SOURCE: u32 = 32;
pub const ETS_I2S1_INTR_SOURCE: u32 = 33;
pub const ETS_UART0_INTR_SOURCE: u32 = 34;
pub const ETS_UART1_INTR_SOURCE: u32 = 35;
pub const ETS_UART2_INTR_SOURCE: u32 = 36;
pub const ETS_SDIO_HOST_INTR_SOURCE: u32 = 37;
pub const ETS_ETH_MAC_INTR_SOURCE: u32 = 38;
pub const ETS_PWM0_INTR_SOURCE: u32 = 39;
pub const ETS_PWM1_INTR_SOURCE: u32 = 40;
pub const ETS_PWM2_INTR_SOURCE: u32 = 41;
pub const ETS_PWM3_INTR_SOURCE: u32 = 42;
pub const ETS_LEDC_INTR_SOURCE: u32 = 43;
pub const ETS_EFUSE_INTR_SOURCE: u32 = 44;
pub const ETS_CAN_INTR_SOURCE: u32 = 45;
pub const ETS_RTC_CORE_INTR_SOURCE: u32 = 46;
pub const ETS_RMT_INTR_SOURCE: u32 = 47;
pub const ETS_PCNT_INTR_SOURCE: u32 = 48;
pub const ETS_I2C_EXT0_INTR_SOURCE: u32 = 49;
pub const ETS_I2C_EXT1_INTR_SOURCE: u32 = 50;
pub const ETS_RSA_INTR_SOURCE: u32 = 51;
pub const ETS_SPI1_DMA_INTR_SOURCE: u32 = 52;
pub const ETS_SPI2_DMA_INTR_SOURCE: u32 = 53;
pub const ETS_SPI3_DMA_INTR_SOURCE: u32 = 54;
pub const ETS_WDT_INTR_SOURCE: u32 = 55;
pub const ETS_TIMER1_INTR_SOURCE: u32 = 56;
pub const ETS_TIMER2_INTR_SOURCE: u32 = 57;
pub const ETS_TG0_T0_EDGE_INTR_SOURCE: u32 = 58;
pub const ETS_TG0_T1_EDGE_INTR_SOURCE: u32 = 59;
pub const ETS_TG0_WDT_EDGE_INTR_SOURCE: u32 = 60;
pub const ETS_TG0_LACT_EDGE_INTR_SOURCE: u32 = 61;
pub const ETS_TG1_T0_EDGE_INTR_SOURCE: u32 = 62;
pub const ETS_TG1_T1_EDGE_INTR_SOURCE: u32 = 63;
pub const ETS_TG1_WDT_EDGE_INTR_SOURCE: u32 = 64;
pub const ETS_TG1_LACT_EDGE_INTR_SOURCE: u32 = 65;
pub const ETS_MMU_IA_INTR_SOURCE: u32 = 66;
pub const ETS_MPU_IA_INTR_SOURCE: u32 = 67;
pub const ETS_CACHE_IA_INTR_SOURCE: u32 = 68;
pub const ETS_WMAC_INUM: u32 = 0;
pub const ETS_BT_HOST_INUM: u32 = 1;
pub const ETS_WBB_INUM: u32 = 4;
pub const ETS_TG0_T1_INUM: u32 = 10;
pub const ETS_FRC1_INUM: u32 = 22;
pub const ETS_T1_WDT_INUM: u32 = 24;
pub const ETS_CACHEERR_INUM: u32 = 25;
pub const ETS_DPORT_INUM: u32 = 28;
pub const ETS_SLC_INUM: u32 = 1;
pub const ETS_UART0_INUM: u32 = 5;
pub const ETS_UART1_INUM: u32 = 5;
pub const ETS_INVALID_INUM: u32 = 6;
pub const UART_RXFIFO_RD_BYTE: u32 = 255;
pub const UART_RXFIFO_RD_BYTE_V: u32 = 255;
pub const UART_RXFIFO_RD_BYTE_S: u32 = 0;
pub const UART_AT_CMD_CHAR_DET_INT_RAW_V: u32 = 1;
pub const UART_AT_CMD_CHAR_DET_INT_RAW_S: u32 = 18;
pub const UART_RS485_CLASH_INT_RAW_V: u32 = 1;
pub const UART_RS485_CLASH_INT_RAW_S: u32 = 17;
pub const UART_RS485_FRM_ERR_INT_RAW_V: u32 = 1;
pub const UART_RS485_FRM_ERR_INT_RAW_S: u32 = 16;
pub const UART_RS485_PARITY_ERR_INT_RAW_V: u32 = 1;
pub const UART_RS485_PARITY_ERR_INT_RAW_S: u32 = 15;
pub const UART_TX_DONE_INT_RAW_V: u32 = 1;
pub const UART_TX_DONE_INT_RAW_S: u32 = 14;
pub const UART_TX_BRK_IDLE_DONE_INT_RAW_V: u32 = 1;
pub const UART_TX_BRK_IDLE_DONE_INT_RAW_S: u32 = 13;
pub const UART_TX_BRK_DONE_INT_RAW_V: u32 = 1;
pub const UART_TX_BRK_DONE_INT_RAW_S: u32 = 12;
pub const UART_GLITCH_DET_INT_RAW_V: u32 = 1;
pub const UART_GLITCH_DET_INT_RAW_S: u32 = 11;
pub const UART_SW_XOFF_INT_RAW_V: u32 = 1;
pub const UART_SW_XOFF_INT_RAW_S: u32 = 10;
pub const UART_SW_XON_INT_RAW_V: u32 = 1;
pub const UART_SW_XON_INT_RAW_S: u32 = 9;
pub const UART_RXFIFO_TOUT_INT_RAW_V: u32 = 1;
pub const UART_RXFIFO_TOUT_INT_RAW_S: u32 = 8;
pub const UART_BRK_DET_INT_RAW_V: u32 = 1;
pub const UART_BRK_DET_INT_RAW_S: u32 = 7;
pub const UART_CTS_CHG_INT_RAW_V: u32 = 1;
pub const UART_CTS_CHG_INT_RAW_S: u32 = 6;
pub const UART_DSR_CHG_INT_RAW_V: u32 = 1;
pub const UART_DSR_CHG_INT_RAW_S: u32 = 5;
pub const UART_RXFIFO_OVF_INT_RAW_V: u32 = 1;
pub const UART_RXFIFO_OVF_INT_RAW_S: u32 = 4;
pub const UART_FRM_ERR_INT_RAW_V: u32 = 1;
pub const UART_FRM_ERR_INT_RAW_S: u32 = 3;
pub const UART_PARITY_ERR_INT_RAW_V: u32 = 1;
pub const UART_PARITY_ERR_INT_RAW_S: u32 = 2;
pub const UART_TXFIFO_EMPTY_INT_RAW_V: u32 = 1;
pub const UART_TXFIFO_EMPTY_INT_RAW_S: u32 = 1;
pub const UART_RXFIFO_FULL_INT_RAW_V: u32 = 1;
pub const UART_RXFIFO_FULL_INT_RAW_S: u32 = 0;
pub const UART_AT_CMD_CHAR_DET_INT_ST_V: u32 = 1;
pub const UART_AT_CMD_CHAR_DET_INT_ST_S: u32 = 18;
pub const UART_RS485_CLASH_INT_ST_V: u32 = 1;
pub const UART_RS485_CLASH_INT_ST_S: u32 = 17;
pub const UART_RS485_FRM_ERR_INT_ST_V: u32 = 1;
pub const UART_RS485_FRM_ERR_INT_ST_S: u32 = 16;
pub const UART_RS485_PARITY_ERR_INT_ST_V: u32 = 1;
pub const UART_RS485_PARITY_ERR_INT_ST_S: u32 = 15;
pub const UART_TX_DONE_INT_ST_V: u32 = 1;
pub const UART_TX_DONE_INT_ST_S: u32 = 14;
pub const UART_TX_BRK_IDLE_DONE_INT_ST_V: u32 = 1;
pub const UART_TX_BRK_IDLE_DONE_INT_ST_S: u32 = 13;
pub const UART_TX_BRK_DONE_INT_ST_V: u32 = 1;
pub const UART_TX_BRK_DONE_INT_ST_S: u32 = 12;
pub const UART_GLITCH_DET_INT_ST_V: u32 = 1;
pub const UART_GLITCH_DET_INT_ST_S: u32 = 11;
pub const UART_SW_XOFF_INT_ST_V: u32 = 1;
pub const UART_SW_XOFF_INT_ST_S: u32 = 10;
pub const UART_SW_XON_INT_ST_V: u32 = 1;
pub const UART_SW_XON_INT_ST_S: u32 = 9;
pub const UART_RXFIFO_TOUT_INT_ST_V: u32 = 1;
pub const UART_RXFIFO_TOUT_INT_ST_S: u32 = 8;
pub const UART_BRK_DET_INT_ST_V: u32 = 1;
pub const UART_BRK_DET_INT_ST_S: u32 = 7;
pub const UART_CTS_CHG_INT_ST_V: u32 = 1;
pub const UART_CTS_CHG_INT_ST_S: u32 = 6;
pub const UART_DSR_CHG_INT_ST_V: u32 = 1;
pub const UART_DSR_CHG_INT_ST_S: u32 = 5;
pub const UART_RXFIFO_OVF_INT_ST_V: u32 = 1;
pub const UART_RXFIFO_OVF_INT_ST_S: u32 = 4;
pub const UART_FRM_ERR_INT_ST_V: u32 = 1;
pub const UART_FRM_ERR_INT_ST_S: u32 = 3;
pub const UART_PARITY_ERR_INT_ST_V: u32 = 1;
pub const UART_PARITY_ERR_INT_ST_S: u32 = 2;
pub const UART_TXFIFO_EMPTY_INT_ST_V: u32 = 1;
pub const UART_TXFIFO_EMPTY_INT_ST_S: u32 = 1;
pub const UART_RXFIFO_FULL_INT_ST_V: u32 = 1;
pub const UART_RXFIFO_FULL_INT_ST_S: u32 = 0;
pub const UART_AT_CMD_CHAR_DET_INT_ENA_V: u32 = 1;
pub const UART_AT_CMD_CHAR_DET_INT_ENA_S: u32 = 18;
pub const UART_RS485_CLASH_INT_ENA_V: u32 = 1;
pub const UART_RS485_CLASH_INT_ENA_S: u32 = 17;
pub const UART_RS485_FRM_ERR_INT_ENA_V: u32 = 1;
pub const UART_RS485_FRM_ERR_INT_ENA_S: u32 = 16;
pub const UART_RS485_PARITY_ERR_INT_ENA_V: u32 = 1;
pub const UART_RS485_PARITY_ERR_INT_ENA_S: u32 = 15;
pub const UART_TX_DONE_INT_ENA_V: u32 = 1;
pub const UART_TX_DONE_INT_ENA_S: u32 = 14;
pub const UART_TX_BRK_IDLE_DONE_INT_ENA_V: u32 = 1;
pub const UART_TX_BRK_IDLE_DONE_INT_ENA_S: u32 = 13;
pub const UART_TX_BRK_DONE_INT_ENA_V: u32 = 1;
pub const UART_TX_BRK_DONE_INT_ENA_S: u32 = 12;
pub const UART_GLITCH_DET_INT_ENA_V: u32 = 1;
pub const UART_GLITCH_DET_INT_ENA_S: u32 = 11;
pub const UART_SW_XOFF_INT_ENA_V: u32 = 1;
pub const UART_SW_XOFF_INT_ENA_S: u32 = 10;
pub const UART_SW_XON_INT_ENA_V: u32 = 1;
pub const UART_SW_XON_INT_ENA_S: u32 = 9;
pub const UART_RXFIFO_TOUT_INT_ENA_V: u32 = 1;
pub const UART_RXFIFO_TOUT_INT_ENA_S: u32 = 8;
pub const UART_BRK_DET_INT_ENA_V: u32 = 1;
pub const UART_BRK_DET_INT_ENA_S: u32 = 7;
pub const UART_CTS_CHG_INT_ENA_V: u32 = 1;
pub const UART_CTS_CHG_INT_ENA_S: u32 = 6;
pub const UART_DSR_CHG_INT_ENA_V: u32 = 1;
pub const UART_DSR_CHG_INT_ENA_S: u32 = 5;
pub const UART_RXFIFO_OVF_INT_ENA_V: u32 = 1;
pub const UART_RXFIFO_OVF_INT_ENA_S: u32 = 4;
pub const UART_FRM_ERR_INT_ENA_V: u32 = 1;
pub const UART_FRM_ERR_INT_ENA_S: u32 = 3;
pub const UART_PARITY_ERR_INT_ENA_V: u32 = 1;
pub const UART_PARITY_ERR_INT_ENA_S: u32 = 2;
pub const UART_TXFIFO_EMPTY_INT_ENA_V: u32 = 1;
pub const UART_TXFIFO_EMPTY_INT_ENA_S: u32 = 1;
pub const UART_RXFIFO_FULL_INT_ENA_V: u32 = 1;
pub const UART_RXFIFO_FULL_INT_ENA_S: u32 = 0;
pub const UART_AT_CMD_CHAR_DET_INT_CLR_V: u32 = 1;
pub const UART_AT_CMD_CHAR_DET_INT_CLR_S: u32 = 18;
pub const UART_RS485_CLASH_INT_CLR_V: u32 = 1;
pub const UART_RS485_CLASH_INT_CLR_S: u32 = 17;
pub const UART_RS485_FRM_ERR_INT_CLR_V: u32 = 1;
pub const UART_RS485_FRM_ERR_INT_CLR_S: u32 = 16;
pub const UART_RS485_PARITY_ERR_INT_CLR_V: u32 = 1;
pub const UART_RS485_PARITY_ERR_INT_CLR_S: u32 = 15;
pub const UART_TX_DONE_INT_CLR_V: u32 = 1;
pub const UART_TX_DONE_INT_CLR_S: u32 = 14;
pub const UART_TX_BRK_IDLE_DONE_INT_CLR_V: u32 = 1;
pub const UART_TX_BRK_IDLE_DONE_INT_CLR_S: u32 = 13;
pub const UART_TX_BRK_DONE_INT_CLR_V: u32 = 1;
pub const UART_TX_BRK_DONE_INT_CLR_S: u32 = 12;
pub const UART_GLITCH_DET_INT_CLR_V: u32 = 1;
pub const UART_GLITCH_DET_INT_CLR_S: u32 = 11;
pub const UART_SW_XOFF_INT_CLR_V: u32 = 1;
pub const UART_SW_XOFF_INT_CLR_S: u32 = 10;
pub const UART_SW_XON_INT_CLR_V: u32 = 1;
pub const UART_SW_XON_INT_CLR_S: u32 = 9;
pub const UART_RXFIFO_TOUT_INT_CLR_V: u32 = 1;
pub const UART_RXFIFO_TOUT_INT_CLR_S: u32 = 8;
pub const UART_BRK_DET_INT_CLR_V: u32 = 1;
pub const UART_BRK_DET_INT_CLR_S: u32 = 7;
pub const UART_CTS_CHG_INT_CLR_V: u32 = 1;
pub const UART_CTS_CHG_INT_CLR_S: u32 = 6;
pub const UART_DSR_CHG_INT_CLR_V: u32 = 1;
pub const UART_DSR_CHG_INT_CLR_S: u32 = 5;
pub const UART_RXFIFO_OVF_INT_CLR_V: u32 = 1;
pub const UART_RXFIFO_OVF_INT_CLR_S: u32 = 4;
pub const UART_FRM_ERR_INT_CLR_V: u32 = 1;
pub const UART_FRM_ERR_INT_CLR_S: u32 = 3;
pub const UART_PARITY_ERR_INT_CLR_V: u32 = 1;
pub const UART_PARITY_ERR_INT_CLR_S: u32 = 2;
pub const UART_TXFIFO_EMPTY_INT_CLR_V: u32 = 1;
pub const UART_TXFIFO_EMPTY_INT_CLR_S: u32 = 1;
pub const UART_RXFIFO_FULL_INT_CLR_V: u32 = 1;
pub const UART_RXFIFO_FULL_INT_CLR_S: u32 = 0;
pub const UART_CLKDIV_FRAG: u32 = 15;
pub const UART_CLKDIV_FRAG_V: u32 = 15;
pub const UART_CLKDIV_FRAG_S: u32 = 20;
pub const UART_CLKDIV: u32 = 1048575;
pub const UART_CLKDIV_V: u32 = 1048575;
pub const UART_CLKDIV_S: u32 = 0;
pub const UART_GLITCH_FILT: u32 = 255;
pub const UART_GLITCH_FILT_V: u32 = 255;
pub const UART_GLITCH_FILT_S: u32 = 8;
pub const UART_AUTOBAUD_EN_V: u32 = 1;
pub const UART_AUTOBAUD_EN_S: u32 = 0;
pub const UART_TXD_V: u32 = 1;
pub const UART_TXD_S: u32 = 31;
pub const UART_RTSN_V: u32 = 1;
pub const UART_RTSN_S: u32 = 30;
pub const UART_DTRN_V: u32 = 1;
pub const UART_DTRN_S: u32 = 29;
pub const UART_ST_UTX_OUT: u32 = 15;
pub const UART_ST_UTX_OUT_V: u32 = 15;
pub const UART_ST_UTX_OUT_S: u32 = 24;
pub const UART_TXFIFO_CNT: u32 = 255;
pub const UART_TXFIFO_CNT_V: u32 = 255;
pub const UART_TXFIFO_CNT_S: u32 = 16;
pub const UART_RXD_V: u32 = 1;
pub const UART_RXD_S: u32 = 15;
pub const UART_CTSN_V: u32 = 1;
pub const UART_CTSN_S: u32 = 14;
pub const UART_DSRN_V: u32 = 1;
pub const UART_DSRN_S: u32 = 13;
pub const UART_ST_URX_OUT: u32 = 15;
pub const UART_ST_URX_OUT_V: u32 = 15;
pub const UART_ST_URX_OUT_S: u32 = 8;
pub const UART_RXFIFO_CNT: u32 = 255;
pub const UART_RXFIFO_CNT_V: u32 = 255;
pub const UART_RXFIFO_CNT_S: u32 = 0;
pub const UART_TICK_REF_ALWAYS_ON_V: u32 = 1;
pub const UART_TICK_REF_ALWAYS_ON_S: u32 = 27;
pub const UART_ERR_WR_MASK_V: u32 = 1;
pub const UART_ERR_WR_MASK_S: u32 = 26;
pub const UART_CLK_EN_V: u32 = 1;
pub const UART_CLK_EN_S: u32 = 25;
pub const UART_DTR_INV_V: u32 = 1;
pub const UART_DTR_INV_S: u32 = 24;
pub const UART_RTS_INV_V: u32 = 1;
pub const UART_RTS_INV_S: u32 = 23;
pub const UART_TXD_INV_V: u32 = 1;
pub const UART_TXD_INV_S: u32 = 22;
pub const UART_DSR_INV_V: u32 = 1;
pub const UART_DSR_INV_S: u32 = 21;
pub const UART_CTS_INV_V: u32 = 1;
pub const UART_CTS_INV_S: u32 = 20;
pub const UART_RXD_INV_V: u32 = 1;
pub const UART_RXD_INV_S: u32 = 19;
pub const UART_TXFIFO_RST_V: u32 = 1;
pub const UART_TXFIFO_RST_S: u32 = 18;
pub const UART_RXFIFO_RST_V: u32 = 1;
pub const UART_RXFIFO_RST_S: u32 = 17;
pub const UART_IRDA_EN_V: u32 = 1;
pub const UART_IRDA_EN_S: u32 = 16;
pub const UART_TX_FLOW_EN_V: u32 = 1;
pub const UART_TX_FLOW_EN_S: u32 = 15;
pub const UART_LOOPBACK_V: u32 = 1;
pub const UART_LOOPBACK_S: u32 = 14;
pub const UART_IRDA_RX_INV_V: u32 = 1;
pub const UART_IRDA_RX_INV_S: u32 = 13;
pub const UART_IRDA_TX_INV_V: u32 = 1;
pub const UART_IRDA_TX_INV_S: u32 = 12;
pub const UART_IRDA_WCTL_V: u32 = 1;
pub const UART_IRDA_WCTL_S: u32 = 11;
pub const UART_IRDA_TX_EN_V: u32 = 1;
pub const UART_IRDA_TX_EN_S: u32 = 10;
pub const UART_IRDA_DPLX_V: u32 = 1;
pub const UART_IRDA_DPLX_S: u32 = 9;
pub const UART_TXD_BRK_V: u32 = 1;
pub const UART_TXD_BRK_S: u32 = 8;
pub const UART_SW_DTR_V: u32 = 1;
pub const UART_SW_DTR_S: u32 = 7;
pub const UART_SW_RTS_V: u32 = 1;
pub const UART_SW_RTS_S: u32 = 6;
pub const UART_STOP_BIT_NUM: u32 = 3;
pub const UART_STOP_BIT_NUM_V: u32 = 3;
pub const UART_STOP_BIT_NUM_S: u32 = 4;
pub const UART_BIT_NUM: u32 = 3;
pub const UART_BIT_NUM_V: u32 = 3;
pub const UART_BIT_NUM_S: u32 = 2;
pub const UART_PARITY_EN_V: u32 = 1;
pub const UART_PARITY_EN_S: u32 = 1;
pub const UART_PARITY_V: u32 = 1;
pub const UART_PARITY_S: u32 = 0;
pub const UART_RX_TOUT_EN_V: u32 = 1;
pub const UART_RX_TOUT_EN_S: u32 = 31;
pub const UART_RX_TOUT_THRHD: u32 = 127;
pub const UART_RX_TOUT_THRHD_V: u32 = 127;
pub const UART_RX_TOUT_THRHD_S: u32 = 24;
pub const UART_RX_FLOW_EN_V: u32 = 1;
pub const UART_RX_FLOW_EN_S: u32 = 23;
pub const UART_RX_FLOW_THRHD: u32 = 127;
pub const UART_RX_FLOW_THRHD_V: u32 = 127;
pub const UART_RX_FLOW_THRHD_S: u32 = 16;
pub const UART_TXFIFO_EMPTY_THRHD: u32 = 127;
pub const UART_TXFIFO_EMPTY_THRHD_V: u32 = 127;
pub const UART_TXFIFO_EMPTY_THRHD_S: u32 = 8;
pub const UART_RXFIFO_FULL_THRHD: u32 = 127;
pub const UART_RXFIFO_FULL_THRHD_V: u32 = 127;
pub const UART_RXFIFO_FULL_THRHD_S: u32 = 0;
pub const UART_LOWPULSE_MIN_CNT: u32 = 1048575;
pub const UART_LOWPULSE_MIN_CNT_V: u32 = 1048575;
pub const UART_LOWPULSE_MIN_CNT_S: u32 = 0;
pub const UART_HIGHPULSE_MIN_CNT: u32 = 1048575;
pub const UART_HIGHPULSE_MIN_CNT_V: u32 = 1048575;
pub const UART_HIGHPULSE_MIN_CNT_S: u32 = 0;
pub const UART_RXD_EDGE_CNT: u32 = 1023;
pub const UART_RXD_EDGE_CNT_V: u32 = 1023;
pub const UART_RXD_EDGE_CNT_S: u32 = 0;
pub const UART_SEND_XOFF_V: u32 = 1;
pub const UART_SEND_XOFF_S: u32 = 5;
pub const UART_SEND_XON_V: u32 = 1;
pub const UART_SEND_XON_S: u32 = 4;
pub const UART_FORCE_XOFF_V: u32 = 1;
pub const UART_FORCE_XOFF_S: u32 = 3;
pub const UART_FORCE_XON_V: u32 = 1;
pub const UART_FORCE_XON_S: u32 = 2;
pub const UART_XONOFF_DEL_V: u32 = 1;
pub const UART_XONOFF_DEL_S: u32 = 1;
pub const UART_SW_FLOW_CON_EN_V: u32 = 1;
pub const UART_SW_FLOW_CON_EN_S: u32 = 0;
pub const UART_ACTIVE_THRESHOLD: u32 = 1023;
pub const UART_ACTIVE_THRESHOLD_V: u32 = 1023;
pub const UART_ACTIVE_THRESHOLD_S: u32 = 0;
pub const UART_XOFF_CHAR: u32 = 255;
pub const UART_XOFF_CHAR_V: u32 = 255;
pub const UART_XOFF_CHAR_S: u32 = 24;
pub const UART_XON_CHAR: u32 = 255;
pub const UART_XON_CHAR_V: u32 = 255;
pub const UART_XON_CHAR_S: u32 = 16;
pub const UART_XOFF_THRESHOLD: u32 = 255;
pub const UART_XOFF_THRESHOLD_V: u32 = 255;
pub const UART_XOFF_THRESHOLD_S: u32 = 8;
pub const UART_XON_THRESHOLD: u32 = 255;
pub const UART_XON_THRESHOLD_V: u32 = 255;
pub const UART_XON_THRESHOLD_S: u32 = 0;
pub const UART_TX_BRK_NUM: u32 = 255;
pub const UART_TX_BRK_NUM_V: u32 = 255;
pub const UART_TX_BRK_NUM_S: u32 = 20;
pub const UART_TX_IDLE_NUM: u32 = 1023;
pub const UART_TX_IDLE_NUM_V: u32 = 1023;
pub const UART_TX_IDLE_NUM_S: u32 = 10;
pub const UART_RX_IDLE_THRHD: u32 = 1023;
pub const UART_RX_IDLE_THRHD_V: u32 = 1023;
pub const UART_RX_IDLE_THRHD_S: u32 = 0;
pub const UART_RS485_TX_DLY_NUM: u32 = 15;
pub const UART_RS485_TX_DLY_NUM_V: u32 = 15;
pub const UART_RS485_TX_DLY_NUM_S: u32 = 6;
pub const UART_RS485_RX_DLY_NUM_V: u32 = 1;
pub const UART_RS485_RX_DLY_NUM_S: u32 = 5;
pub const UART_RS485RXBY_TX_EN_V: u32 = 1;
pub const UART_RS485RXBY_TX_EN_S: u32 = 4;
pub const UART_RS485TX_RX_EN_V: u32 = 1;
pub const UART_RS485TX_RX_EN_S: u32 = 3;
pub const UART_DL1_EN_V: u32 = 1;
pub const UART_DL1_EN_S: u32 = 2;
pub const UART_DL0_EN_V: u32 = 1;
pub const UART_DL0_EN_S: u32 = 1;
pub const UART_RS485_EN_V: u32 = 1;
pub const UART_RS485_EN_S: u32 = 0;
pub const UART_PRE_IDLE_NUM: u32 = 16777215;
pub const UART_PRE_IDLE_NUM_V: u32 = 16777215;
pub const UART_PRE_IDLE_NUM_S: u32 = 0;
pub const UART_POST_IDLE_NUM: u32 = 16777215;
pub const UART_POST_IDLE_NUM_V: u32 = 16777215;
pub const UART_POST_IDLE_NUM_S: u32 = 0;
pub const UART_RX_GAP_TOUT: u32 = 16777215;
pub const UART_RX_GAP_TOUT_V: u32 = 16777215;
pub const UART_RX_GAP_TOUT_S: u32 = 0;
pub const UART_CHAR_NUM: u32 = 255;
pub const UART_CHAR_NUM_V: u32 = 255;
pub const UART_CHAR_NUM_S: u32 = 8;
pub const UART_AT_CMD_CHAR: u32 = 255;
pub const UART_AT_CMD_CHAR_V: u32 = 255;
pub const UART_AT_CMD_CHAR_S: u32 = 0;
pub const UART_TX_MEM_EMPTY_THRHD: u32 = 7;
pub const UART_TX_MEM_EMPTY_THRHD_V: u32 = 7;
pub const UART_TX_MEM_EMPTY_THRHD_S: u32 = 28;
pub const UART_RX_MEM_FULL_THRHD: u32 = 7;
pub const UART_RX_MEM_FULL_THRHD_V: u32 = 7;
pub const UART_RX_MEM_FULL_THRHD_S: u32 = 25;
pub const UART_XOFF_THRESHOLD_H2: u32 = 3;
pub const UART_XOFF_THRESHOLD_H2_V: u32 = 3;
pub const UART_XOFF_THRESHOLD_H2_S: u32 = 23;
pub const UART_XON_THRESHOLD_H2: u32 = 3;
pub const UART_XON_THRESHOLD_H2_V: u32 = 3;
pub const UART_XON_THRESHOLD_H2_S: u32 = 21;
pub const UART_RX_TOUT_THRHD_H3: u32 = 7;
pub const UART_RX_TOUT_THRHD_H3_V: u32 = 7;
pub const UART_RX_TOUT_THRHD_H3_S: u32 = 18;
pub const UART_RX_FLOW_THRHD_H3: u32 = 7;
pub const UART_RX_FLOW_THRHD_H3_V: u32 = 7;
pub const UART_RX_FLOW_THRHD_H3_S: u32 = 15;
pub const UART_TX_SIZE: u32 = 15;
pub const UART_TX_SIZE_V: u32 = 15;
pub const UART_TX_SIZE_S: u32 = 7;
pub const UART_RX_SIZE: u32 = 15;
pub const UART_RX_SIZE_V: u32 = 15;
pub const UART_RX_SIZE_S: u32 = 3;
pub const UART_MEM_PD_V: u32 = 1;
pub const UART_MEM_PD_S: u32 = 0;
pub const UART_MEM_TX_STATUS: u32 = 16777215;
pub const UART_MEM_TX_STATUS_V: u32 = 16777215;
pub const UART_MEM_TX_STATUS_S: u32 = 0;
pub const UART_MEM_RX_STATUS: u32 = 16777215;
pub const UART_MEM_RX_STATUS_V: u32 = 16777215;
pub const UART_MEM_RX_STATUS_S: u32 = 0;
pub const UART_MEM_RX_RD_ADDR: u32 = 2047;
pub const UART_MEM_RX_RD_ADDR_V: u32 = 2047;
pub const UART_MEM_RX_RD_ADDR_S: u32 = 2;
pub const UART_MEM_RX_WR_ADDR: u32 = 2047;
pub const UART_MEM_RX_WR_ADDR_V: u32 = 2047;
pub const UART_MEM_RX_WR_ADDR_S: u32 = 13;
pub const UART_TX_MEM_CNT: u32 = 7;
pub const UART_TX_MEM_CNT_V: u32 = 7;
pub const UART_TX_MEM_CNT_S: u32 = 3;
pub const UART_RX_MEM_CNT: u32 = 7;
pub const UART_RX_MEM_CNT_V: u32 = 7;
pub const UART_RX_MEM_CNT_S: u32 = 0;
pub const UART_POSEDGE_MIN_CNT: u32 = 1048575;
pub const UART_POSEDGE_MIN_CNT_V: u32 = 1048575;
pub const UART_POSEDGE_MIN_CNT_S: u32 = 0;
pub const UART_NEGEDGE_MIN_CNT: u32 = 1048575;
pub const UART_NEGEDGE_MIN_CNT_V: u32 = 1048575;
pub const UART_NEGEDGE_MIN_CNT_S: u32 = 0;
pub const UART_DATE: u32 = 4294967295;
pub const UART_DATE_V: u32 = 4294967295;
pub const UART_DATE_S: u32 = 0;
pub const UART_ID: u32 = 4294967295;
pub const UART_ID_V: u32 = 4294967295;
pub const UART_ID_S: u32 = 0;
pub const UART_NUM_0_TXD_DIRECT_GPIO_NUM: u32 = 1;
pub const UART_NUM_0_RXD_DIRECT_GPIO_NUM: u32 = 3;
pub const UART_NUM_0_CTS_DIRECT_GPIO_NUM: u32 = 19;
pub const UART_NUM_0_RTS_DIRECT_GPIO_NUM: u32 = 22;
pub const UART_NUM_1_TXD_DIRECT_GPIO_NUM: u32 = 10;
pub const UART_NUM_1_RXD_DIRECT_GPIO_NUM: u32 = 9;
pub const UART_NUM_1_CTS_DIRECT_GPIO_NUM: u32 = 6;
pub const UART_NUM_1_RTS_DIRECT_GPIO_NUM: u32 = 11;
pub const UART_NUM_2_TXD_DIRECT_GPIO_NUM: u32 = 17;
pub const UART_NUM_2_RXD_DIRECT_GPIO_NUM: u32 = 16;
pub const UART_NUM_2_CTS_DIRECT_GPIO_NUM: u32 = 8;
pub const UART_NUM_2_RTS_DIRECT_GPIO_NUM: u32 = 7;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __XSI_VISIBLE: u32 = 700;
pub const __BSD_VISIBLE: u32 = 1;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _CLOCKS_PER_SEC_: u32 = 1000;
pub const CLOCKS_PER_SEC: u32 = 1000;
pub const CLK_TCK: u32 = 1000;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 3;
pub const CLOCK_ENABLED: u32 = 1;
pub const CLOCK_DISABLED: u32 = 0;
pub const CLOCK_ALLOWED: u32 = 1;
pub const CLOCK_DISALLOWED: u32 = 0;
pub const TIMER_ABSTIME: u32 = 4;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 128;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_cuserid: u32 = 9;
pub const ESP_OK: u32 = 0;
pub const ESP_FAIL: i32 = -1;
pub const ESP_ERR_NO_MEM: u32 = 257;
pub const ESP_ERR_INVALID_ARG: u32 = 258;
pub const ESP_ERR_INVALID_STATE: u32 = 259;
pub const ESP_ERR_INVALID_SIZE: u32 = 260;
pub const ESP_ERR_NOT_FOUND: u32 = 261;
pub const ESP_ERR_NOT_SUPPORTED: u32 = 262;
pub const ESP_ERR_TIMEOUT: u32 = 263;
pub const ESP_ERR_INVALID_RESPONSE: u32 = 264;
pub const ESP_ERR_INVALID_CRC: u32 = 265;
pub const ESP_ERR_INVALID_VERSION: u32 = 266;
pub const ESP_ERR_INVALID_MAC: u32 = 267;
pub const ESP_ERR_WIFI_BASE: u32 = 12288;
pub const ESP_ERR_MESH_BASE: u32 = 16384;
pub const ESP_ERR_FLASH_BASE: u32 = 24576;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const XTHAL_RELEASE_MAJOR: u32 = 11000;
pub const XTHAL_RELEASE_MINOR: u32 = 3;
pub const XTHAL_RELEASE_NAME: &'static [u8; 7usize] = b"11.0.3\0";
pub const XTHAL_REL_11: u32 = 1;
pub const XTHAL_REL_11_0: u32 = 1;
pub const XTHAL_REL_11_0_3: u32 = 1;
pub const XTHAL_MAJOR_REV: u32 = 11000;
pub const XTHAL_MINOR_REV: u32 = 3;
pub const XTHAL_MAYBE: i32 = -1;
pub const XTHAL_MAX_CPS: u32 = 8;
pub const XTHAL_LITTLEENDIAN: u32 = 0;
pub const XTHAL_BIGENDIAN: u32 = 1;
pub const XTHAL_PREFETCH_ENABLE: i32 = -1;
pub const XTHAL_PREFETCH_DISABLE: u32 = 4294901760;
pub const XTHAL_DCACHE_PREFETCH_L1_OFF: u32 = 2415919104;
pub const XTHAL_DCACHE_PREFETCH_L1: u32 = 2415923200;
pub const XTHAL_ICACHE_PREFETCH_L1_OFF: u32 = 2684354560;
pub const XTHAL_ICACHE_PREFETCH_L1: u32 = 2684362752;
pub const XTHAL_DISASM_BUFSIZE: u32 = 80;
pub const XTHAL_DISASM_OPT_ADDR: u32 = 1;
pub const XTHAL_DISASM_OPT_OPHEX: u32 = 2;
pub const XTHAL_DISASM_OPT_OPCODE: u32 = 4;
pub const XTHAL_DISASM_OPT_PARMS: u32 = 8;
pub const XTHAL_DISASM_OPT_ALL: u32 = 4095;
pub const XTHAL_MAX_INTERRUPTS: u32 = 32;
pub const XTHAL_MAX_INTLEVELS: u32 = 16;
pub const XTHAL_MAX_TIMERS: u32 = 4;
pub const XTHAL_INTTYPE_UNCONFIGURED: u32 = 0;
pub const XTHAL_INTTYPE_SOFTWARE: u32 = 1;
pub const XTHAL_INTTYPE_EXTERN_EDGE: u32 = 2;
pub const XTHAL_INTTYPE_EXTERN_LEVEL: u32 = 3;
pub const XTHAL_INTTYPE_TIMER: u32 = 4;
pub const XTHAL_INTTYPE_NMI: u32 = 5;
pub const XTHAL_INTTYPE_WRITE_ERROR: u32 = 6;
pub const XTHAL_INTTYPE_PROFILING: u32 = 7;
pub const XTHAL_MAX_INTTYPES: u32 = 8;
pub const XTHAL_TIMER_UNCONFIGURED: i32 = -1;
pub const XTHAL_TIMER_UNASSIGNED: i32 = -1;
pub const XTHAL_MEMEP_PARITY: u32 = 1;
pub const XTHAL_MEMEP_ECC: u32 = 2;
pub const XTHAL_MEMEP_F_LOCAL: u32 = 0;
pub const XTHAL_MEMEP_F_DCACHE_DATA: u32 = 4;
pub const XTHAL_MEMEP_F_DCACHE_TAG: u32 = 5;
pub const XTHAL_MEMEP_F_ICACHE_DATA: u32 = 6;
pub const XTHAL_MEMEP_F_ICACHE_TAG: u32 = 7;
pub const XTHAL_MEMEP_F_CORRECTABLE: u32 = 16;
pub const XTHAL_AMB_EXCEPTION: u32 = 0;
pub const XTHAL_AMB_HITCACHE: u32 = 1;
pub const XTHAL_AMB_ALLOCATE: u32 = 2;
pub const XTHAL_AMB_WRITETHRU: u32 = 3;
pub const XTHAL_AMB_ISOLATE: u32 = 4;
pub const XTHAL_AMB_GUARD: u32 = 5;
pub const XTHAL_AMB_COHERENT: u32 = 6;
pub const XTHAL_AM_EXCEPTION: u32 = 1;
pub const XTHAL_AM_HITCACHE: u32 = 2;
pub const XTHAL_AM_ALLOCATE: u32 = 4;
pub const XTHAL_AM_WRITETHRU: u32 = 8;
pub const XTHAL_AM_ISOLATE: u32 = 16;
pub const XTHAL_AM_GUARD: u32 = 32;
pub const XTHAL_AM_COHERENT: u32 = 64;
pub const XTHAL_FAM_EXCEPTION: u32 = 1;
pub const XTHAL_FAM_BYPASS: u32 = 0;
pub const XTHAL_FAM_CACHED: u32 = 6;
pub const XTHAL_LAM_EXCEPTION: u32 = 1;
pub const XTHAL_LAM_ISOLATE: u32 = 18;
pub const XTHAL_LAM_BYPASS: u32 = 0;
pub const XTHAL_LAM_BYPASSG: u32 = 32;
pub const XTHAL_LAM_CACHED_NOALLOC: u32 = 2;
pub const XTHAL_LAM_NACACHED: u32 = 2;
pub const XTHAL_LAM_NACACHEDG: u32 = 34;
pub const XTHAL_LAM_CACHED: u32 = 6;
pub const XTHAL_LAM_COHCACHED: u32 = 70;
pub const XTHAL_SAM_EXCEPTION: u32 = 1;
pub const XTHAL_SAM_ISOLATE: u32 = 50;
pub const XTHAL_SAM_BYPASS: u32 = 40;
pub const XTHAL_SAM_WRITETHRU: u32 = 42;
pub const XTHAL_SAM_WRITEBACK: u32 = 38;
pub const XTHAL_SAM_WRITEBACK_NOALLOC: u32 = 34;
pub const XTHAL_SAM_COHWRITEBACK: u32 = 102;
pub const XTHAL_PAM_BYPASS: u32 = 0;
pub const XTHAL_PAM_BYPASS_BUF: u32 = 16;
pub const XTHAL_PAM_CACHED_NOALLOC: u32 = 48;
pub const XTHAL_PAM_WRITETHRU: u32 = 176;
pub const XTHAL_PAM_WRITEBACK_NOALLOC: u32 = 240;
pub const XTHAL_PAM_WRITEBACK: u32 = 496;
pub const XTHAL_CAFLAG_EXPAND: u32 = 256;
pub const XTHAL_CAFLAG_EXACT: u32 = 512;
pub const XTHAL_CAFLAG_NO_PARTIAL: u32 = 1024;
pub const XTHAL_CAFLAG_NO_AUTO_WB: u32 = 2048;
pub const XTHAL_CAFLAG_NO_AUTO_INV: u32 = 4096;
pub const XCHAL_SUCCESS: u32 = 0;
pub const XCHAL_ADDRESS_MISALIGNED: i32 = -1;
pub const XCHAL_INEXACT: i32 = -2;
pub const XCHAL_INVALID_ADDRESS: i32 = -3;
pub const XCHAL_UNSUPPORTED_ON_THIS_ARCH: i32 = -4;
pub const XCHAL_NO_PAGES_MAPPED: i32 = -5;
pub const XTHAL_NO_MAPPING: i32 = -6;
pub const XCHAL_CA_R: u32 = 1073742016;
pub const XCHAL_CA_RX: u32 = 1073742032;
pub const XCHAL_CA_RW: u32 = 1073742048;
pub const XCHAL_CA_RWX: u32 = 1073742064;
pub const XCHAL_CP_NUM: u32 = 1;
pub const XCHAL_CP_MAX: u32 = 1;
pub const XCHAL_CP_MASK: u32 = 1;
pub const XCHAL_CP_PORT_MASK: u32 = 0;
pub const XCHAL_CP0_NAME: &'static [u8; 4usize] = b"FPU\0";
pub const XCHAL_CP0_SA_SIZE: u32 = 72;
pub const XCHAL_CP0_SA_ALIGN: u32 = 4;
pub const XCHAL_CP_ID_FPU: u32 = 0;
pub const XCHAL_CP1_SA_SIZE: u32 = 0;
pub const XCHAL_CP1_SA_ALIGN: u32 = 1;
pub const XCHAL_CP2_SA_SIZE: u32 = 0;
pub const XCHAL_CP2_SA_ALIGN: u32 = 1;
pub const XCHAL_CP3_SA_SIZE: u32 = 0;
pub const XCHAL_CP3_SA_ALIGN: u32 = 1;
pub const XCHAL_CP4_SA_SIZE: u32 = 0;
pub const XCHAL_CP4_SA_ALIGN: u32 = 1;
pub const XCHAL_CP5_SA_SIZE: u32 = 0;
pub const XCHAL_CP5_SA_ALIGN: u32 = 1;
pub const XCHAL_CP6_SA_SIZE: u32 = 0;
pub const XCHAL_CP6_SA_ALIGN: u32 = 1;
pub const XCHAL_CP7_SA_SIZE: u32 = 0;
pub const XCHAL_CP7_SA_ALIGN: u32 = 1;
pub const XCHAL_NCP_SA_SIZE: u32 = 48;
pub const XCHAL_NCP_SA_ALIGN: u32 = 4;
pub const XCHAL_TOTAL_SA_SIZE: u32 = 128;
pub const XCHAL_TOTAL_SA_ALIGN: u32 = 4;
pub const XCHAL_NCP_SA_NUM: u32 = 12;
pub const XCHAL_CP0_SA_NUM: u32 = 18;
pub const XCHAL_CP1_SA_NUM: u32 = 0;
pub const XCHAL_CP2_SA_NUM: u32 = 0;
pub const XCHAL_CP3_SA_NUM: u32 = 0;
pub const XCHAL_CP4_SA_NUM: u32 = 0;
pub const XCHAL_CP5_SA_NUM: u32 = 0;
pub const XCHAL_CP6_SA_NUM: u32 = 0;
pub const XCHAL_CP7_SA_NUM: u32 = 0;
pub const EXCCAUSE_EXCCAUSE_SHIFT: u32 = 0;
pub const EXCCAUSE_EXCCAUSE_MASK: u32 = 63;
pub const EXCCAUSE_ILLEGAL: u32 = 0;
pub const EXCCAUSE_SYSCALL: u32 = 1;
pub const EXCCAUSE_INSTR_ERROR: u32 = 2;
pub const EXCCAUSE_IFETCHERROR: u32 = 2;
pub const EXCCAUSE_LOAD_STORE_ERROR: u32 = 3;
pub const EXCCAUSE_LOADSTOREERROR: u32 = 3;
pub const EXCCAUSE_LEVEL1_INTERRUPT: u32 = 4;
pub const EXCCAUSE_LEVEL1INTERRUPT: u32 = 4;
pub const EXCCAUSE_ALLOCA: u32 = 5;
pub const EXCCAUSE_DIVIDE_BY_ZERO: u32 = 6;
pub const EXCCAUSE_SPECULATION: u32 = 7;
pub const EXCCAUSE_PRIVILEGED: u32 = 8;
pub const EXCCAUSE_UNALIGNED: u32 = 9;
pub const EXCCAUSE_INSTR_DATA_ERROR: u32 = 12;
pub const EXCCAUSE_LOAD_STORE_DATA_ERROR: u32 = 13;
pub const EXCCAUSE_INSTR_ADDR_ERROR: u32 = 14;
pub const EXCCAUSE_LOAD_STORE_ADDR_ERROR: u32 = 15;
pub const EXCCAUSE_ITLB_MISS: u32 = 16;
pub const EXCCAUSE_ITLB_MULTIHIT: u32 = 17;
pub const EXCCAUSE_INSTR_RING: u32 = 18;
pub const EXCCAUSE_INSTR_PROHIBITED: u32 = 20;
pub const EXCCAUSE_DTLB_MISS: u32 = 24;
pub const EXCCAUSE_DTLB_MULTIHIT: u32 = 25;
pub const EXCCAUSE_LOAD_STORE_RING: u32 = 26;
pub const EXCCAUSE_LOAD_PROHIBITED: u32 = 28;
pub const EXCCAUSE_STORE_PROHIBITED: u32 = 29;
pub const EXCCAUSE_CP0_DISABLED: u32 = 32;
pub const EXCCAUSE_CP1_DISABLED: u32 = 33;
pub const EXCCAUSE_CP2_DISABLED: u32 = 34;
pub const EXCCAUSE_CP3_DISABLED: u32 = 35;
pub const EXCCAUSE_CP4_DISABLED: u32 = 36;
pub const EXCCAUSE_CP5_DISABLED: u32 = 37;
pub const EXCCAUSE_CP6_DISABLED: u32 = 38;
pub const EXCCAUSE_CP7_DISABLED: u32 = 39;
pub const PS_WOE_SHIFT: u32 = 18;
pub const PS_WOE_MASK: u32 = 262144;
pub const PS_WOE: u32 = 262144;
pub const PS_CALLINC_SHIFT: u32 = 16;
pub const PS_CALLINC_MASK: u32 = 196608;
pub const PS_OWB_SHIFT: u32 = 8;
pub const PS_OWB_MASK: u32 = 3840;
pub const PS_RING_SHIFT: u32 = 6;
pub const PS_RING_MASK: u32 = 192;
pub const PS_UM_SHIFT: u32 = 5;
pub const PS_UM_MASK: u32 = 32;
pub const PS_UM: u32 = 32;
pub const PS_EXCM_SHIFT: u32 = 4;
pub const PS_EXCM_MASK: u32 = 16;
pub const PS_EXCM: u32 = 16;
pub const PS_INTLEVEL_SHIFT: u32 = 0;
pub const PS_INTLEVEL_MASK: u32 = 15;
pub const PS_PROGSTACK_SHIFT: u32 = 5;
pub const PS_PROGSTACK_MASK: u32 = 32;
pub const PS_PROG_SHIFT: u32 = 5;
pub const PS_PROG_MASK: u32 = 32;
pub const PS_PROG: u32 = 32;
pub const DBREAKC_MASK_SHIFT: u32 = 0;
pub const DBREAKC_MASK_MASK: u32 = 63;
pub const DBREAKC_LOADBREAK_SHIFT: u32 = 30;
pub const DBREAKC_LOADBREAK_MASK: u32 = 1073741824;
pub const DBREAKC_STOREBREAK_SHIFT: u32 = 31;
pub const DBREAKC_STOREBREAK_MASK: u32 = 2147483648;
pub const DEBUGCAUSE_DEBUGINT_SHIFT: u32 = 5;
pub const DEBUGCAUSE_DEBUGINT_MASK: u32 = 32;
pub const DEBUGCAUSE_BREAKN_SHIFT: u32 = 4;
pub const DEBUGCAUSE_BREAKN_MASK: u32 = 16;
pub const DEBUGCAUSE_BREAK_SHIFT: u32 = 3;
pub const DEBUGCAUSE_BREAK_MASK: u32 = 8;
pub const DEBUGCAUSE_DBREAK_SHIFT: u32 = 2;
pub const DEBUGCAUSE_DBREAK_MASK: u32 = 4;
pub const DEBUGCAUSE_IBREAK_SHIFT: u32 = 1;
pub const DEBUGCAUSE_IBREAK_MASK: u32 = 2;
pub const DEBUGCAUSE_ICOUNT_SHIFT: u32 = 0;
pub const DEBUGCAUSE_ICOUNT_MASK: u32 = 1;
pub const MESR_MEME: u32 = 1;
pub const MESR_MEME_SHIFT: u32 = 0;
pub const MESR_DME: u32 = 2;
pub const MESR_DME_SHIFT: u32 = 1;
pub const MESR_RCE: u32 = 16;
pub const MESR_RCE_SHIFT: u32 = 4;
pub const MESR_ERRENAB: u32 = 256;
pub const MESR_ERRENAB_SHIFT: u32 = 8;
pub const MESR_ERRTEST: u32 = 512;
pub const MESR_ERRTEST_SHIFT: u32 = 9;
pub const MESR_DATEXC: u32 = 1024;
pub const MESR_DATEXC_SHIFT: u32 = 10;
pub const MESR_INSEXC: u32 = 2048;
pub const MESR_INSEXC_SHIFT: u32 = 11;
pub const MESR_WAYNUM_SHIFT: u32 = 16;
pub const MESR_ACCTYPE_SHIFT: u32 = 20;
pub const MESR_MEMTYPE_SHIFT: u32 = 24;
pub const MESR_ERRTYPE_SHIFT: u32 = 30;
pub const MEMCTL_SNOOP_EN_SHIFT: u32 = 1;
pub const MEMCTL_SNOOP_EN: u32 = 2;
pub const MEMCTL_L0IBUF_EN_SHIFT: u32 = 0;
pub const MEMCTL_L0IBUF_EN: u32 = 1;
pub const MEMCTL_INV_EN_SHIFT: u32 = 23;
pub const MEMCTL_INV_EN: u32 = 8388608;
pub const MEMCTL_DCWU_SHIFT: u32 = 8;
pub const MEMCTL_DCWU_BITS: u32 = 5;
pub const MEMCTL_DCWA_SHIFT: u32 = 13;
pub const MEMCTL_DCWA_BITS: u32 = 5;
pub const MEMCTL_ICWU_SHIFT: u32 = 18;
pub const MEMCTL_ICWU_BITS: u32 = 5;
pub const MEMCTL_DCWU_MASK: u32 = 7936;
pub const MEMCTL_DCWA_MASK: u32 = 253952;
pub const MEMCTL_ICWU_MASK: u32 = 8126464;
pub const MEMCTL_DCWU_CLR_MASK: i32 = -7937;
pub const MEMCTL_DCWA_CLR_MASK: i32 = -253953;
pub const MEMCTL_ICWU_CLR_MASK: i32 = -8126465;
pub const MEMCTL_DCW_CLR_MASK: i32 = -1;
pub const MEMCTL_IDCW_CLR_MASK: i32 = -1;
pub const XSHAL_USE_ABSOLUTE_LITERALS: u32 = 0;
pub const XSHAL_HAVE_TEXT_SECTION_LITERALS: u32 = 1;
pub const XTHAL_ABI_WINDOWED: u32 = 0;
pub const XTHAL_ABI_CALL0: u32 = 1;
pub const XTHAL_CLIB_NEWLIB: u32 = 0;
pub const XTHAL_CLIB_UCLIBC: u32 = 1;
pub const XTHAL_CLIB_XCLIB: u32 = 2;
pub const XSHAL_USE_FLOATING_POINT: u32 = 1;
pub const XSHAL_FLOATING_POINT_ABI: u32 = 0;
pub const XSHAL_IOBLOCK_CACHED_VADDR: u32 = 1879048192;
pub const XSHAL_IOBLOCK_CACHED_PADDR: u32 = 1879048192;
pub const XSHAL_IOBLOCK_CACHED_SIZE: u32 = 234881024;
pub const XSHAL_IOBLOCK_BYPASS_VADDR: u32 = 2415919104;
pub const XSHAL_IOBLOCK_BYPASS_PADDR: u32 = 2415919104;
pub const XSHAL_IOBLOCK_BYPASS_SIZE: u32 = 234881024;
pub const XSHAL_ROM_VADDR: u32 = 1342177280;
pub const XSHAL_ROM_PADDR: u32 = 1342177280;
pub const XSHAL_ROM_SIZE: u32 = 16777216;
pub const XSHAL_ROM_AVAIL_VADDR: u32 = 1342177280;
pub const XSHAL_ROM_AVAIL_VSIZE: u32 = 16777216;
pub const XSHAL_RAM_VADDR: u32 = 1610612736;
pub const XSHAL_RAM_PADDR: u32 = 1610612736;
pub const XSHAL_RAM_VSIZE: u32 = 536870912;
pub const XSHAL_RAM_PSIZE: u32 = 536870912;
pub const XSHAL_RAM_SIZE: u32 = 536870912;
pub const XSHAL_RAM_AVAIL_VADDR: u32 = 1610612736;
pub const XSHAL_RAM_AVAIL_VSIZE: u32 = 536870912;
pub const XSHAL_RAM_BYPASS_VADDR: u32 = 2684354560;
pub const XSHAL_RAM_BYPASS_PADDR: u32 = 2684354560;
pub const XSHAL_RAM_BYPASS_PSIZE: u32 = 536870912;
pub const XSHAL_SIMIO_CACHED_VADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_BYPASS_VADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_PADDR: u32 = 3221225472;
pub const XSHAL_SIMIO_SIZE: u32 = 536870912;
pub const XSHAL_MAGIC_EXIT: u32 = 0;
pub const XSHAL_ALLVALID_CACHEATTR_WRITEBACK: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_WRITEALLOC: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_WRITETHRU: u32 = 572657938;
pub const XSHAL_ALLVALID_CACHEATTR_BYPASS: u32 = 572662306;
pub const XSHAL_ALLVALID_CACHEATTR_DEFAULT: u32 = 572657938;
pub const XSHAL_STRICT_CACHEATTR_WRITEBACK: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_WRITEALLOC: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_WRITETHRU: u32 = 4294906143;
pub const XSHAL_STRICT_CACHEATTR_BYPASS: u32 = 4294910511;
pub const XSHAL_STRICT_CACHEATTR_DEFAULT: u32 = 4294906143;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITEBACK: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITEALLOC: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_WRITETHRU: u32 = 572657951;
pub const XSHAL_TRAPNULL_CACHEATTR_BYPASS: u32 = 572662319;
pub const XSHAL_TRAPNULL_CACHEATTR_DEFAULT: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITEBACK: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITEALLOC: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_WRITETHRU: u32 = 572657951;
pub const XSHAL_ISS_CACHEATTR_BYPASS: u32 = 572662319;
pub const XSHAL_ISS_CACHEATTR_DEFAULT: u32 = 572657951;
pub const XSHAL_ISS_PIPE_REGIONS: u32 = 0;
pub const XSHAL_ISS_SDRAM_REGIONS: u32 = 0;
pub const XSHAL_XT2000_CACHEATTR_WRITEBACK: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_WRITEALLOC: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_WRITETHRU: u32 = 4280422687;
pub const XSHAL_XT2000_CACHEATTR_BYPASS: u32 = 4280427055;
pub const XSHAL_XT2000_CACHEATTR_DEFAULT: u32 = 4280422687;
pub const XSHAL_XT2000_PIPE_REGIONS: u32 = 0;
pub const XSHAL_XT2000_SDRAM_REGIONS: u32 = 1088;
pub const XSHAL_VECTORS_PACKED: u32 = 0;
pub const XSHAL_STATIC_VECTOR_SELECT: u32 = 1;
pub const XSHAL_RESET_VECTOR_VADDR: u32 = 1073742848;
pub const XSHAL_RESET_VECTOR_PADDR: u32 = 1073742848;
pub const XSHAL_RESET_VECTOR_SIZE: u32 = 768;
pub const XSHAL_RESET_VECTOR_ISROM: u32 = 0;
pub const XSHAL_USER_VECTOR_SIZE: u32 = 56;
pub const XSHAL_USER_VECTOR_ISROM: u32 = 0;
pub const XSHAL_PROGRAMEXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_USEREXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_KERNEL_VECTOR_SIZE: u32 = 56;
pub const XSHAL_KERNEL_VECTOR_ISROM: u32 = 0;
pub const XSHAL_STACKEDEXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_KERNELEXC_VECTOR_SIZE: u32 = 56;
pub const XSHAL_DOUBLEEXC_VECTOR_SIZE: u32 = 64;
pub const XSHAL_DOUBLEEXC_VECTOR_ISROM: u32 = 0;
pub const XSHAL_WINDOW_VECTORS_SIZE: u32 = 376;
pub const XSHAL_WINDOW_VECTORS_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL2_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL2_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL3_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL3_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL4_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL4_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL5_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL5_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL6_VECTOR_SIZE: u32 = 56;
pub const XSHAL_INTLEVEL6_VECTOR_ISROM: u32 = 0;
pub const XSHAL_DEBUG_VECTOR_SIZE: u32 = 56;
pub const XSHAL_DEBUG_VECTOR_ISROM: u32 = 0;
pub const XSHAL_NMI_VECTOR_SIZE: u32 = 56;
pub const XSHAL_NMI_VECTOR_ISROM: u32 = 0;
pub const XSHAL_INTLEVEL7_VECTOR_SIZE: u32 = 56;
pub const XTENSA_HWVERSION_T1020_0: u32 = 102000;
pub const XTENSA_HWCIDSCHEME_T1020_0: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_0: u32 = 2;
pub const XTENSA_HWVERSION_T1020_1: u32 = 102001;
pub const XTENSA_HWCIDSCHEME_T1020_1: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_1: u32 = 3;
pub const XTENSA_HWVERSION_T1020_2B: u32 = 102002;
pub const XTENSA_HWCIDSCHEME_T1020_2B: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_2B: u32 = 5;
pub const XTENSA_HWVERSION_T1020_2: u32 = 102002;
pub const XTENSA_HWCIDSCHEME_T1020_2: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_2: u32 = 4;
pub const XTENSA_HWVERSION_T1020_3: u32 = 102003;
pub const XTENSA_HWCIDSCHEME_T1020_3: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_3: u32 = 6;
pub const XTENSA_HWVERSION_T1020_4: u32 = 102004;
pub const XTENSA_HWCIDSCHEME_T1020_4: u32 = 10;
pub const XTENSA_HWCIDVERS_T1020_4: u32 = 7;
pub const XTENSA_HWVERSION_T1030_0: u32 = 103000;
pub const XTENSA_HWCIDSCHEME_T1030_0: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_0: u32 = 9;
pub const XTENSA_HWVERSION_T1030_1: u32 = 103001;
pub const XTENSA_HWCIDSCHEME_T1030_1: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_1: u32 = 10;
pub const XTENSA_HWVERSION_T1030_2: u32 = 103002;
pub const XTENSA_HWCIDSCHEME_T1030_2: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_2: u32 = 11;
pub const XTENSA_HWVERSION_T1030_3: u32 = 103003;
pub const XTENSA_HWCIDSCHEME_T1030_3: u32 = 10;
pub const XTENSA_HWCIDVERS_T1030_3: u32 = 12;
pub const XTENSA_HWVERSION_T1040_0: u32 = 104000;
pub const XTENSA_HWCIDSCHEME_T1040_0: u32 = 10;
pub const XTENSA_HWCIDVERS_T1040_0: u32 = 15;
pub const XTENSA_HWVERSION_T1040_1: u32 = 104001;
pub const XTENSA_HWCIDSCHEME_T1040_1: u32 = 1;
pub const XTENSA_HWCIDVERS_T1040_1: u32 = 32;
pub const XTENSA_HWVERSION_T1040_1P: u32 = 104001;
pub const XTENSA_HWCIDSCHEME_T1040_1P: u32 = 10;
pub const XTENSA_HWCIDVERS_T1040_1P: u32 = 16;
pub const XTENSA_HWVERSION_T1040_2: u32 = 104002;
pub const XTENSA_HWCIDSCHEME_T1040_2: u32 = 1;
pub const XTENSA_HWCIDVERS_T1040_2: u32 = 33;
pub const XTENSA_HWVERSION_T1040_3: u32 = 104003;
pub const XTENSA_HWCIDSCHEME_T1040_3: u32 = 1;
pub const XTENSA_HWCIDVERS_T1040_3: u32 = 34;
pub const XTENSA_HWVERSION_T1050_0: u32 = 105000;
pub const XTENSA_HWCIDSCHEME_T1050_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_0: u32 = 1;
pub const XTENSA_HWVERSION_T1050_1: u32 = 105001;
pub const XTENSA_HWCIDSCHEME_T1050_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_1: u32 = 2;
pub const XTENSA_HWVERSION_T1050_2: u32 = 105002;
pub const XTENSA_HWCIDSCHEME_T1050_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_2: u32 = 4;
pub const XTENSA_HWVERSION_T1050_3: u32 = 105003;
pub const XTENSA_HWCIDSCHEME_T1050_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_3: u32 = 6;
pub const XTENSA_HWVERSION_T1050_4: u32 = 105004;
pub const XTENSA_HWCIDSCHEME_T1050_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_4: u32 = 7;
pub const XTENSA_HWVERSION_T1050_5: u32 = 105005;
pub const XTENSA_HWCIDSCHEME_T1050_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_T1050_5: u32 = 8;
pub const XTENSA_HWVERSION_RA_2004_1: u32 = 210000;
pub const XTENSA_HWCIDSCHEME_RA_2004_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2004_1: u32 = 3;
pub const XTENSA_HWVERSION_RA_2005_1: u32 = 210001;
pub const XTENSA_HWCIDSCHEME_RA_2005_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2005_1: u32 = 20;
pub const XTENSA_HWVERSION_RA_2005_2: u32 = 210002;
pub const XTENSA_HWCIDSCHEME_RA_2005_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2005_2: u32 = 21;
pub const XTENSA_HWVERSION_RA_2005_3: u32 = 210003;
pub const XTENSA_HWCIDSCHEME_RA_2005_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2005_3: u32 = 22;
pub const XTENSA_HWVERSION_RA_2006_4: u32 = 210004;
pub const XTENSA_HWCIDSCHEME_RA_2006_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2006_4: u32 = 23;
pub const XTENSA_HWVERSION_RA_2006_5: u32 = 210005;
pub const XTENSA_HWCIDSCHEME_RA_2006_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2006_5: u32 = 24;
pub const XTENSA_HWVERSION_RA_2006_6: u32 = 210006;
pub const XTENSA_HWCIDSCHEME_RA_2006_6: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2006_6: u32 = 25;
pub const XTENSA_HWVERSION_RA_2007_7: u32 = 210007;
pub const XTENSA_HWCIDSCHEME_RA_2007_7: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2007_7: u32 = 26;
pub const XTENSA_HWVERSION_RA_2008_8: u32 = 210008;
pub const XTENSA_HWCIDSCHEME_RA_2008_8: u32 = 1100;
pub const XTENSA_HWCIDVERS_RA_2008_8: u32 = 27;
pub const XTENSA_HWVERSION_RB_2006_0: u32 = 220000;
pub const XTENSA_HWCIDSCHEME_RB_2006_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2006_0: u32 = 48;
pub const XTENSA_HWVERSION_RB_2007_1: u32 = 220001;
pub const XTENSA_HWCIDSCHEME_RB_2007_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2007_1: u32 = 49;
pub const XTENSA_HWVERSION_RB_2007_2: u32 = 221000;
pub const XTENSA_HWCIDSCHEME_RB_2007_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2007_2: u32 = 52;
pub const XTENSA_HWVERSION_RB_2008_3: u32 = 221001;
pub const XTENSA_HWCIDSCHEME_RB_2008_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2008_3: u32 = 53;
pub const XTENSA_HWVERSION_RB_2008_4: u32 = 221002;
pub const XTENSA_HWCIDSCHEME_RB_2008_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2008_4: u32 = 54;
pub const XTENSA_HWVERSION_RB_2009_5: u32 = 221003;
pub const XTENSA_HWCIDSCHEME_RB_2009_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2009_5: u32 = 55;
pub const XTENSA_HWVERSION_RB_2007_2_MP: u32 = 221100;
pub const XTENSA_HWCIDSCHEME_RB_2007_2_MP: u32 = 1100;
pub const XTENSA_HWCIDVERS_RB_2007_2_MP: u32 = 64;
pub const XTENSA_HWVERSION_RC_2009_0: u32 = 230000;
pub const XTENSA_HWCIDSCHEME_RC_2009_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2009_0: u32 = 65;
pub const XTENSA_HWVERSION_RC_2010_1: u32 = 230001;
pub const XTENSA_HWCIDSCHEME_RC_2010_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2010_1: u32 = 66;
pub const XTENSA_HWVERSION_RC_2010_2: u32 = 230002;
pub const XTENSA_HWCIDSCHEME_RC_2010_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2010_2: u32 = 67;
pub const XTENSA_HWVERSION_RC_2011_3: u32 = 230003;
pub const XTENSA_HWCIDSCHEME_RC_2011_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RC_2011_3: u32 = 68;
pub const XTENSA_HWVERSION_RD_2010_0: u32 = 240000;
pub const XTENSA_HWCIDSCHEME_RD_2010_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2010_0: u32 = 80;
pub const XTENSA_HWVERSION_RD_2011_1: u32 = 240001;
pub const XTENSA_HWCIDSCHEME_RD_2011_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2011_1: u32 = 81;
pub const XTENSA_HWVERSION_RD_2011_2: u32 = 240002;
pub const XTENSA_HWCIDSCHEME_RD_2011_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2011_2: u32 = 82;
pub const XTENSA_HWVERSION_RD_2011_3: u32 = 240003;
pub const XTENSA_HWCIDSCHEME_RD_2011_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2011_3: u32 = 83;
pub const XTENSA_HWVERSION_RD_2012_4: u32 = 240004;
pub const XTENSA_HWCIDSCHEME_RD_2012_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2012_4: u32 = 84;
pub const XTENSA_HWVERSION_RD_2012_5: u32 = 240005;
pub const XTENSA_HWCIDSCHEME_RD_2012_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RD_2012_5: u32 = 85;
pub const XTENSA_HWVERSION_RE_2012_0: u32 = 250000;
pub const XTENSA_HWCIDSCHEME_RE_2012_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2012_0: u32 = 96;
pub const XTENSA_HWVERSION_RE_2012_1: u32 = 250001;
pub const XTENSA_HWCIDSCHEME_RE_2012_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2012_1: u32 = 97;
pub const XTENSA_HWVERSION_RE_2013_2: u32 = 250002;
pub const XTENSA_HWCIDSCHEME_RE_2013_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2013_2: u32 = 98;
pub const XTENSA_HWVERSION_RE_2013_3: u32 = 250003;
pub const XTENSA_HWCIDSCHEME_RE_2013_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2013_3: u32 = 99;
pub const XTENSA_HWVERSION_RE_2013_4: u32 = 250004;
pub const XTENSA_HWCIDSCHEME_RE_2013_4: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2013_4: u32 = 100;
pub const XTENSA_HWVERSION_RE_2014_5: u32 = 250005;
pub const XTENSA_HWCIDSCHEME_RE_2014_5: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2014_5: u32 = 101;
pub const XTENSA_HWVERSION_RE_2015_6: u32 = 250006;
pub const XTENSA_HWCIDSCHEME_RE_2015_6: u32 = 1100;
pub const XTENSA_HWCIDVERS_RE_2015_6: u32 = 102;
pub const XTENSA_HWVERSION_RF_2014_0: u32 = 260000;
pub const XTENSA_HWCIDSCHEME_RF_2014_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2014_0: u32 = 112;
pub const XTENSA_HWVERSION_RF_2014_1: u32 = 260001;
pub const XTENSA_HWCIDSCHEME_RF_2014_1: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2014_1: u32 = 113;
pub const XTENSA_HWVERSION_RF_2015_2: u32 = 260002;
pub const XTENSA_HWCIDSCHEME_RF_2015_2: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2015_2: u32 = 114;
pub const XTENSA_HWVERSION_RF_2015_3: u32 = 260003;
pub const XTENSA_HWCIDSCHEME_RF_2015_3: u32 = 1100;
pub const XTENSA_HWCIDVERS_RF_2015_3: u32 = 115;
pub const XTENSA_HWVERSION_RG_2015_0: u32 = 270000;
pub const XTENSA_HWCIDSCHEME_RG_2015_0: u32 = 1100;
pub const XTENSA_HWCIDVERS_RG_2015_0: u32 = 128;
pub const XTENSA_SWVERSION_T1020_0: u32 = 102000;
pub const XTENSA_SWVERSION_T1020_1: u32 = 102001;
pub const XTENSA_SWVERSION_T1020_2B: u32 = 102002;
pub const XTENSA_SWVERSION_T1020_2: u32 = 102002;
pub const XTENSA_SWVERSION_T1020_3: u32 = 102003;
pub const XTENSA_SWVERSION_T1020_4: u32 = 102004;
pub const XTENSA_SWVERSION_T1030_0: u32 = 103000;
pub const XTENSA_SWVERSION_T1030_1: u32 = 103001;
pub const XTENSA_SWVERSION_T1030_2: u32 = 103002;
pub const XTENSA_SWVERSION_T1030_3: u32 = 103003;
pub const XTENSA_SWVERSION_T1040_0: u32 = 104000;
pub const XTENSA_SWVERSION_T1040_1: u32 = 104001;
pub const XTENSA_SWVERSION_T1040_1P: u32 = 104001;
pub const XTENSA_SWVERSION_T1040_2: u32 = 104002;
pub const XTENSA_SWVERSION_T1040_3: u32 = 104003;
pub const XTENSA_SWVERSION_T1050_0: u32 = 105000;
pub const XTENSA_SWVERSION_T1050_1: u32 = 105001;
pub const XTENSA_SWVERSION_T1050_2: u32 = 105002;
pub const XTENSA_SWVERSION_T1050_3: u32 = 105003;
pub const XTENSA_SWVERSION_T1050_4: u32 = 105004;
pub const XTENSA_SWVERSION_T1050_5: u32 = 105005;
pub const XTENSA_SWVERSION_RA_2004_1: u32 = 600000;
pub const XTENSA_SWVERSION_RA_2005_1: u32 = 600001;
pub const XTENSA_SWVERSION_RA_2005_2: u32 = 600002;
pub const XTENSA_SWVERSION_RA_2005_3: u32 = 600003;
pub const XTENSA_SWVERSION_RA_2006_4: u32 = 600004;
pub const XTENSA_SWVERSION_RA_2006_5: u32 = 600005;
pub const XTENSA_SWVERSION_RA_2006_6: u32 = 600006;
pub const XTENSA_SWVERSION_RA_2007_7: u32 = 600007;
pub const XTENSA_SWVERSION_RA_2008_8: u32 = 600008;
pub const XTENSA_SWVERSION_RB_2006_0: u32 = 700000;
pub const XTENSA_SWVERSION_RB_2007_1: u32 = 700001;
pub const XTENSA_SWVERSION_RB_2007_2: u32 = 701000;
pub const XTENSA_SWVERSION_RB_2008_3: u32 = 701001;
pub const XTENSA_SWVERSION_RB_2008_4: u32 = 701002;
pub const XTENSA_SWVERSION_RB_2009_5: u32 = 701003;
pub const XTENSA_SWVERSION_RB_2007_2_MP: u32 = 701100;
pub const XTENSA_SWVERSION_RC_2009_0: u32 = 800000;
pub const XTENSA_SWVERSION_RC_2010_1: u32 = 800001;
pub const XTENSA_SWVERSION_RC_2010_2: u32 = 800002;
pub const XTENSA_SWVERSION_RC_2011_3: u32 = 800003;
pub const XTENSA_SWVERSION_RD_2010_0: u32 = 900000;
pub const XTENSA_SWVERSION_RD_2011_1: u32 = 900001;
pub const XTENSA_SWVERSION_RD_2011_2: u32 = 900002;
pub const XTENSA_SWVERSION_RD_2011_3: u32 = 900003;
pub const XTENSA_SWVERSION_RD_2012_4: u32 = 900004;
pub const XTENSA_SWVERSION_RD_2012_5: u32 = 900005;
pub const XTENSA_SWVERSION_RE_2012_0: u32 = 1000000;
pub const XTENSA_SWVERSION_RE_2012_1: u32 = 1000001;
pub const XTENSA_SWVERSION_RE_2013_2: u32 = 1000002;
pub const XTENSA_SWVERSION_RE_2013_3: u32 = 1000003;
pub const XTENSA_SWVERSION_RE_2013_4: u32 = 1000004;
pub const XTENSA_SWVERSION_RE_2014_5: u32 = 1000005;
pub const XTENSA_SWVERSION_RE_2015_6: u32 = 1000006;
pub const XTENSA_SWVERSION_RF_2014_0: u32 = 1100000;
pub const XTENSA_SWVERSION_RF_2014_1: u32 = 1100001;
pub const XTENSA_SWVERSION_RF_2015_2: u32 = 1100002;
pub const XTENSA_SWVERSION_RF_2015_3: u32 = 1100003;
pub const XTENSA_SWVERSION_RG_2015_0: u32 = 1200000;
pub const XTENSA_SWVERSION_T1040_1_PREHOTFIX: u32 = 104001;
pub const XTENSA_SWVERSION_6_0_0: u32 = 600000;
pub const XTENSA_SWVERSION_6_0_1: u32 = 600001;
pub const XTENSA_SWVERSION_6_0_2: u32 = 600002;
pub const XTENSA_SWVERSION_6_0_3: u32 = 600003;
pub const XTENSA_SWVERSION_6_0_4: u32 = 600004;
pub const XTENSA_SWVERSION_6_0_5: u32 = 600005;
pub const XTENSA_SWVERSION_6_0_6: u32 = 600006;
pub const XTENSA_SWVERSION_6_0_7: u32 = 600007;
pub const XTENSA_SWVERSION_6_0_8: u32 = 600008;
pub const XTENSA_SWVERSION_7_0_0: u32 = 700000;
pub const XTENSA_SWVERSION_7_0_1: u32 = 700001;
pub const XTENSA_SWVERSION_7_1_0: u32 = 701000;
pub const XTENSA_SWVERSION_7_1_1: u32 = 701001;
pub const XTENSA_SWVERSION_7_1_2: u32 = 701002;
pub const XTENSA_SWVERSION_7_1_3: u32 = 701003;
pub const XTENSA_SWVERSION_7_1_8_MP: u32 = 701100;
pub const XTENSA_SWVERSION_8_0_0: u32 = 800000;
pub const XTENSA_SWVERSION_8_0_1: u32 = 800001;
pub const XTENSA_SWVERSION_8_0_2: u32 = 800002;
pub const XTENSA_SWVERSION_8_0_3: u32 = 800003;
pub const XTENSA_SWVERSION_9_0_0: u32 = 900000;
pub const XTENSA_SWVERSION_9_0_1: u32 = 900001;
pub const XTENSA_SWVERSION_9_0_2: u32 = 900002;
pub const XTENSA_SWVERSION_9_0_3: u32 = 900003;
pub const XTENSA_SWVERSION_9_0_4: u32 = 900004;
pub const XTENSA_SWVERSION_9_0_5: u32 = 900005;
pub const XTENSA_SWVERSION_10_0_0: u32 = 1000000;
pub const XTENSA_SWVERSION_10_0_1: u32 = 1000001;
pub const XTENSA_SWVERSION_10_0_2: u32 = 1000002;
pub const XTENSA_SWVERSION_10_0_3: u32 = 1000003;
pub const XTENSA_SWVERSION_10_0_4: u32 = 1000004;
pub const XTENSA_SWVERSION_10_0_5: u32 = 1000005;
pub const XTENSA_SWVERSION_10_0_6: u32 = 1000006;
pub const XTENSA_SWVERSION_11_0_0: u32 = 1100000;
pub const XTENSA_SWVERSION_11_0_1: u32 = 1100001;
pub const XTENSA_SWVERSION_11_0_2: u32 = 1100002;
pub const XTENSA_SWVERSION_11_0_3: u32 = 1100003;
pub const XTENSA_SWVERSION_12_0_0: u32 = 1200000;
pub const XTENSA_RELEASE_NAME: &'static [u8; 10usize] = b"RF-2015.3\0";
pub const XTENSA_RELEASE_CANONICAL_NAME: &'static [u8; 10usize] = b"RF-2015.3\0";
pub const XTENSA_SWVERSION: u32 = 1100003;
pub const XTENSA_SWVERSION_NAME: &'static [u8; 7usize] = b"11.0.3\0";
pub const XTENSA_SWVERSION_CANONICAL_NAME: &'static [u8; 7usize] = b"11.0.3\0";
pub const XTENSA_SWVERSION_MAJORMID_NAME: &'static [u8; 5usize] = b"11.0\0";
pub const XTENSA_SWVERSION_MAJOR_NAME: &'static [u8; 3usize] = b"11\0";
pub const XTENSA_SWVERSION_LICENSE_NAME: &'static [u8; 5usize] = b"11.0\0";
pub const XCHAL_CA_BYPASS: u32 = 2;
pub const XCHAL_CA_BYPASSBUF: u32 = 6;
pub const XCHAL_CA_WRITETHRU: u32 = 2;
pub const XCHAL_CA_WRITEBACK: u32 = 2;
pub const XCHAL_HAVE_CA_WRITEBACK_NOALLOC: u32 = 0;
pub const XCHAL_CA_WRITEBACK_NOALLOC: u32 = 2;
pub const XCHAL_CA_BYPASS_RW: u32 = 0;
pub const XCHAL_CA_WRITETHRU_RW: u32 = 0;
pub const XCHAL_CA_WRITEBACK_RW: u32 = 0;
pub const XCHAL_CA_WRITEBACK_NOALLOC_RW: u32 = 0;
pub const XCHAL_CA_ILLEGAL: u32 = 15;
pub const XCHAL_CA_ISOLATE: u32 = 0;
pub const XCHAL_MMU_ASID_INVALID: u32 = 0;
pub const XCHAL_MMU_ASID_KERNEL: u32 = 0;
pub const XCHAL_MMU_SR_BITS: u32 = 0;
pub const XCHAL_MMU_CA_BITS: u32 = 4;
pub const XCHAL_MMU_MAX_PTE_PAGE_SIZE: u32 = 29;
pub const XCHAL_MMU_MIN_PTE_PAGE_SIZE: u32 = 29;
pub const XCHAL_ITLB_WAY_BITS: u32 = 0;
pub const XCHAL_ITLB_WAYS: u32 = 1;
pub const XCHAL_ITLB_ARF_WAYS: u32 = 0;
pub const XCHAL_ITLB_SETS: u32 = 1;
pub const XCHAL_ITLB_WAY0_SET: u32 = 0;
pub const XCHAL_ITLB_ARF_SETS: u32 = 0;
pub const XCHAL_ITLB_MINWIRED_SETS: u32 = 0;
pub const XCHAL_ITLB_SET0_WAY: u32 = 0;
pub const XCHAL_ITLB_SET0_WAYS: u32 = 1;
pub const XCHAL_ITLB_SET0_ENTRIES_LOG2: u32 = 3;
pub const XCHAL_ITLB_SET0_ENTRIES: u32 = 8;
pub const XCHAL_ITLB_SET0_ARF: u32 = 0;
pub const XCHAL_ITLB_SET0_PAGESIZES: u32 = 1;
pub const XCHAL_ITLB_SET0_PAGESZ_BITS: u32 = 0;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_MIN: u32 = 29;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_MAX: u32 = 29;
pub const XCHAL_ITLB_SET0_PAGESZ_LOG2_LIST: u32 = 29;
pub const XCHAL_ITLB_SET0_ASID_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_VPN_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_PPN_CONSTMASK: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_CA_CONSTMASK: u32 = 0;
pub const XCHAL_ITLB_SET0_ASID_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_VPN_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_PPN_RESET: u32 = 0;
pub const XCHAL_ITLB_SET0_CA_RESET: u32 = 1;
pub const XCHAL_ITLB_SET0_E0_VPN_CONST: u32 = 0;
pub const XCHAL_ITLB_SET0_E1_VPN_CONST: u32 = 536870912;
pub const XCHAL_ITLB_SET0_E2_VPN_CONST: u32 = 1073741824;
pub const XCHAL_ITLB_SET0_E3_VPN_CONST: u32 = 1610612736;
pub const XCHAL_ITLB_SET0_E4_VPN_CONST: u32 = 2147483648;
pub const XCHAL_ITLB_SET0_E5_VPN_CONST: u32 = 2684354560;
pub const XCHAL_ITLB_SET0_E6_VPN_CONST: u32 = 3221225472;
pub const XCHAL_ITLB_SET0_E7_VPN_CONST: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_E0_PPN_CONST: u32 = 0;
pub const XCHAL_ITLB_SET0_E1_PPN_CONST: u32 = 536870912;
pub const XCHAL_ITLB_SET0_E2_PPN_CONST: u32 = 1073741824;
pub const XCHAL_ITLB_SET0_E3_PPN_CONST: u32 = 1610612736;
pub const XCHAL_ITLB_SET0_E4_PPN_CONST: u32 = 2147483648;
pub const XCHAL_ITLB_SET0_E5_PPN_CONST: u32 = 2684354560;
pub const XCHAL_ITLB_SET0_E6_PPN_CONST: u32 = 3221225472;
pub const XCHAL_ITLB_SET0_E7_PPN_CONST: u32 = 3758096384;
pub const XCHAL_ITLB_SET0_E0_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E1_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E2_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E3_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E4_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E5_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E6_CA_RESET: u32 = 2;
pub const XCHAL_ITLB_SET0_E7_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_WAY_BITS: u32 = 0;
pub const XCHAL_DTLB_WAYS: u32 = 1;
pub const XCHAL_DTLB_ARF_WAYS: u32 = 0;
pub const XCHAL_DTLB_SETS: u32 = 1;
pub const XCHAL_DTLB_WAY0_SET: u32 = 0;
pub const XCHAL_DTLB_ARF_SETS: u32 = 0;
pub const XCHAL_DTLB_MINWIRED_SETS: u32 = 0;
pub const XCHAL_DTLB_SET0_WAY: u32 = 0;
pub const XCHAL_DTLB_SET0_WAYS: u32 = 1;
pub const XCHAL_DTLB_SET0_ENTRIES_LOG2: u32 = 3;
pub const XCHAL_DTLB_SET0_ENTRIES: u32 = 8;
pub const XCHAL_DTLB_SET0_ARF: u32 = 0;
pub const XCHAL_DTLB_SET0_PAGESIZES: u32 = 1;
pub const XCHAL_DTLB_SET0_PAGESZ_BITS: u32 = 0;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_MIN: u32 = 29;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_MAX: u32 = 29;
pub const XCHAL_DTLB_SET0_PAGESZ_LOG2_LIST: u32 = 29;
pub const XCHAL_DTLB_SET0_ASID_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_VPN_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_PPN_CONSTMASK: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_CA_CONSTMASK: u32 = 0;
pub const XCHAL_DTLB_SET0_ASID_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_VPN_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_PPN_RESET: u32 = 0;
pub const XCHAL_DTLB_SET0_CA_RESET: u32 = 1;
pub const XCHAL_DTLB_SET0_E0_VPN_CONST: u32 = 0;
pub const XCHAL_DTLB_SET0_E1_VPN_CONST: u32 = 536870912;
pub const XCHAL_DTLB_SET0_E2_VPN_CONST: u32 = 1073741824;
pub const XCHAL_DTLB_SET0_E3_VPN_CONST: u32 = 1610612736;
pub const XCHAL_DTLB_SET0_E4_VPN_CONST: u32 = 2147483648;
pub const XCHAL_DTLB_SET0_E5_VPN_CONST: u32 = 2684354560;
pub const XCHAL_DTLB_SET0_E6_VPN_CONST: u32 = 3221225472;
pub const XCHAL_DTLB_SET0_E7_VPN_CONST: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_E0_PPN_CONST: u32 = 0;
pub const XCHAL_DTLB_SET0_E1_PPN_CONST: u32 = 536870912;
pub const XCHAL_DTLB_SET0_E2_PPN_CONST: u32 = 1073741824;
pub const XCHAL_DTLB_SET0_E3_PPN_CONST: u32 = 1610612736;
pub const XCHAL_DTLB_SET0_E4_PPN_CONST: u32 = 2147483648;
pub const XCHAL_DTLB_SET0_E5_PPN_CONST: u32 = 2684354560;
pub const XCHAL_DTLB_SET0_E6_PPN_CONST: u32 = 3221225472;
pub const XCHAL_DTLB_SET0_E7_PPN_CONST: u32 = 3758096384;
pub const XCHAL_DTLB_SET0_E0_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E1_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E2_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E3_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E4_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E5_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E6_CA_RESET: u32 = 2;
pub const XCHAL_DTLB_SET0_E7_CA_RESET: u32 = 2;
pub const XCHAL_HAVE_LE: u32 = 1;
pub const XCHAL_MEMORY_ORDER: u32 = 0;
pub const XCHAL_HAVE_HIGHLEVEL_INTERRUPTS: u32 = 1;
pub const XCHAL_NUM_LOWPRI_LEVELS: u32 = 1;
pub const XCHAL_FIRST_HIGHPRI_LEVEL: u32 = 2;
pub const XCHAL_INTLEVEL0_MASK: u32 = 0;
pub const XCHAL_INTLEVEL8_MASK: u32 = 0;
pub const XCHAL_INTLEVEL9_MASK: u32 = 0;
pub const XCHAL_INTLEVEL10_MASK: u32 = 0;
pub const XCHAL_INTLEVEL11_MASK: u32 = 0;
pub const XCHAL_INTLEVEL12_MASK: u32 = 0;
pub const XCHAL_INTLEVEL13_MASK: u32 = 0;
pub const XCHAL_INTLEVEL14_MASK: u32 = 0;
pub const XCHAL_INTLEVEL15_MASK: u32 = 0;
pub const XCHAL_INTLEVEL0_ANDBELOW_MASK: u32 = 0;
pub const XCHAL_INTLEVEL8_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL9_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL10_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL11_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL12_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL13_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL14_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_INTLEVEL15_ANDBELOW_MASK: u32 = 4294967295;
pub const XCHAL_LOWPRI_MASK: u32 = 407551;
pub const XCHAL_INTCLEARABLE_MASK: u32 = 1883243648;
pub const XCHAL_INTSETTABLE_MASK: u32 = 536871040;
pub const XCHAL_EXTINT0_MASK: u32 = 1;
pub const XCHAL_EXTINT1_MASK: u32 = 2;
pub const XCHAL_EXTINT2_MASK: u32 = 4;
pub const XCHAL_EXTINT3_MASK: u32 = 8;
pub const XCHAL_EXTINT4_MASK: u32 = 16;
pub const XCHAL_EXTINT5_MASK: u32 = 32;
pub const XCHAL_EXTINT6_MASK: u32 = 256;
pub const XCHAL_EXTINT7_MASK: u32 = 512;
pub const XCHAL_EXTINT8_MASK: u32 = 1024;
pub const XCHAL_EXTINT9_MASK: u32 = 4096;
pub const XCHAL_EXTINT10_MASK: u32 = 8192;
pub const XCHAL_EXTINT11_MASK: u32 = 16384;
pub const XCHAL_EXTINT12_MASK: u32 = 131072;
pub const XCHAL_EXTINT13_MASK: u32 = 262144;
pub const XCHAL_EXTINT14_MASK: u32 = 524288;
pub const XCHAL_EXTINT15_MASK: u32 = 1048576;
pub const XCHAL_EXTINT16_MASK: u32 = 2097152;
pub const XCHAL_EXTINT17_MASK: u32 = 4194304;
pub const XCHAL_EXTINT18_MASK: u32 = 8388608;
pub const XCHAL_EXTINT19_MASK: u32 = 16777216;
pub const XCHAL_EXTINT20_MASK: u32 = 33554432;
pub const XCHAL_EXTINT21_MASK: u32 = 67108864;
pub const XCHAL_EXTINT22_MASK: u32 = 134217728;
pub const XCHAL_EXTINT23_MASK: u32 = 268435456;
pub const XCHAL_EXTINT24_MASK: u32 = 1073741824;
pub const XCHAL_EXTINT25_MASK: u32 = 2147483648;
pub const XCHAL_HAVE_OLD_EXC_ARCH: u32 = 0;
pub const XCHAL_HAVE_EXCM: u32 = 1;
pub const XCHAL_PROGRAMEXC_VECTOR_VADDR: u32 = 1073742656;
pub const XCHAL_USEREXC_VECTOR_VADDR: u32 = 1073742656;
pub const XCHAL_PROGRAMEXC_VECTOR_PADDR: u32 = 1073742656;
pub const XCHAL_USEREXC_VECTOR_PADDR: u32 = 1073742656;
pub const XCHAL_STACKEDEXC_VECTOR_VADDR: u32 = 1073742592;
pub const XCHAL_KERNELEXC_VECTOR_VADDR: u32 = 1073742592;
pub const XCHAL_STACKEDEXC_VECTOR_PADDR: u32 = 1073742592;
pub const XCHAL_KERNELEXC_VECTOR_PADDR: u32 = 1073742592;
pub const XCHAL_EXCCAUSE_ILLEGAL_INSTRUCTION: u32 = 0;
pub const XCHAL_EXCCAUSE_SYSTEM_CALL: u32 = 1;
pub const XCHAL_EXCCAUSE_INSTRUCTION_FETCH_ERROR: u32 = 2;
pub const XCHAL_EXCCAUSE_LOAD_STORE_ERROR: u32 = 3;
pub const XCHAL_EXCCAUSE_LEVEL1_INTERRUPT: u32 = 4;
pub const XCHAL_EXCCAUSE_ALLOCA: u32 = 5;
pub const XCHAL_EXCCAUSE_INTEGER_DIVIDE_BY_ZERO: u32 = 6;
pub const XCHAL_EXCCAUSE_SPECULATION: u32 = 7;
pub const XCHAL_EXCCAUSE_PRIVILEGED: u32 = 8;
pub const XCHAL_EXCCAUSE_UNALIGNED: u32 = 9;
pub const XCHAL_EXCCAUSE_ITLB_MISS: u32 = 16;
pub const XCHAL_EXCCAUSE_ITLB_MULTIHIT: u32 = 17;
pub const XCHAL_EXCCAUSE_ITLB_PRIVILEGE: u32 = 18;
pub const XCHAL_EXCCAUSE_ITLB_SIZE_RESTRICTION: u32 = 19;
pub const XCHAL_EXCCAUSE_FETCH_CACHE_ATTRIBUTE: u32 = 20;
pub const XCHAL_EXCCAUSE_DTLB_MISS: u32 = 24;
pub const XCHAL_EXCCAUSE_DTLB_MULTIHIT: u32 = 25;
pub const XCHAL_EXCCAUSE_DTLB_PRIVILEGE: u32 = 26;
pub const XCHAL_EXCCAUSE_DTLB_SIZE_RESTRICTION: u32 = 27;
pub const XCHAL_EXCCAUSE_LOAD_CACHE_ATTRIBUTE: u32 = 28;
pub const XCHAL_EXCCAUSE_STORE_CACHE_ATTRIBUTE: u32 = 29;
pub const XCHAL_EXCCAUSE_COPROCESSOR0_DISABLED: u32 = 32;
pub const XCHAL_EXCCAUSE_COPROCESSOR1_DISABLED: u32 = 33;
pub const XCHAL_EXCCAUSE_COPROCESSOR2_DISABLED: u32 = 34;
pub const XCHAL_EXCCAUSE_COPROCESSOR3_DISABLED: u32 = 35;
pub const XCHAL_EXCCAUSE_COPROCESSOR4_DISABLED: u32 = 36;
pub const XCHAL_EXCCAUSE_COPROCESSOR5_DISABLED: u32 = 37;
pub const XCHAL_EXCCAUSE_COPROCESSOR6_DISABLED: u32 = 38;
pub const XCHAL_EXCCAUSE_COPROCESSOR7_DISABLED: u32 = 39;
pub const XCHAL_DBREAKC_VALIDMASK: u32 = 3221225535;
pub const XCHAL_DBREAKC_MASK_BITS: u32 = 6;
pub const XCHAL_DBREAKC_MASK_NUM: u32 = 64;
pub const XCHAL_DBREAKC_MASK_SHIFT: u32 = 0;
pub const XCHAL_DBREAKC_MASK_MASK: u32 = 63;
pub const XCHAL_DBREAKC_LOADBREAK_BITS: u32 = 1;
pub const XCHAL_DBREAKC_LOADBREAK_NUM: u32 = 2;
pub const XCHAL_DBREAKC_LOADBREAK_SHIFT: u32 = 30;
pub const XCHAL_DBREAKC_LOADBREAK_MASK: u32 = 1073741824;
pub const XCHAL_DBREAKC_STOREBREAK_BITS: u32 = 1;
pub const XCHAL_DBREAKC_STOREBREAK_NUM: u32 = 2;
pub const XCHAL_DBREAKC_STOREBREAK_SHIFT: u32 = 31;
pub const XCHAL_DBREAKC_STOREBREAK_MASK: u32 = 2147483648;
pub const XCHAL_PS_VALIDMASK: u32 = 462655;
pub const XCHAL_PS_INTLEVEL_BITS: u32 = 4;
pub const XCHAL_PS_INTLEVEL_NUM: u32 = 16;
pub const XCHAL_PS_INTLEVEL_SHIFT: u32 = 0;
pub const XCHAL_PS_INTLEVEL_MASK: u32 = 15;
pub const XCHAL_PS_EXCM_BITS: u32 = 1;
pub const XCHAL_PS_EXCM_NUM: u32 = 2;
pub const XCHAL_PS_EXCM_SHIFT: u32 = 4;
pub const XCHAL_PS_EXCM_MASK: u32 = 16;
pub const XCHAL_PS_UM_BITS: u32 = 1;
pub const XCHAL_PS_UM_NUM: u32 = 2;
pub const XCHAL_PS_UM_SHIFT: u32 = 5;
pub const XCHAL_PS_UM_MASK: u32 = 32;
pub const XCHAL_PS_RING_BITS: u32 = 2;
pub const XCHAL_PS_RING_NUM: u32 = 4;
pub const XCHAL_PS_RING_SHIFT: u32 = 6;
pub const XCHAL_PS_RING_MASK: u32 = 192;
pub const XCHAL_PS_OWB_BITS: u32 = 4;
pub const XCHAL_PS_OWB_NUM: u32 = 16;
pub const XCHAL_PS_OWB_SHIFT: u32 = 8;
pub const XCHAL_PS_OWB_MASK: u32 = 3840;
pub const XCHAL_PS_CALLINC_BITS: u32 = 2;
pub const XCHAL_PS_CALLINC_NUM: u32 = 4;
pub const XCHAL_PS_CALLINC_SHIFT: u32 = 16;
pub const XCHAL_PS_CALLINC_MASK: u32 = 196608;
pub const XCHAL_PS_WOE_BITS: u32 = 1;
pub const XCHAL_PS_WOE_NUM: u32 = 2;
pub const XCHAL_PS_WOE_SHIFT: u32 = 18;
pub const XCHAL_PS_WOE_MASK: u32 = 262144;
pub const XCHAL_EXCCAUSE_VALIDMASK: u32 = 63;
pub const XCHAL_EXCCAUSE_BITS: u32 = 6;
pub const XCHAL_EXCCAUSE_NUM: u32 = 64;
pub const XCHAL_EXCCAUSE_SHIFT: u32 = 0;
pub const XCHAL_EXCCAUSE_MASK: u32 = 63;
pub const XCHAL_DEBUGCAUSE_VALIDMASK: u32 = 63;
pub const XCHAL_DEBUGCAUSE_ICOUNT_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_ICOUNT_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_ICOUNT_SHIFT: u32 = 0;
pub const XCHAL_DEBUGCAUSE_ICOUNT_MASK: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_IBREAK_SHIFT: u32 = 1;
pub const XCHAL_DEBUGCAUSE_IBREAK_MASK: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_DBREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_SHIFT: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DBREAK_MASK: u32 = 4;
pub const XCHAL_DEBUGCAUSE_BREAK_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_BREAK_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_BREAK_SHIFT: u32 = 3;
pub const XCHAL_DEBUGCAUSE_BREAK_MASK: u32 = 8;
pub const XCHAL_DEBUGCAUSE_BREAKN_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_BREAKN_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_BREAKN_SHIFT: u32 = 4;
pub const XCHAL_DEBUGCAUSE_BREAKN_MASK: u32 = 16;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_BITS: u32 = 1;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_NUM: u32 = 2;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_SHIFT: u32 = 5;
pub const XCHAL_DEBUGCAUSE_DEBUGINT_MASK: u32 = 32;
pub const XCHAL_NUM_IROM: u32 = 1;
pub const XCHAL_NUM_IRAM: u32 = 2;
pub const XCHAL_NUM_DROM: u32 = 1;
pub const XCHAL_NUM_DRAM: u32 = 2;
pub const XCHAL_IROM0_VADDR: u32 = 1082130432;
pub const XCHAL_IROM0_PADDR: u32 = 1082130432;
pub const XCHAL_IROM0_SIZE: u32 = 4194304;
pub const XCHAL_IRAM0_VADDR: u32 = 1073741824;
pub const XCHAL_IRAM0_PADDR: u32 = 1073741824;
pub const XCHAL_IRAM0_SIZE: u32 = 4194304;
pub const XCHAL_IRAM1_VADDR: u32 = 1077936128;
pub const XCHAL_IRAM1_PADDR: u32 = 1077936128;
pub const XCHAL_IRAM1_SIZE: u32 = 4194304;
pub const XCHAL_DROM0_VADDR: u32 = 1061158912;
pub const XCHAL_DROM0_PADDR: u32 = 1061158912;
pub const XCHAL_DROM0_SIZE: u32 = 4194304;
pub const XCHAL_DRAM0_VADDR: u32 = 1073217536;
pub const XCHAL_DRAM0_PADDR: u32 = 1073217536;
pub const XCHAL_DRAM0_SIZE: u32 = 524288;
pub const XCHAL_DRAM1_VADDR: u32 = 1065353216;
pub const XCHAL_DRAM1_PADDR: u32 = 1065353216;
pub const XCHAL_DRAM1_SIZE: u32 = 4194304;
pub const XCHAL_CACHE_PREFCTL_DEFAULT: u32 = 4164;
pub const XCHAL_CACHE_LINEWIDTH_MAX: u32 = 2;
pub const XCHAL_CACHE_LINESIZE_MAX: u32 = 4;
pub const XCHAL_ICACHE_SETSIZE: u32 = 1;
pub const XCHAL_DCACHE_SETSIZE: u32 = 1;
pub const XCHAL_CACHE_SETWIDTH_MAX: u32 = 0;
pub const XCHAL_CACHE_SETSIZE_MAX: u32 = 1;
pub const XCHAL_ICACHE_TAG_V_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_V: u32 = 1;
pub const XCHAL_ICACHE_TAG_F_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_F: u32 = 0;
pub const XCHAL_ICACHE_TAG_L_SHIFT: u32 = 0;
pub const XCHAL_ICACHE_TAG_L: u32 = 0;
pub const XCHAL_DCACHE_TAG_V_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_V: u32 = 1;
pub const XCHAL_DCACHE_TAG_F_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_F: u32 = 0;
pub const XCHAL_DCACHE_TAG_D_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_D: u32 = 0;
pub const XCHAL_DCACHE_TAG_L_SHIFT: u32 = 0;
pub const XCHAL_DCACHE_TAG_L: u32 = 0;
pub const XCHAL_CACHE_MEMCTL_DEFAULT: u32 = 0;
pub const _MEMCTL_SNOOP_EN: u32 = 0;
pub const _MEMCTL_L0IBUF_EN: u32 = 1;
pub const XCHAL_SNOOP_LB_MEMCTL_DEFAULT: u32 = 1;
pub const XCHAL_ALIGN_MAX: u32 = 4;
pub const XCHAL_HW_RELEASE_MAJOR: u32 = 2600;
pub const XCHAL_HW_RELEASE_MINOR: u32 = 3;
pub const XCHAL_HW_RELEASE_NAME: &'static [u8; 8usize] = b"LX6.0.3\0";
pub const XCHAL_EXTRA_SA_SIZE: u32 = 48;
pub const XCHAL_EXTRA_SA_ALIGN: u32 = 4;
pub const XCHAL_CPEXTRA_SA_SIZE: u32 = 128;
pub const XCHAL_CPEXTRA_SA_ALIGN: u32 = 4;
pub const XCHAL_CP1_NAME: u32 = 0;
pub const XCHAL_CP1_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP2_NAME: u32 = 0;
pub const XCHAL_CP2_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP3_NAME: u32 = 0;
pub const XCHAL_CP3_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP4_NAME: u32 = 0;
pub const XCHAL_CP4_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP5_NAME: u32 = 0;
pub const XCHAL_CP5_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP6_NAME: u32 = 0;
pub const XCHAL_CP6_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CP7_NAME: u32 = 0;
pub const XCHAL_CP7_SA_CONTENTS_LIBDB_NUM: u32 = 0;
pub const XCHAL_CPEXTRA_SA_SIZE_TOR2: u32 = 128;
pub const XCHAL_INST_ILLN: u32 = 61549;
pub const XCHAL_INST_ILLN_BYTE0: u32 = 109;
pub const XCHAL_INST_ILLN_BYTE1: u32 = 240;
pub const XTHAL_INST_ILL: u32 = 0;
pub const XCHAL_ERRATUM_453: u32 = 0;
pub const XCHAL_ERRATUM_497: u32 = 0;
pub const XCHAL_ERRATUM_572: u32 = 1;
pub const CALL0_ABI: u32 = 0;
pub const ALIGNPAD: u32 = 2;
pub const KERNELSTACKSIZE: u32 = 1024;
pub const XT_CP0_SA: u32 = 0;
pub const XT_CPENABLE: u32 = 0;
pub const XT_CPSTORED: u32 = 2;
pub const XT_CP_CS_ST: u32 = 4;
pub const XT_CP_ASA: u32 = 8;
pub const CORE_ID_PRO: u32 = 52685;
pub const CORE_ID_APP: u32 = 43947;
pub const ESP_INTR_FLAG_LEVEL1: u32 = 2;
pub const ESP_INTR_FLAG_LEVEL2: u32 = 4;
pub const ESP_INTR_FLAG_LEVEL3: u32 = 8;
pub const ESP_INTR_FLAG_LEVEL4: u32 = 16;
pub const ESP_INTR_FLAG_LEVEL5: u32 = 32;
pub const ESP_INTR_FLAG_LEVEL6: u32 = 64;
pub const ESP_INTR_FLAG_NMI: u32 = 128;
pub const ESP_INTR_FLAG_SHARED: u32 = 256;
pub const ESP_INTR_FLAG_EDGE: u32 = 512;
pub const ESP_INTR_FLAG_IRAM: u32 = 1024;
pub const ESP_INTR_FLAG_INTRDISABLED: u32 = 2048;
pub const ESP_INTR_FLAG_LOWMED: u32 = 14;
pub const ESP_INTR_FLAG_HIGH: u32 = 240;
pub const ESP_INTR_FLAG_LEVELMASK: u32 = 254;
pub const ETS_INTERNAL_TIMER0_INTR_SOURCE: i32 = -1;
pub const ETS_INTERNAL_TIMER1_INTR_SOURCE: i32 = -2;
pub const ETS_INTERNAL_TIMER2_INTR_SOURCE: i32 = -3;
pub const ETS_INTERNAL_SW0_INTR_SOURCE: i32 = -4;
pub const ETS_INTERNAL_SW1_INTR_SOURCE: i32 = -5;
pub const ETS_INTERNAL_PROFILING_INTR_SOURCE: i32 = -6;
pub const ETS_INTERNAL_INTR_SOURCE_OFF: u32 = 6;
pub const CONFIG_IDF_TARGET_ESP32: u32 = 1;
pub const CONFIG_IDF_TARGET: &'static [u8; 6usize] = b"esp32\0";
pub const CONFIG_IDF_FIRMWARE_CHIP_ID: u32 = 0;
pub const CONFIG_SDK_TOOLPREFIX: &'static [u8; 18usize] = b"xtensa-esp32-elf-\0";
pub const CONFIG_SDK_PYTHON: &'static [u8; 7usize] = b"python\0";
pub const CONFIG_SDK_MAKE_WARN_UNDEFINED_VARIABLES: u32 = 1;
pub const CONFIG_APP_COMPILE_TIME_DATE: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL_VERBOSE: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL: u32 = 5;
pub const CONFIG_BOOTLOADER_VDDSDIO_BOOST_1_9V: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_ENABLE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_TIME_MS: u32 = 9000;
pub const CONFIG_ESPTOOLPY_PORT: &'static [u8; 13usize] = b"/dev/ttyUSB0\0";
pub const CONFIG_ESPTOOLPY_BAUD_115200B: u32 = 1;
pub const CONFIG_ESPTOOLPY_BAUD_OTHER_VAL: u32 = 115200;
pub const CONFIG_ESPTOOLPY_BAUD: u32 = 115200;
pub const CONFIG_ESPTOOLPY_COMPRESSED: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE: &'static [u8; 4usize] = b"dio\0";
pub const CONFIG_ESPTOOLPY_FLASHFREQ_40M: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ: &'static [u8; 4usize] = b"40m\0";
pub const CONFIG_ESPTOOLPY_FLASHSIZE_2MB: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHSIZE: &'static [u8; 4usize] = b"2MB\0";
pub const CONFIG_ESPTOOLPY_FLASHSIZE_DETECT: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE: &'static [u8; 14usize] = b"default_reset\0";
pub const CONFIG_ESPTOOLPY_AFTER_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_AFTER: &'static [u8; 11usize] = b"hard_reset\0";
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD_115200B: u32 = 1;
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD_OTHER_VAL: u32 = 115200;
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_PARTITION_TABLE_SINGLE_APP: u32 = 1;
pub const CONFIG_PARTITION_TABLE_CUSTOM_FILENAME: &'static [u8; 15usize] = b"partitions.csv\0";
pub const CONFIG_PARTITION_TABLE_FILENAME: &'static [u8; 25usize] = b"partitions_singleapp.csv\0";
pub const CONFIG_PARTITION_TABLE_OFFSET: u32 = 32768;
pub const CONFIG_PARTITION_TABLE_MD5: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_LEVEL_DEBUG: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE: u32 = 1;
pub const CONFIG_COMPILER_STACK_CHECK_MODE_NONE: u32 = 1;
pub const CONFIG_ESP32_APPTRACE_DEST_NONE: u32 = 1;
pub const CONFIG_ESP32_APPTRACE_LOCK_ENABLE: u32 = 1;
pub const CONFIG_BT_ENABLED: u32 = 1;
pub const CONFIG_BTDM_CTRL_MODE_BLE_ONLY: u32 = 1;
pub const CONFIG_BTDM_CTRL_BLE_MAX_CONN: u32 = 3;
pub const CONFIG_BTDM_CTRL_BR_EDR_SCO_DATA_PATH_EFF: u32 = 0;
pub const CONFIG_BTDM_CTRL_BLE_MAX_CONN_EFF: u32 = 3;
pub const CONFIG_BTDM_CTRL_BR_EDR_MAX_ACL_CONN_EFF: u32 = 0;
pub const CONFIG_BTDM_CTRL_BR_EDR_MAX_SYNC_CONN_EFF: u32 = 0;
pub const CONFIG_BTDM_CTRL_PINNED_TO_CORE_0: u32 = 1;
pub const CONFIG_BTDM_CTRL_PINNED_TO_CORE: u32 = 0;
pub const CONFIG_BTDM_CTRL_HCI_MODE_VHCI: u32 = 1;
pub const CONFIG_BTDM_MODEM_SLEEP: u32 = 1;
pub const CONFIG_BTDM_MODEM_SLEEP_MODE_ORIG: u32 = 1;
pub const CONFIG_BTDM_LPCLK_SEL_MAIN_XTAL: u32 = 1;
pub const CONFIG_BTDM_BLE_DEFAULT_SCA_250PPM: u32 = 1;
pub const CONFIG_BTDM_BLE_SLEEP_CLOCK_ACCURACY_INDEX_EFF: u32 = 1;
pub const CONFIG_BTDM_BLE_SCAN_DUPL: u32 = 1;
pub const CONFIG_BTDM_SCAN_DUPL_TYPE_DEVICE: u32 = 1;
pub const CONFIG_BTDM_SCAN_DUPL_TYPE: u32 = 0;
pub const CONFIG_BTDM_SCAN_DUPL_CACHE_SIZE: u32 = 200;
pub const CONFIG_BTDM_BLE_ADV_REPORT_FLOW_CTRL_SUPP: u32 = 1;
pub const CONFIG_BTDM_BLE_ADV_REPORT_FLOW_CTRL_NUM: u32 = 100;
pub const CONFIG_BTDM_BLE_ADV_REPORT_DISCARD_THRSHOLD: u32 = 20;
pub const CONFIG_BT_NIMBLE_ENABLED: u32 = 1;
pub const CONFIG_BT_RESERVE_DRAM: u32 = 56156;
pub const CONFIG_BT_NIMBLE_MAX_CONNECTIONS: u32 = 1;
pub const CONFIG_BT_NIMBLE_MAX_BONDS: u32 = 3;
pub const CONFIG_BT_NIMBLE_MAX_CCCDS: u32 = 8;
pub const CONFIG_BT_NIMBLE_L2CAP_COC_MAX_NUM: u32 = 0;
pub const CONFIG_BT_NIMBLE_PINNED_TO_CORE_0: u32 = 1;
pub const CONFIG_BT_NIMBLE_PINNED_TO_CORE: u32 = 0;
pub const CONFIG_BT_NIMBLE_TASK_STACK_SIZE: u32 = 4096;
pub const CONFIG_BT_NIMBLE_ROLE_CENTRAL: u32 = 1;
pub const CONFIG_BT_NIMBLE_ROLE_PERIPHERAL: u32 = 1;
pub const CONFIG_BT_NIMBLE_ROLE_BROADCASTER: u32 = 1;
pub const CONFIG_BT_NIMBLE_ROLE_OBSERVER: u32 = 1;
pub const CONFIG_BT_NIMBLE_NVS_PERSIST: u32 = 1;
pub const CONFIG_BT_NIMBLE_SM_LEGACY: u32 = 1;
pub const CONFIG_BT_NIMBLE_SM_SC: u32 = 1;
pub const CONFIG_BT_NIMBLE_SVC_GAP_DEVICE_NAME: &'static [u8; 7usize] = b"nimble\0";
pub const CONFIG_BT_NIMBLE_GAP_DEVICE_NAME_MAX_LEN: u32 = 31;
pub const CONFIG_BT_NIMBLE_ATT_PREFERRED_MTU: u32 = 256;
pub const CONFIG_BT_NIMBLE_SVC_GAP_APPEARANCE: u32 = 0;
pub const CONFIG_BT_NIMBLE_ACL_BUF_COUNT: u32 = 12;
pub const CONFIG_BT_NIMBLE_ACL_BUF_SIZE: u32 = 255;
pub const CONFIG_BT_NIMBLE_HCI_EVT_BUF_SIZE: u32 = 70;
pub const CONFIG_BT_NIMBLE_HCI_EVT_HI_BUF_COUNT: u32 = 30;
pub const CONFIG_BT_NIMBLE_HCI_EVT_LO_BUF_COUNT: u32 = 8;
pub const CONFIG_BT_NIMBLE_CRYPTO_STACK_MBEDTLS: u32 = 1;
pub const CONFIG_ADC_DISABLE_DAC: u32 = 1;
pub const CONFIG_SPI_MASTER_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_SPI_SLAVE_ISR_IN_IRAM: u32 = 1;
pub const CONFIG_EFUSE_CODE_SCHEME_COMPAT_3_4: u32 = 1;
pub const CONFIG_EFUSE_MAX_BLK_LEN: u32 = 192;
pub const CONFIG_ESP32_REV_MIN_0: u32 = 1;
pub const CONFIG_ESP32_REV_MIN: u32 = 0;
pub const CONFIG_ESP32_DPORT_WORKAROUND: u32 = 1;
pub const CONFIG_ESP32_DEFAULT_CPU_FREQ_160: u32 = 1;
pub const CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ: u32 = 160;
pub const CONFIG_ESP32_TRACEMEM_RESERVE_DRAM: u32 = 0;
pub const CONFIG_ESP32_UNIVERSAL_MAC_ADDRESSES_FOUR: u32 = 1;
pub const CONFIG_ESP32_UNIVERSAL_MAC_ADDRESSES: u32 = 4;
pub const CONFIG_ESP32_ULP_COPROC_RESERVE_MEM: u32 = 0;
pub const CONFIG_ESP32_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_ESP32_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_ESP32_DEBUG_STUBS_ENABLE: u32 = 1;
pub const CONFIG_ESP32_BROWNOUT_DET: u32 = 1;
pub const CONFIG_ESP32_BROWNOUT_DET_LVL_SEL_0: u32 = 1;
pub const CONFIG_ESP32_BROWNOUT_DET_LVL: u32 = 0;
pub const CONFIG_ESP32_REDUCE_PHY_TX_POWER: u32 = 1;
pub const CONFIG_ESP32_TIME_SYSCALL_USE_RTC_FRC1: u32 = 1;
pub const CONFIG_ESP32_RTC_CLK_SRC_INT_RC: u32 = 1;
pub const CONFIG_ESP32_RTC_CLK_CAL_CYCLES: u32 = 1024;
pub const CONFIG_ESP32_DEEP_SLEEP_WAKEUP_DELAY: u32 = 2000;
pub const CONFIG_ESP32_XTAL_FREQ_40: u32 = 1;
pub const CONFIG_ESP32_XTAL_FREQ: u32 = 40;
pub const CONFIG_ESP32_DPORT_DIS_INTERRUPT_LVL: u32 = 5;
pub const CONFIG_ADC_CAL_EFUSE_TP_ENABLE: u32 = 1;
pub const CONFIG_ADC_CAL_EFUSE_VREF_ENABLE: u32 = 1;
pub const CONFIG_ADC_CAL_LUT_ENABLE: u32 = 1;
pub const CONFIG_ESP_ERR_TO_NAME_LOOKUP: u32 = 1;
pub const CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_ESP_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_ESP_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_ESP_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_ESP_INT_WDT: u32 = 1;
pub const CONFIG_ESP_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_ESP_INT_WDT_CHECK_CPU1: u32 = 1;
pub const CONFIG_ESP_TASK_WDT: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU1: u32 = 1;
pub const CONFIG_ETH_USE_ESP32_EMAC: u32 = 1;
pub const CONFIG_ETH_PHY_INTERFACE_RMII: u32 = 1;
pub const CONFIG_ETH_RMII_CLK_INPUT: u32 = 1;
pub const CONFIG_ETH_RMII_CLK_IN_GPIO: u32 = 0;
pub const CONFIG_ETH_SMI_MDC_GPIO: u32 = 23;
pub const CONFIG_ETH_SMI_MDIO_GPIO: u32 = 18;
pub const CONFIG_ETH_PHY_USE_RST: u32 = 1;
pub const CONFIG_ETH_PHY_RST_GPIO: u32 = 5;
pub const CONFIG_ETH_DMA_BUFFER_SIZE: u32 = 512;
pub const CONFIG_ETH_DMA_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ETH_DMA_TX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ETH_USE_SPI_ETHERNET: u32 = 1;
pub const CONFIG_ETH_SPI_ETHERNET_DM9051: u32 = 1;
pub const CONFIG_ETH_DM9051_INT_GPIO: u32 = 4;
pub const CONFIG_ESP_EVENT_POST_FROM_ISR: u32 = 1;
pub const CONFIG_ESP_EVENT_POST_FROM_IRAM_ISR: u32 = 1;
pub const CONFIG_ESP_HTTP_CLIENT_ENABLE_HTTPS: u32 = 1;
pub const CONFIG_HTTPD_MAX_REQ_HDR_LEN: u32 = 512;
pub const CONFIG_HTTPD_MAX_URI_LEN: u32 = 512;
pub const CONFIG_HTTPD_ERR_RESP_NO_DELAY: u32 = 1;
pub const CONFIG_HTTPD_PURGE_BUF_LEN: u32 = 32;
pub const CONFIG_ESP32_WIFI_SW_COEXIST_ENABLE: u32 = 1;
pub const CONFIG_ESP32_WIFI_SW_COEXIST_PREFERENCE_BALANCE: u32 = 1;
pub const CONFIG_ESP32_WIFI_SW_COEXIST_PREFERENCE_VALUE: u32 = 2;
pub const CONFIG_ESP32_WIFI_STATIC_RX_BUFFER_NUM: u32 = 10;
pub const CONFIG_ESP32_WIFI_DYNAMIC_RX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER: u32 = 1;
pub const CONFIG_ESP32_WIFI_TX_BUFFER_TYPE: u32 = 1;
pub const CONFIG_ESP32_WIFI_DYNAMIC_TX_BUFFER_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_AMPDU_TX_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_TX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_AMPDU_RX_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_RX_BA_WIN: u32 = 6;
pub const CONFIG_ESP32_WIFI_NVS_ENABLED: u32 = 1;
pub const CONFIG_ESP32_WIFI_TASK_PINNED_TO_CORE_0: u32 = 1;
pub const CONFIG_ESP32_WIFI_SOFTAP_BEACON_MAX_LEN: u32 = 752;
pub const CONFIG_ESP32_WIFI_MGMT_SBUF_NUM: u32 = 32;
pub const CONFIG_ESP32_WIFI_IRAM_OPT: u32 = 1;
pub const CONFIG_ESP32_PHY_CALIBRATION_AND_DATA_STORAGE: u32 = 1;
pub const CONFIG_ESP32_PHY_MAX_WIFI_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_PHY_MAX_TX_POWER: u32 = 20;
pub const CONFIG_ESP32_ENABLE_COREDUMP_TO_NONE: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE_437: u32 = 1;
pub const CONFIG_FATFS_CODEPAGE: u32 = 437;
pub const CONFIG_FATFS_LFN_NONE: u32 = 1;
pub const CONFIG_FATFS_FS_LOCK: u32 = 0;
pub const CONFIG_FATFS_TIMEOUT_MS: u32 = 10000;
pub const CONFIG_FATFS_PER_FILE_CACHE: u32 = 1;
pub const CONFIG_FMB_MASTER_TIMEOUT_MS_RESPOND: u32 = 150;
pub const CONFIG_FMB_MASTER_DELAY_MS_CONVERT: u32 = 200;
pub const CONFIG_FMB_QUEUE_LENGTH: u32 = 20;
pub const CONFIG_FMB_SERIAL_TASK_STACK_SIZE: u32 = 2048;
pub const CONFIG_FMB_SERIAL_BUF_SIZE: u32 = 256;
pub const CONFIG_FMB_SERIAL_TASK_PRIO: u32 = 10;
pub const CONFIG_FMB_CONTROLLER_NOTIFY_TIMEOUT: u32 = 20;
pub const CONFIG_FMB_CONTROLLER_NOTIFY_QUEUE_SIZE: u32 = 20;
pub const CONFIG_FMB_CONTROLLER_STACK_SIZE: u32 = 4096;
pub const CONFIG_FMB_EVENT_QUEUE_TIMEOUT: u32 = 20;
pub const CONFIG_FMB_TIMER_PORT_ENABLED: u32 = 1;
pub const CONFIG_FMB_TIMER_GROUP: u32 = 0;
pub const CONFIG_FMB_TIMER_INDEX: u32 = 0;
pub const CONFIG_FREERTOS_NO_AFFINITY: u32 = 2147483647;
pub const CONFIG_FREERTOS_CORETIMER_0: u32 = 1;
pub const CONFIG_FREERTOS_HZ: u32 = 100;
pub const CONFIG_FREERTOS_ASSERT_ON_UNTESTED_FUNCTION: u32 = 1;
pub const CONFIG_FREERTOS_CHECK_STACKOVERFLOW_CANARY: u32 = 1;
pub const CONFIG_FREERTOS_INTERRUPT_BACKTRACE: u32 = 1;
pub const CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const CONFIG_FREERTOS_ASSERT_FAIL_ABORT: u32 = 1;
pub const CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_ISR_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_MAX_TASK_NAME_LEN: u32 = 16;
pub const CONFIG_FREERTOS_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_FREERTOS_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_FREERTOS_QUEUE_REGISTRY_SIZE: u32 = 0;
pub const CONFIG_FREERTOS_TASK_FUNCTION_WRAPPER: u32 = 1;
pub const CONFIG_FREERTOS_CHECK_MUTEX_GIVEN_BY_OWNER: u32 = 1;
pub const CONFIG_HEAP_POISONING_DISABLED: u32 = 1;
pub const CONFIG_HEAP_TRACING_OFF: u32 = 1;
pub const CONFIG_LIBSODIUM_USE_MBEDTLS_SHA: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL_INFO: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL: u32 = 3;
pub const CONFIG_LOG_COLORS: u32 = 1;
pub const CONFIG_LWIP_LOCAL_HOSTNAME: &'static [u8; 10usize] = b"espressif\0";
pub const CONFIG_LWIP_TIMERS_ONDEMAND: u32 = 1;
pub const CONFIG_LWIP_MAX_SOCKETS: u32 = 10;
pub const CONFIG_LWIP_SO_REUSE: u32 = 1;
pub const CONFIG_LWIP_SO_REUSE_RXTOALL: u32 = 1;
pub const CONFIG_LWIP_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_LWIP_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_LWIP_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_LWIP_DHCP_DOES_ARP_CHECK: u32 = 1;
pub const CONFIG_LWIP_DHCPS_LEASE_UNIT: u32 = 60;
pub const CONFIG_LWIP_DHCPS_MAX_STATION_NUM: u32 = 8;
pub const CONFIG_LWIP_NETIF_LOOPBACK: u32 = 1;
pub const CONFIG_LWIP_LOOPBACK_MAX_PBUFS: u32 = 8;
pub const CONFIG_LWIP_MAX_ACTIVE_TCP: u32 = 16;
pub const CONFIG_LWIP_MAX_LISTENING_TCP: u32 = 16;
pub const CONFIG_LWIP_TCP_MAXRTX: u32 = 12;
pub const CONFIG_LWIP_TCP_SYNMAXRTX: u32 = 6;
pub const CONFIG_LWIP_TCP_MSS: u32 = 1436;
pub const CONFIG_LWIP_TCP_MSL: u32 = 60000;
pub const CONFIG_LWIP_TCP_SND_BUF_DEFAULT: u32 = 5744;
pub const CONFIG_LWIP_TCP_WND_DEFAULT: u32 = 5744;
pub const CONFIG_LWIP_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_LWIP_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_LWIP_MAX_UDP_PCBS: u32 = 16;
pub const CONFIG_LWIP_UDP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_LWIP_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_LWIP_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_LWIP_MAX_RAW_PCBS: u32 = 16;
pub const CONFIG_LWIP_DHCP_MAX_NTP_SERVERS: u32 = 1;
pub const CONFIG_LWIP_SNTP_UPDATE_DELAY: u32 = 3600000;
pub const CONFIG_MBEDTLS_INTERNAL_MEM_ALLOC: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_MAX_CONTENT_LEN: u32 = 16384;
pub const CONFIG_MBEDTLS_ECP_RESTARTABLE: u32 = 1;
pub const CONFIG_MBEDTLS_CMAC_C: u32 = 1;
pub const CONFIG_MBEDTLS_HARDWARE_AES: u32 = 1;
pub const CONFIG_MBEDTLS_HAVE_TIME: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER_AND_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_SERVER: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_CLIENT: u32 = 1;
pub const CONFIG_MBEDTLS_TLS_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_DHE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ELLIPTIC_CURVE: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA: u32 = 1;
pub const CONFIG_MBEDTLS_KEY_EXCHANGE_ECDH_RSA: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_RENEGOTIATION: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_1: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_PROTO_TLS1_2: u32 = 1;
pub const CONFIG_MBEDTLS_SSL_ALPN: u32 = 1;
pub const CONFIG_MBEDTLS_CLIENT_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_SERVER_SSL_SESSION_TICKETS: u32 = 1;
pub const CONFIG_MBEDTLS_AES_C: u32 = 1;
pub const CONFIG_MBEDTLS_RC4_DISABLED: u32 = 1;
pub const CONFIG_MBEDTLS_CCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_GCM_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_PEM_WRITE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CRL_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_X509_CSR_PARSE_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDH_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECDSA_C: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP521R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP192K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP224K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_SECP256K1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP256R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP384R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_BP512R1_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_DP_CURVE25519_ENABLED: u32 = 1;
pub const CONFIG_MBEDTLS_ECP_NIST_OPTIM: u32 = 1;
pub const CONFIG_MDNS_MAX_SERVICES: u32 = 10;
pub const CONFIG_MQTT_PROTOCOL_311: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_SSL: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET: u32 = 1;
pub const CONFIG_MQTT_TRANSPORT_WEBSOCKET_SECURE: u32 = 1;
pub const CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF: u32 = 1;
pub const CONFIG_NEWLIB_STDIN_LINE_ENDING_CR: u32 = 1;
pub const CONFIG_OPENSSL_ASSERT_DO_NOTHING: u32 = 1;
pub const CONFIG_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_PTHREAD_DEFAULT_CORE_NO_AFFINITY: u32 = 1;
pub const CONFIG_PTHREAD_TASK_CORE_DEFAULT: i32 = -1;
pub const CONFIG_PTHREAD_TASK_NAME_DEFAULT: &'static [u8; 8usize] = b"pthread\0";
pub const CONFIG_SPI_FLASH_ROM_DRIVER_PATCH: u32 = 1;
pub const CONFIG_SPI_FLASH_DANGEROUS_WRITE_ABORTS: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_ISSI_CHIP: u32 = 1;
pub const CONFIG_SPIFFS_MAX_PARTITIONS: u32 = 3;
pub const CONFIG_SPIFFS_CACHE: u32 = 1;
pub const CONFIG_SPIFFS_CACHE_WR: u32 = 1;
pub const CONFIG_SPIFFS_PAGE_CHECK: u32 = 1;
pub const CONFIG_SPIFFS_GC_MAX_RUNS: u32 = 10;
pub const CONFIG_SPIFFS_PAGE_SIZE: u32 = 256;
pub const CONFIG_SPIFFS_OBJ_NAME_LEN: u32 = 32;
pub const CONFIG_SPIFFS_USE_MAGIC: u32 = 1;
pub const CONFIG_SPIFFS_USE_MAGIC_LENGTH: u32 = 1;
pub const CONFIG_SPIFFS_META_LENGTH: u32 = 4;
pub const CONFIG_SPIFFS_USE_MTIME: u32 = 1;
pub const CONFIG_NETIF_IP_LOST_TIMER_INTERVAL: u32 = 120;
pub const CONFIG_TCPIP_LWIP: u32 = 1;
pub const CONFIG_UNITY_ENABLE_FLOAT: u32 = 1;
pub const CONFIG_UNITY_ENABLE_DOUBLE: u32 = 1;
pub const CONFIG_UNITY_ENABLE_IDF_TEST_RUNNER: u32 = 1;
pub const CONFIG_VFS_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_VFS_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_SEMIHOSTFS_MAX_MOUNT_POINTS: u32 = 1;
pub const CONFIG_SEMIHOSTFS_HOST_PATH_MAX_LEN: u32 = 128;
pub const CONFIG_WL_SECTOR_SIZE_4096: u32 = 1;
pub const CONFIG_WL_SECTOR_SIZE: u32 = 4096;
pub const CONFIG_WIFI_PROV_SCAN_MAX_ENTRIES: u32 = 16;
pub const CONFIG_WPA_MBEDTLS_CRYPTO: u32 = 1;
pub const CONFIG_ADC2_DISABLE_DAC: u32 = 1;
pub const CONFIG_BLE_ADV_REPORT_DISCARD_THRSHOLD: u32 = 20;
pub const CONFIG_BLE_ADV_REPORT_FLOW_CONTROL_NUM: u32 = 100;
pub const CONFIG_BLE_ADV_REPORT_FLOW_CONTROL_SUPPORTED: u32 = 1;
pub const CONFIG_BLE_SCAN_DUPLICATE: u32 = 1;
pub const CONFIG_BROWNOUT_DET: u32 = 1;
pub const CONFIG_BROWNOUT_DET_LVL: u32 = 0;
pub const CONFIG_BROWNOUT_DET_LVL_SEL_0: u32 = 1;
pub const CONFIG_BTDM_CONTROLLER_BLE_MAX_CONN: u32 = 3;
pub const CONFIG_BTDM_CONTROLLER_BLE_MAX_CONN_EFF: u32 = 3;
pub const CONFIG_BTDM_CONTROLLER_BR_EDR_MAX_ACL_CONN_EFF: u32 = 0;
pub const CONFIG_BTDM_CONTROLLER_BR_EDR_MAX_SYNC_CONN_EFF: u32 = 0;
pub const CONFIG_BTDM_CONTROLLER_HCI_MODE_VHCI: u32 = 1;
pub const CONFIG_BTDM_CONTROLLER_MODEM_SLEEP: u32 = 1;
pub const CONFIG_BTDM_CONTROLLER_MODE_BLE_ONLY: u32 = 1;
pub const CONFIG_BTDM_CONTROLLER_PINNED_TO_CORE: u32 = 0;
pub const CONFIG_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_DUPLICATE_SCAN_CACHE_SIZE: u32 = 200;
pub const CONFIG_ESP32_DEFAULT_PTHREAD_CORE_NO_AFFINITY: u32 = 1;
pub const CONFIG_ESP32_PTHREAD_STACK_MIN: u32 = 768;
pub const CONFIG_ESP32_PTHREAD_TASK_CORE_DEFAULT: i32 = -1;
pub const CONFIG_ESP32_PTHREAD_TASK_NAME_DEFAULT: &'static [u8; 8usize] = b"pthread\0";
pub const CONFIG_ESP32_PTHREAD_TASK_PRIO_DEFAULT: u32 = 5;
pub const CONFIG_ESP32_PTHREAD_TASK_STACK_SIZE_DEFAULT: u32 = 3072;
pub const CONFIG_ESP32_RTC_CLOCK_SOURCE_INTERNAL_RC: u32 = 1;
pub const CONFIG_ESP_GRATUITOUS_ARP: u32 = 1;
pub const CONFIG_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_FOUR_UNIVERSAL_MAC_ADDRESS: u32 = 1;
pub const CONFIG_GARP_TMR_INTERVAL: u32 = 60;
pub const CONFIG_INT_WDT: u32 = 1;
pub const CONFIG_INT_WDT_CHECK_CPU1: u32 = 1;
pub const CONFIG_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_IPC_TASK_STACK_SIZE: u32 = 1024;
pub const CONFIG_IP_LOST_TIMER_INTERVAL: u32 = 120;
pub const CONFIG_LOG_BOOTLOADER_LEVEL: u32 = 5;
pub const CONFIG_LOG_BOOTLOADER_LEVEL_VERBOSE: u32 = 1;
pub const CONFIG_MAIN_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_MAKE_WARN_UNDEFINED_VARIABLES: u32 = 1;
pub const CONFIG_MB_CONTROLLER_NOTIFY_QUEUE_SIZE: u32 = 20;
pub const CONFIG_MB_CONTROLLER_NOTIFY_TIMEOUT: u32 = 20;
pub const CONFIG_MB_CONTROLLER_STACK_SIZE: u32 = 4096;
pub const CONFIG_MB_EVENT_QUEUE_TIMEOUT: u32 = 20;
pub const CONFIG_MB_MASTER_DELAY_MS_CONVERT: u32 = 200;
pub const CONFIG_MB_MASTER_TIMEOUT_MS_RESPOND: u32 = 150;
pub const CONFIG_MB_QUEUE_LENGTH: u32 = 20;
pub const CONFIG_MB_SERIAL_BUF_SIZE: u32 = 256;
pub const CONFIG_MB_SERIAL_TASK_PRIO: u32 = 10;
pub const CONFIG_MB_SERIAL_TASK_STACK_SIZE: u32 = 2048;
pub const CONFIG_MB_TIMER_GROUP: u32 = 0;
pub const CONFIG_MB_TIMER_INDEX: u32 = 0;
pub const CONFIG_MB_TIMER_PORT_ENABLED: u32 = 1;
pub const CONFIG_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_MONITOR_BAUD_115200B: u32 = 1;
pub const CONFIG_MONITOR_BAUD_OTHER_VAL: u32 = 115200;
pub const CONFIG_NUMBER_OF_UNIVERSAL_MAC_ADDRESS: u32 = 4;
pub const CONFIG_OPTIMIZATION_ASSERTIONS_ENABLED: u32 = 1;
pub const CONFIG_OPTIMIZATION_LEVEL_DEBUG: u32 = 1;
pub const CONFIG_POST_EVENTS_FROM_IRAM_ISR: u32 = 1;
pub const CONFIG_POST_EVENTS_FROM_ISR: u32 = 1;
pub const CONFIG_PYTHON: &'static [u8; 7usize] = b"python\0";
pub const CONFIG_REDUCE_PHY_TX_POWER: u32 = 1;
pub const CONFIG_SCAN_DUPLICATE_BY_DEVICE_ADDR: u32 = 1;
pub const CONFIG_SCAN_DUPLICATE_TYPE: u32 = 0;
pub const CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ABORTS: u32 = 1;
pub const CONFIG_STACK_CHECK_NONE: u32 = 1;
pub const CONFIG_SUPPORT_TERMIOS: u32 = 1;
pub const CONFIG_SUPPRESS_SELECT_DEBUG_OUTPUT: u32 = 1;
pub const CONFIG_SW_COEXIST_ENABLE: u32 = 1;
pub const CONFIG_SW_COEXIST_PREFERENCE_BALANCE: u32 = 1;
pub const CONFIG_SW_COEXIST_PREFERENCE_VALUE: u32 = 2;
pub const CONFIG_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_TASK_WDT: u32 = 1;
pub const CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU1: u32 = 1;
pub const CONFIG_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_TCPIP_RECVMBOX_SIZE: u32 = 32;
pub const CONFIG_TCPIP_TASK_AFFINITY: u32 = 2147483647;
pub const CONFIG_TCPIP_TASK_AFFINITY_NO_AFFINITY: u32 = 1;
pub const CONFIG_TCPIP_TASK_STACK_SIZE: u32 = 3072;
pub const CONFIG_TCP_MAXRTX: u32 = 12;
pub const CONFIG_TCP_MSL: u32 = 60000;
pub const CONFIG_TCP_MSS: u32 = 1436;
pub const CONFIG_TCP_OVERSIZE_MSS: u32 = 1;
pub const CONFIG_TCP_QUEUE_OOSEQ: u32 = 1;
pub const CONFIG_TCP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_TCP_SND_BUF_DEFAULT: u32 = 5744;
pub const CONFIG_TCP_SYNMAXRTX: u32 = 6;
pub const CONFIG_TCP_WND_DEFAULT: u32 = 5744;
pub const CONFIG_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_TIMER_TASK_STACK_SIZE: u32 = 3584;
pub const CONFIG_TOOLPREFIX: &'static [u8; 18usize] = b"xtensa-esp32-elf-\0";
pub const CONFIG_TRACEMEM_RESERVE_DRAM: u32 = 0;
pub const CONFIG_UDP_RECVMBOX_SIZE: u32 = 6;
pub const CONFIG_ULP_COPROC_RESERVE_MEM: u32 = 0;
pub const portNUM_PROCESSORS: u32 = 2;
pub const XT_USE_THREAD_SAFE_CLIB: u32 = 0;
pub const configASSERT_2: u32 = 0;
pub const portUSING_MPU_WRAPPERS: u32 = 0;
pub const configUSE_MUTEX: u32 = 1;
pub const XT_TIMER_INDEX: u32 = 0;
pub const configNUM_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const configTHREAD_LOCAL_STORAGE_DELETE_CALLBACKS: u32 = 1;
pub const STK_INTEXC_EXTRA: u32 = 0;
pub const XT_CLIB_CONTEXT_AREA_SIZE: u32 = 0;
pub const XT_USER_SIZE: u32 = 1024;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const MACSTR: &'static [u8; 30usize] = b"%02x:%02x:%02x:%02x:%02x:%02x\0";
pub const configUSE_PREEMPTION: u32 = 1;
pub const configUSE_IDLE_HOOK: u32 = 1;
pub const configUSE_TICK_HOOK: u32 = 1;
pub const configTICK_RATE_HZ: u32 = 100;
pub const configMAX_PRIORITIES: u32 = 25;
pub const configMINIMAL_STACK_SIZE: u32 = 768;
pub const configIDLE_TASK_STACK_SIZE: u32 = 1536;
pub const configISR_STACK_SIZE: u32 = 1536;
pub const configAPPLICATION_ALLOCATED_HEAP: u32 = 1;
pub const configMAX_TASK_NAME_LEN: u32 = 16;
pub const configUSE_TRACE_FACILITY_2: u32 = 0;
pub const configBENCHMARK: u32 = 0;
pub const configUSE_16_BIT_TICKS: u32 = 0;
pub const configIDLE_SHOULD_YIELD: u32 = 0;
pub const configQUEUE_REGISTRY_SIZE: u32 = 0;
pub const configUSE_MUTEXES: u32 = 1;
pub const configUSE_RECURSIVE_MUTEXES: u32 = 1;
pub const configUSE_COUNTING_SEMAPHORES: u32 = 1;
pub const configCHECK_FOR_STACK_OVERFLOW: u32 = 2;
pub const configUSE_CO_ROUTINES: u32 = 0;
pub const configMAX_CO_ROUTINE_PRIORITIES: u32 = 2;
pub const INCLUDE_vTaskPrioritySet: u32 = 1;
pub const INCLUDE_uxTaskPriorityGet: u32 = 1;
pub const INCLUDE_vTaskDelete: u32 = 1;
pub const INCLUDE_vTaskCleanUpResources: u32 = 0;
pub const INCLUDE_vTaskSuspend: u32 = 1;
pub const INCLUDE_vTaskDelayUntil: u32 = 1;
pub const INCLUDE_vTaskDelay: u32 = 1;
pub const INCLUDE_uxTaskGetStackHighWaterMark: u32 = 1;
pub const INCLUDE_pcTaskGetTaskName: u32 = 1;
pub const INCLUDE_xTaskGetIdleTaskHandle: u32 = 1;
pub const INCLUDE_pxTaskGetStackStart: u32 = 1;
pub const INCLUDE_xSemaphoreGetMutexHolder: u32 = 1;
pub const configKERNEL_INTERRUPT_PRIORITY: u32 = 1;
pub const configMAX_SYSCALL_INTERRUPT_PRIORITY: u32 = 3;
pub const configUSE_NEWLIB_REENTRANT: u32 = 1;
pub const configSUPPORT_DYNAMIC_ALLOCATION: u32 = 1;
pub const configUSE_TIMERS: u32 = 1;
pub const configTIMER_TASK_PRIORITY: u32 = 1;
pub const configTIMER_QUEUE_LENGTH: u32 = 10;
pub const configTIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const INCLUDE_xTimerPendFunctionCall: u32 = 1;
pub const INCLUDE_eTaskGetState: u32 = 1;
pub const configUSE_QUEUE_SETS: u32 = 1;
pub const configXT_BOARD: u32 = 1;
pub const configXT_SIMULATOR: u32 = 0;
pub const configENABLE_TASK_SNAPSHOT: u32 = 1;
pub const configCHECK_MUTEX_GIVEN_BY_OWNER: u32 = 1;
pub const errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY: i32 = -1;
pub const errQUEUE_BLOCKED: i32 = -4;
pub const errQUEUE_YIELD: i32 = -5;
pub const configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES: u32 = 0;
pub const pdINTEGRITY_CHECK_VALUE: u32 = 1515870810;
pub const LBEG: u32 = 0;
pub const LEND: u32 = 1;
pub const LCOUNT: u32 = 2;
pub const SAR: u32 = 3;
pub const BR: u32 = 4;
pub const SCOMPARE1: u32 = 12;
pub const ACCLO: u32 = 16;
pub const ACCHI: u32 = 17;
pub const MR_0: u32 = 32;
pub const MR_1: u32 = 33;
pub const MR_2: u32 = 34;
pub const MR_3: u32 = 35;
pub const WINDOWBASE: u32 = 72;
pub const WINDOWSTART: u32 = 73;
pub const IBREAKENABLE: u32 = 96;
pub const MEMCTL: u32 = 97;
pub const ATOMCTL: u32 = 99;
pub const DDR: u32 = 104;
pub const IBREAKA_0: u32 = 128;
pub const IBREAKA_1: u32 = 129;
pub const DBREAKA_0: u32 = 144;
pub const DBREAKA_1: u32 = 145;
pub const DBREAKC_0: u32 = 160;
pub const DBREAKC_1: u32 = 161;
pub const EPC_1: u32 = 177;
pub const EPC_2: u32 = 178;
pub const EPC_3: u32 = 179;
pub const EPC_4: u32 = 180;
pub const EPC_5: u32 = 181;
pub const EPC_6: u32 = 182;
pub const EPC_7: u32 = 183;
pub const DEPC: u32 = 192;
pub const EPS_2: u32 = 194;
pub const EPS_3: u32 = 195;
pub const EPS_4: u32 = 196;
pub const EPS_5: u32 = 197;
pub const EPS_6: u32 = 198;
pub const EPS_7: u32 = 199;
pub const EXCSAVE_1: u32 = 209;
pub const EXCSAVE_2: u32 = 210;
pub const EXCSAVE_3: u32 = 211;
pub const EXCSAVE_4: u32 = 212;
pub const EXCSAVE_5: u32 = 213;
pub const EXCSAVE_6: u32 = 214;
pub const EXCSAVE_7: u32 = 215;
pub const CPENABLE: u32 = 224;
pub const INTERRUPT: u32 = 226;
pub const INTENABLE: u32 = 228;
pub const PS: u32 = 230;
pub const VECBASE: u32 = 231;
pub const EXCCAUSE: u32 = 232;
pub const DEBUGCAUSE: u32 = 233;
pub const CCOUNT: u32 = 234;
pub const PRID: u32 = 235;
pub const ICOUNT: u32 = 236;
pub const ICOUNTLEVEL: u32 = 237;
pub const EXCVADDR: u32 = 238;
pub const CCOMPARE_0: u32 = 240;
pub const CCOMPARE_1: u32 = 241;
pub const CCOMPARE_2: u32 = 242;
pub const MISC_REG_0: u32 = 244;
pub const MISC_REG_1: u32 = 245;
pub const MISC_REG_2: u32 = 246;
pub const MISC_REG_3: u32 = 247;
pub const MR: u32 = 32;
pub const IBREAKA: u32 = 128;
pub const DBREAKA: u32 = 144;
pub const DBREAKC: u32 = 160;
pub const EPC: u32 = 176;
pub const EPS: u32 = 192;
pub const EXCSAVE: u32 = 208;
pub const CCOMPARE: u32 = 240;
pub const INTREAD: u32 = 226;
pub const INTSET: u32 = 226;
pub const INTCLEAR: u32 = 227;
pub const CORE_STATE_SIGNATURE: u32 = 2982522861;
pub const XTOS_KEEPON_MEM: u32 = 256;
pub const XTOS_KEEPON_MEM_SHIFT: u32 = 8;
pub const XTOS_KEEPON_DEBUG: u32 = 4096;
pub const XTOS_KEEPON_DEBUG_SHIFT: u32 = 12;
pub const XTOS_COREF_PSO: u32 = 1;
pub const XTOS_COREF_PSO_SHIFT: u32 = 0;
pub const MALLOC_CAP_EXEC: u32 = 1;
pub const MALLOC_CAP_32BIT: u32 = 2;
pub const MALLOC_CAP_8BIT: u32 = 4;
pub const MALLOC_CAP_DMA: u32 = 8;
pub const MALLOC_CAP_PID2: u32 = 16;
pub const MALLOC_CAP_PID3: u32 = 32;
pub const MALLOC_CAP_PID4: u32 = 64;
pub const MALLOC_CAP_PID5: u32 = 128;
pub const MALLOC_CAP_PID6: u32 = 256;
pub const MALLOC_CAP_PID7: u32 = 512;
pub const MALLOC_CAP_SPIRAM: u32 = 1024;
pub const MALLOC_CAP_INTERNAL: u32 = 2048;
pub const MALLOC_CAP_DEFAULT: u32 = 4096;
pub const MALLOC_CAP_INVALID: u32 = 2147483648;
pub const portMUX_FREE_VAL: u32 = 3007315967;
pub const portMUX_NO_TIMEOUT: i32 = -1;
pub const portMUX_TRY_LOCK: u32 = 0;
pub const portCRITICAL_NESTING_IN_TCB: u32 = 1;
pub const portTcbMemoryCaps: u32 = 2052;
pub const portStackMemoryCaps: u32 = 2052;
pub const portSTACK_GROWTH: i32 = -1;
pub const portBYTE_ALIGNMENT: u32 = 4;
pub const portBYTE_ALIGNMENT_MASK: u32 = 3;
pub const portNUM_CONFIGURABLE_REGIONS: u32 = 1;
pub const INCLUDE_xTimerGetTimerDaemonTaskHandle: u32 = 0;
pub const INCLUDE_xQueueGetMutexHolder: u32 = 0;
pub const configUSE_APPLICATION_TASK_TAG: u32 = 0;
pub const configUSE_ALTERNATIVE_API: u32 = 0;
pub const INCLUDE_xTaskResumeFromISR: u32 = 1;
pub const INCLUDE_xEventGroupSetBitFromISR: u32 = 0;
pub const configASSERT_DEFINED: u32 = 1;
pub const INCLUDE_xTaskGetSchedulerState: u32 = 0;
pub const INCLUDE_xTaskGetCurrentTaskHandle: u32 = 0;
pub const configGENERATE_RUN_TIME_STATS: u32 = 0;
pub const configUSE_MALLOC_FAILED_HOOK: u32 = 0;
pub const configEXPECTED_IDLE_TIME_BEFORE_SLEEP: u32 = 2;
pub const configUSE_TIME_SLICING: u32 = 1;
pub const configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS: u32 = 0;
pub const configUSE_STATS_FORMATTING_FUNCTIONS: u32 = 0;
pub const configTASKLIST_INCLUDE_COREID: u32 = 0;
pub const configUSE_TRACE_FACILITY: u32 = 0;
pub const configUSE_PORT_OPTIMISED_TASK_SELECTION: u32 = 0;
pub const configUSE_TASK_NOTIFICATIONS: u32 = 1;
pub const portTICK_TYPE_IS_ATOMIC: u32 = 0;
pub const configENABLE_BACKWARD_COMPATIBILITY: u32 = 1;
pub const configESP32_PER_TASK_DATA: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 1;
pub const NL_ARGMAX: u32 = 32;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const ARG_MAX: u32 = 4096;
pub const PATH_MAX: u32 = 1024;
pub const tskKERNEL_VERSION_NUMBER: &'static [u8; 7usize] = b"V8.2.0\0";
pub const tskKERNEL_VERSION_MAJOR: u32 = 8;
pub const tskKERNEL_VERSION_MINOR: u32 = 2;
pub const tskKERNEL_VERSION_BUILD: u32 = 0;
pub const UART_FIFO_LEN: u32 = 128;
pub const UART_INTR_MASK: u32 = 511;
pub const UART_LINE_INV_MASK: u32 = 33030144;
pub const UART_BITRATE_MAX: u32 = 5000000;
pub const UART_PIN_NO_CHANGE: i32 = -1;
pub const UART_INVERSE_DISABLE: u32 = 0;
pub const GPIO_ID_PIN0: u32 = 0;
pub const GPIO_FUNC_IN_HIGH: u32 = 56;
pub const GPIO_FUNC_IN_LOW: u32 = 48;
pub const GPIO_PIN_COUNT: u32 = 40;
pub const SLP_OE_V: u32 = 1;
pub const SLP_OE_S: u32 = 0;
pub const SLP_SEL_V: u32 = 1;
pub const SLP_SEL_S: u32 = 1;
pub const SLP_PD_V: u32 = 1;
pub const SLP_PD_S: u32 = 2;
pub const SLP_PU_V: u32 = 1;
pub const SLP_PU_S: u32 = 3;
pub const SLP_IE_V: u32 = 1;
pub const SLP_IE_S: u32 = 4;
pub const SLP_DRV: u32 = 3;
pub const SLP_DRV_V: u32 = 3;
pub const SLP_DRV_S: u32 = 5;
pub const FUN_PD_V: u32 = 1;
pub const FUN_PD_S: u32 = 7;
pub const FUN_PU_V: u32 = 1;
pub const FUN_PU_S: u32 = 8;
pub const FUN_IE_V: u32 = 1;
pub const FUN_IE_S: u32 = 9;
pub const FUN_DRV: u32 = 3;
pub const FUN_DRV_V: u32 = 3;
pub const FUN_DRV_S: u32 = 10;
pub const MCU_SEL: u32 = 7;
pub const MCU_SEL_V: u32 = 7;
pub const MCU_SEL_S: u32 = 12;
pub const PIN_FUNC_GPIO: u32 = 2;
pub const PIN_CTRL: u32 = 1072992256;
pub const CLK_OUT3: u32 = 15;
pub const CLK_OUT3_V: u32 = 15;
pub const CLK_OUT3_S: u32 = 8;
pub const CLK_OUT3_M: u32 = 3840;
pub const CLK_OUT2: u32 = 15;
pub const CLK_OUT2_V: u32 = 15;
pub const CLK_OUT2_S: u32 = 4;
pub const CLK_OUT2_M: u32 = 240;
pub const CLK_OUT1: u32 = 15;
pub const CLK_OUT1_V: u32 = 15;
pub const CLK_OUT1_S: u32 = 0;
pub const CLK_OUT1_M: u32 = 15;
pub const PERIPHS_IO_MUX_GPIO0_U: u32 = 1072992324;
pub const IO_MUX_GPIO0_REG: u32 = 1072992324;
pub const FUNC_GPIO0_EMAC_TX_CLK: u32 = 5;
pub const FUNC_GPIO0_GPIO0: u32 = 2;
pub const FUNC_GPIO0_CLK_OUT1: u32 = 1;
pub const FUNC_GPIO0_GPIO0_0: u32 = 0;
pub const PERIPHS_IO_MUX_U0TXD_U: u32 = 1072992392;
pub const IO_MUX_GPIO1_REG: u32 = 1072992392;
pub const FUNC_U0TXD_EMAC_RXD2: u32 = 5;
pub const FUNC_U0TXD_GPIO1: u32 = 2;
pub const FUNC_U0TXD_CLK_OUT3: u32 = 1;
pub const FUNC_U0TXD_U0TXD: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO2_U: u32 = 1072992320;
pub const IO_MUX_GPIO2_REG: u32 = 1072992320;
pub const FUNC_GPIO2_SD_DATA0: u32 = 4;
pub const FUNC_GPIO2_HS2_DATA0: u32 = 3;
pub const FUNC_GPIO2_GPIO2: u32 = 2;
pub const FUNC_GPIO2_HSPIWP: u32 = 1;
pub const FUNC_GPIO2_GPIO2_0: u32 = 0;
pub const PERIPHS_IO_MUX_U0RXD_U: u32 = 1072992388;
pub const IO_MUX_GPIO3_REG: u32 = 1072992388;
pub const FUNC_U0RXD_GPIO3: u32 = 2;
pub const FUNC_U0RXD_CLK_OUT2: u32 = 1;
pub const FUNC_U0RXD_U0RXD: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO4_U: u32 = 1072992328;
pub const IO_MUX_GPIO4_REG: u32 = 1072992328;
pub const FUNC_GPIO4_EMAC_TX_ER: u32 = 5;
pub const FUNC_GPIO4_SD_DATA1: u32 = 4;
pub const FUNC_GPIO4_HS2_DATA1: u32 = 3;
pub const FUNC_GPIO4_GPIO4: u32 = 2;
pub const FUNC_GPIO4_HSPIHD: u32 = 1;
pub const FUNC_GPIO4_GPIO4_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO5_U: u32 = 1072992364;
pub const IO_MUX_GPIO5_REG: u32 = 1072992364;
pub const FUNC_GPIO5_EMAC_RX_CLK: u32 = 5;
pub const FUNC_GPIO5_HS1_DATA6: u32 = 3;
pub const FUNC_GPIO5_GPIO5: u32 = 2;
pub const FUNC_GPIO5_VSPICS0: u32 = 1;
pub const FUNC_GPIO5_GPIO5_0: u32 = 0;
pub const PERIPHS_IO_MUX_SD_CLK_U: u32 = 1072992352;
pub const IO_MUX_GPIO6_REG: u32 = 1072992352;
pub const FUNC_SD_CLK_U1CTS: u32 = 4;
pub const FUNC_SD_CLK_HS1_CLK: u32 = 3;
pub const FUNC_SD_CLK_GPIO6: u32 = 2;
pub const FUNC_SD_CLK_SPICLK: u32 = 1;
pub const FUNC_SD_CLK_SD_CLK: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA0_U: u32 = 1072992356;
pub const IO_MUX_GPIO7_REG: u32 = 1072992356;
pub const FUNC_SD_DATA0_U2RTS: u32 = 4;
pub const FUNC_SD_DATA0_HS1_DATA0: u32 = 3;
pub const FUNC_SD_DATA0_GPIO7: u32 = 2;
pub const FUNC_SD_DATA0_SPIQ: u32 = 1;
pub const FUNC_SD_DATA0_SD_DATA0: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA1_U: u32 = 1072992360;
pub const IO_MUX_GPIO8_REG: u32 = 1072992360;
pub const FUNC_SD_DATA1_U2CTS: u32 = 4;
pub const FUNC_SD_DATA1_HS1_DATA1: u32 = 3;
pub const FUNC_SD_DATA1_GPIO8: u32 = 2;
pub const FUNC_SD_DATA1_SPID: u32 = 1;
pub const FUNC_SD_DATA1_SD_DATA1: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA2_U: u32 = 1072992340;
pub const IO_MUX_GPIO9_REG: u32 = 1072992340;
pub const FUNC_SD_DATA2_U1RXD: u32 = 4;
pub const FUNC_SD_DATA2_HS1_DATA2: u32 = 3;
pub const FUNC_SD_DATA2_GPIO9: u32 = 2;
pub const FUNC_SD_DATA2_SPIHD: u32 = 1;
pub const FUNC_SD_DATA2_SD_DATA2: u32 = 0;
pub const PERIPHS_IO_MUX_SD_DATA3_U: u32 = 1072992344;
pub const IO_MUX_GPIO10_REG: u32 = 1072992344;
pub const FUNC_SD_DATA3_U1TXD: u32 = 4;
pub const FUNC_SD_DATA3_HS1_DATA3: u32 = 3;
pub const FUNC_SD_DATA3_GPIO10: u32 = 2;
pub const FUNC_SD_DATA3_SPIWP: u32 = 1;
pub const FUNC_SD_DATA3_SD_DATA3: u32 = 0;
pub const PERIPHS_IO_MUX_SD_CMD_U: u32 = 1072992348;
pub const IO_MUX_GPIO11_REG: u32 = 1072992348;
pub const FUNC_SD_CMD_U1RTS: u32 = 4;
pub const FUNC_SD_CMD_HS1_CMD: u32 = 3;
pub const FUNC_SD_CMD_GPIO11: u32 = 2;
pub const FUNC_SD_CMD_SPICS0: u32 = 1;
pub const FUNC_SD_CMD_SD_CMD: u32 = 0;
pub const PERIPHS_IO_MUX_MTDI_U: u32 = 1072992308;
pub const IO_MUX_GPIO12_REG: u32 = 1072992308;
pub const FUNC_MTDI_EMAC_TXD3: u32 = 5;
pub const FUNC_MTDI_SD_DATA2: u32 = 4;
pub const FUNC_MTDI_HS2_DATA2: u32 = 3;
pub const FUNC_MTDI_GPIO12: u32 = 2;
pub const FUNC_MTDI_HSPIQ: u32 = 1;
pub const FUNC_MTDI_MTDI: u32 = 0;
pub const PERIPHS_IO_MUX_MTCK_U: u32 = 1072992312;
pub const IO_MUX_GPIO13_REG: u32 = 1072992312;
pub const FUNC_MTCK_EMAC_RX_ER: u32 = 5;
pub const FUNC_MTCK_SD_DATA3: u32 = 4;
pub const FUNC_MTCK_HS2_DATA3: u32 = 3;
pub const FUNC_MTCK_GPIO13: u32 = 2;
pub const FUNC_MTCK_HSPID: u32 = 1;
pub const FUNC_MTCK_MTCK: u32 = 0;
pub const PERIPHS_IO_MUX_MTMS_U: u32 = 1072992304;
pub const IO_MUX_GPIO14_REG: u32 = 1072992304;
pub const FUNC_MTMS_EMAC_TXD2: u32 = 5;
pub const FUNC_MTMS_SD_CLK: u32 = 4;
pub const FUNC_MTMS_HS2_CLK: u32 = 3;
pub const FUNC_MTMS_GPIO14: u32 = 2;
pub const FUNC_MTMS_HSPICLK: u32 = 1;
pub const FUNC_MTMS_MTMS: u32 = 0;
pub const PERIPHS_IO_MUX_MTDO_U: u32 = 1072992316;
pub const IO_MUX_GPIO15_REG: u32 = 1072992316;
pub const FUNC_MTDO_EMAC_RXD3: u32 = 5;
pub const FUNC_MTDO_SD_CMD: u32 = 4;
pub const FUNC_MTDO_HS2_CMD: u32 = 3;
pub const FUNC_MTDO_GPIO15: u32 = 2;
pub const FUNC_MTDO_HSPICS0: u32 = 1;
pub const FUNC_MTDO_MTDO: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO16_U: u32 = 1072992332;
pub const IO_MUX_GPIO16_REG: u32 = 1072992332;
pub const FUNC_GPIO16_EMAC_CLK_OUT: u32 = 5;
pub const FUNC_GPIO16_U2RXD: u32 = 4;
pub const FUNC_GPIO16_HS1_DATA4: u32 = 3;
pub const FUNC_GPIO16_GPIO16: u32 = 2;
pub const FUNC_GPIO16_GPIO16_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO17_U: u32 = 1072992336;
pub const IO_MUX_GPIO17_REG: u32 = 1072992336;
pub const FUNC_GPIO17_EMAC_CLK_OUT_180: u32 = 5;
pub const FUNC_GPIO17_U2TXD: u32 = 4;
pub const FUNC_GPIO17_HS1_DATA5: u32 = 3;
pub const FUNC_GPIO17_GPIO17: u32 = 2;
pub const FUNC_GPIO17_GPIO17_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO18_U: u32 = 1072992368;
pub const IO_MUX_GPIO18_REG: u32 = 1072992368;
pub const FUNC_GPIO18_HS1_DATA7: u32 = 3;
pub const FUNC_GPIO18_GPIO18: u32 = 2;
pub const FUNC_GPIO18_VSPICLK: u32 = 1;
pub const FUNC_GPIO18_GPIO18_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO19_U: u32 = 1072992372;
pub const IO_MUX_GPIO19_REG: u32 = 1072992372;
pub const FUNC_GPIO19_EMAC_TXD0: u32 = 5;
pub const FUNC_GPIO19_U0CTS: u32 = 3;
pub const FUNC_GPIO19_GPIO19: u32 = 2;
pub const FUNC_GPIO19_VSPIQ: u32 = 1;
pub const FUNC_GPIO19_GPIO19_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO20_U: u32 = 1072992376;
pub const IO_MUX_GPIO20_REG: u32 = 1072992376;
pub const FUNC_GPIO20_GPIO20: u32 = 2;
pub const FUNC_GPIO20_GPIO20_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO21_U: u32 = 1072992380;
pub const IO_MUX_GPIO21_REG: u32 = 1072992380;
pub const FUNC_GPIO21_EMAC_TX_EN: u32 = 5;
pub const FUNC_GPIO21_GPIO21: u32 = 2;
pub const FUNC_GPIO21_VSPIHD: u32 = 1;
pub const FUNC_GPIO21_GPIO21_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO22_U: u32 = 1072992384;
pub const IO_MUX_GPIO22_REG: u32 = 1072992384;
pub const FUNC_GPIO22_EMAC_TXD1: u32 = 5;
pub const FUNC_GPIO22_U0RTS: u32 = 3;
pub const FUNC_GPIO22_GPIO22: u32 = 2;
pub const FUNC_GPIO22_VSPIWP: u32 = 1;
pub const FUNC_GPIO22_GPIO22_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO23_U: u32 = 1072992396;
pub const IO_MUX_GPIO23_REG: u32 = 1072992396;
pub const FUNC_GPIO23_HS1_STROBE: u32 = 3;
pub const FUNC_GPIO23_GPIO23: u32 = 2;
pub const FUNC_GPIO23_VSPID: u32 = 1;
pub const FUNC_GPIO23_GPIO23_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO24_U: u32 = 1072992400;
pub const IO_MUX_GPIO24_REG: u32 = 1072992400;
pub const FUNC_GPIO24_GPIO24: u32 = 2;
pub const FUNC_GPIO24_GPIO24_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO25_U: u32 = 1072992292;
pub const IO_MUX_GPIO25_REG: u32 = 1072992292;
pub const FUNC_GPIO25_EMAC_RXD0: u32 = 5;
pub const FUNC_GPIO25_GPIO25: u32 = 2;
pub const FUNC_GPIO25_GPIO25_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO26_U: u32 = 1072992296;
pub const IO_MUX_GPIO26_REG: u32 = 1072992296;
pub const FUNC_GPIO26_EMAC_RXD1: u32 = 5;
pub const FUNC_GPIO26_GPIO26: u32 = 2;
pub const FUNC_GPIO26_GPIO26_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO27_U: u32 = 1072992300;
pub const IO_MUX_GPIO27_REG: u32 = 1072992300;
pub const FUNC_GPIO27_EMAC_RX_DV: u32 = 5;
pub const FUNC_GPIO27_GPIO27: u32 = 2;
pub const FUNC_GPIO27_GPIO27_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO32_U: u32 = 1072992284;
pub const IO_MUX_GPIO32_REG: u32 = 1072992284;
pub const FUNC_GPIO32_GPIO32: u32 = 2;
pub const FUNC_GPIO32_GPIO32_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO33_U: u32 = 1072992288;
pub const IO_MUX_GPIO33_REG: u32 = 1072992288;
pub const FUNC_GPIO33_GPIO33: u32 = 2;
pub const FUNC_GPIO33_GPIO33_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO34_U: u32 = 1072992276;
pub const IO_MUX_GPIO34_REG: u32 = 1072992276;
pub const FUNC_GPIO34_GPIO34: u32 = 2;
pub const FUNC_GPIO34_GPIO34_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO35_U: u32 = 1072992280;
pub const IO_MUX_GPIO35_REG: u32 = 1072992280;
pub const FUNC_GPIO35_GPIO35: u32 = 2;
pub const FUNC_GPIO35_GPIO35_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO36_U: u32 = 1072992260;
pub const IO_MUX_GPIO36_REG: u32 = 1072992260;
pub const FUNC_GPIO36_GPIO36: u32 = 2;
pub const FUNC_GPIO36_GPIO36_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO37_U: u32 = 1072992264;
pub const IO_MUX_GPIO37_REG: u32 = 1072992264;
pub const FUNC_GPIO37_GPIO37: u32 = 2;
pub const FUNC_GPIO37_GPIO37_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO38_U: u32 = 1072992268;
pub const IO_MUX_GPIO38_REG: u32 = 1072992268;
pub const FUNC_GPIO38_GPIO38: u32 = 2;
pub const FUNC_GPIO38_GPIO38_0: u32 = 0;
pub const PERIPHS_IO_MUX_GPIO39_U: u32 = 1072992272;
pub const IO_MUX_GPIO39_REG: u32 = 1072992272;
pub const FUNC_GPIO39_GPIO39: u32 = 2;
pub const FUNC_GPIO39_GPIO39_0: u32 = 0;
pub const GPIO_BT_SELECT_REG: u32 = 1072971776;
pub const GPIO_BT_SEL: u32 = 4294967295;
pub const GPIO_BT_SEL_V: u32 = 4294967295;
pub const GPIO_BT_SEL_S: u32 = 0;
pub const GPIO_OUT_REG: u32 = 1072971780;
pub const GPIO_OUT_DATA: u32 = 4294967295;
pub const GPIO_OUT_DATA_V: u32 = 4294967295;
pub const GPIO_OUT_DATA_S: u32 = 0;
pub const GPIO_OUT_W1TS_REG: u32 = 1072971784;
pub const GPIO_OUT_DATA_W1TS: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TS_V: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TS_S: u32 = 0;
pub const GPIO_OUT_W1TC_REG: u32 = 1072971788;
pub const GPIO_OUT_DATA_W1TC: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TC_V: u32 = 4294967295;
pub const GPIO_OUT_DATA_W1TC_S: u32 = 0;
pub const GPIO_OUT1_REG: u32 = 1072971792;
pub const GPIO_OUT1_DATA: u32 = 255;
pub const GPIO_OUT1_DATA_V: u32 = 255;
pub const GPIO_OUT1_DATA_S: u32 = 0;
pub const GPIO_OUT1_W1TS_REG: u32 = 1072971796;
pub const GPIO_OUT1_DATA_W1TS: u32 = 255;
pub const GPIO_OUT1_DATA_W1TS_V: u32 = 255;
pub const GPIO_OUT1_DATA_W1TS_S: u32 = 0;
pub const GPIO_OUT1_W1TC_REG: u32 = 1072971800;
pub const GPIO_OUT1_DATA_W1TC: u32 = 255;
pub const GPIO_OUT1_DATA_W1TC_V: u32 = 255;
pub const GPIO_OUT1_DATA_W1TC_S: u32 = 0;
pub const GPIO_SDIO_SELECT_REG: u32 = 1072971804;
pub const GPIO_SDIO_SEL: u32 = 255;
pub const GPIO_SDIO_SEL_V: u32 = 255;
pub const GPIO_SDIO_SEL_S: u32 = 0;
pub const GPIO_ENABLE_REG: u32 = 1072971808;
pub const GPIO_ENABLE_DATA: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_V: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_S: u32 = 0;
pub const GPIO_ENABLE_W1TS_REG: u32 = 1072971812;
pub const GPIO_ENABLE_DATA_W1TS: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TS_V: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TS_S: u32 = 0;
pub const GPIO_ENABLE_W1TC_REG: u32 = 1072971816;
pub const GPIO_ENABLE_DATA_W1TC: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TC_V: u32 = 4294967295;
pub const GPIO_ENABLE_DATA_W1TC_S: u32 = 0;
pub const GPIO_ENABLE1_REG: u32 = 1072971820;
pub const GPIO_ENABLE1_DATA: u32 = 255;
pub const GPIO_ENABLE1_DATA_V: u32 = 255;
pub const GPIO_ENABLE1_DATA_S: u32 = 0;
pub const GPIO_ENABLE1_W1TS_REG: u32 = 1072971824;
pub const GPIO_ENABLE1_DATA_W1TS: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TS_V: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TS_S: u32 = 0;
pub const GPIO_ENABLE1_W1TC_REG: u32 = 1072971828;
pub const GPIO_ENABLE1_DATA_W1TC: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TC_V: u32 = 255;
pub const GPIO_ENABLE1_DATA_W1TC_S: u32 = 0;
pub const GPIO_STRAP_REG: u32 = 1072971832;
pub const GPIO_STRAPPING: u32 = 65535;
pub const GPIO_STRAPPING_V: u32 = 65535;
pub const GPIO_STRAPPING_S: u32 = 0;
pub const GPIO_IN_REG: u32 = 1072971836;
pub const GPIO_IN_DATA: u32 = 4294967295;
pub const GPIO_IN_DATA_V: u32 = 4294967295;
pub const GPIO_IN_DATA_S: u32 = 0;
pub const GPIO_IN1_REG: u32 = 1072971840;
pub const GPIO_IN1_DATA: u32 = 255;
pub const GPIO_IN1_DATA_V: u32 = 255;
pub const GPIO_IN1_DATA_S: u32 = 0;
pub const GPIO_STATUS_REG: u32 = 1072971844;
pub const GPIO_STATUS_INT: u32 = 4294967295;
pub const GPIO_STATUS_INT_V: u32 = 4294967295;
pub const GPIO_STATUS_INT_S: u32 = 0;
pub const GPIO_STATUS_W1TS_REG: u32 = 1072971848;
pub const GPIO_STATUS_INT_W1TS: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TS_V: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TS_S: u32 = 0;
pub const GPIO_STATUS_W1TC_REG: u32 = 1072971852;
pub const GPIO_STATUS_INT_W1TC: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TC_V: u32 = 4294967295;
pub const GPIO_STATUS_INT_W1TC_S: u32 = 0;
pub const GPIO_STATUS1_REG: u32 = 1072971856;
pub const GPIO_STATUS1_INT: u32 = 255;
pub const GPIO_STATUS1_INT_V: u32 = 255;
pub const GPIO_STATUS1_INT_S: u32 = 0;
pub const GPIO_STATUS1_W1TS_REG: u32 = 1072971860;
pub const GPIO_STATUS1_INT_W1TS: u32 = 255;
pub const GPIO_STATUS1_INT_W1TS_V: u32 = 255;
pub const GPIO_STATUS1_INT_W1TS_S: u32 = 0;
pub const GPIO_STATUS1_W1TC_REG: u32 = 1072971864;
pub const GPIO_STATUS1_INT_W1TC: u32 = 255;
pub const GPIO_STATUS1_INT_W1TC_V: u32 = 255;
pub const GPIO_STATUS1_INT_W1TC_S: u32 = 0;
pub const GPIO_ACPU_INT_REG: u32 = 1072971872;
pub const GPIO_APPCPU_INT: u32 = 4294967295;
pub const GPIO_APPCPU_INT_V: u32 = 4294967295;
pub const GPIO_APPCPU_INT_S: u32 = 0;
pub const GPIO_ACPU_NMI_INT_REG: u32 = 1072971876;
pub const GPIO_APPCPU_NMI_INT: u32 = 4294967295;
pub const GPIO_APPCPU_NMI_INT_V: u32 = 4294967295;
pub const GPIO_APPCPU_NMI_INT_S: u32 = 0;
pub const GPIO_PCPU_INT_REG: u32 = 1072971880;
pub const GPIO_PROCPU_INT: u32 = 4294967295;
pub const GPIO_PROCPU_INT_V: u32 = 4294967295;
pub const GPIO_PROCPU_INT_S: u32 = 0;
pub const GPIO_PCPU_NMI_INT_REG: u32 = 1072971884;
pub const GPIO_PROCPU_NMI_INT: u32 = 4294967295;
pub const GPIO_PROCPU_NMI_INT_V: u32 = 4294967295;
pub const GPIO_PROCPU_NMI_INT_S: u32 = 0;
pub const GPIO_CPUSDIO_INT_REG: u32 = 1072971888;
pub const GPIO_SDIO_INT: u32 = 4294967295;
pub const GPIO_SDIO_INT_V: u32 = 4294967295;
pub const GPIO_SDIO_INT_S: u32 = 0;
pub const GPIO_ACPU_INT1_REG: u32 = 1072971892;
pub const GPIO_APPCPU_INT_H: u32 = 255;
pub const GPIO_APPCPU_INT_H_V: u32 = 255;
pub const GPIO_APPCPU_INT_H_S: u32 = 0;
pub const GPIO_ACPU_NMI_INT1_REG: u32 = 1072971896;
pub const GPIO_APPCPU_NMI_INT_H: u32 = 255;
pub const GPIO_APPCPU_NMI_INT_H_V: u32 = 255;
pub const GPIO_APPCPU_NMI_INT_H_S: u32 = 0;
pub const GPIO_PCPU_INT1_REG: u32 = 1072971900;
pub const GPIO_PROCPU_INT_H: u32 = 255;
pub const GPIO_PROCPU_INT_H_V: u32 = 255;
pub const GPIO_PROCPU_INT_H_S: u32 = 0;
pub const GPIO_PCPU_NMI_INT1_REG: u32 = 1072971904;
pub const GPIO_PROCPU_NMI_INT_H: u32 = 255;
pub const GPIO_PROCPU_NMI_INT_H_V: u32 = 255;
pub const GPIO_PROCPU_NMI_INT_H_S: u32 = 0;
pub const GPIO_CPUSDIO_INT1_REG: u32 = 1072971908;
pub const GPIO_SDIO_INT_H: u32 = 255;
pub const GPIO_SDIO_INT_H_V: u32 = 255;
pub const GPIO_SDIO_INT_H_S: u32 = 0;
pub const GPIO_PIN_INT_ENA: u32 = 31;
pub const GPIO_PIN_INT_ENA_V: u32 = 31;
pub const GPIO_PIN_INT_ENA_S: u32 = 13;
pub const GPIO_PIN_CONFIG: u32 = 3;
pub const GPIO_PIN_CONFIG_V: u32 = 3;
pub const GPIO_PIN_CONFIG_S: u32 = 11;
pub const GPIO_PIN_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN_INT_TYPE: u32 = 7;
pub const GPIO_PIN_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN0_REG: u32 = 1072971912;
pub const GPIO_PIN0_INT_ENA: u32 = 31;
pub const GPIO_PIN0_INT_ENA_V: u32 = 31;
pub const GPIO_PIN0_INT_ENA_S: u32 = 13;
pub const GPIO_PIN0_CONFIG: u32 = 3;
pub const GPIO_PIN0_CONFIG_V: u32 = 3;
pub const GPIO_PIN0_CONFIG_S: u32 = 11;
pub const GPIO_PIN0_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN0_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN0_INT_TYPE: u32 = 7;
pub const GPIO_PIN0_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN0_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN0_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN0_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN1_REG: u32 = 1072971916;
pub const GPIO_PIN1_INT_ENA: u32 = 31;
pub const GPIO_PIN1_INT_ENA_V: u32 = 31;
pub const GPIO_PIN1_INT_ENA_S: u32 = 13;
pub const GPIO_PIN1_CONFIG: u32 = 3;
pub const GPIO_PIN1_CONFIG_V: u32 = 3;
pub const GPIO_PIN1_CONFIG_S: u32 = 11;
pub const GPIO_PIN1_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN1_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN1_INT_TYPE: u32 = 7;
pub const GPIO_PIN1_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN1_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN1_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN1_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN2_REG: u32 = 1072971920;
pub const GPIO_PIN2_INT_ENA: u32 = 31;
pub const GPIO_PIN2_INT_ENA_V: u32 = 31;
pub const GPIO_PIN2_INT_ENA_S: u32 = 13;
pub const GPIO_PIN2_CONFIG: u32 = 3;
pub const GPIO_PIN2_CONFIG_V: u32 = 3;
pub const GPIO_PIN2_CONFIG_S: u32 = 11;
pub const GPIO_PIN2_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN2_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN2_INT_TYPE: u32 = 7;
pub const GPIO_PIN2_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN2_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN2_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN2_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN3_REG: u32 = 1072971924;
pub const GPIO_PIN3_INT_ENA: u32 = 31;
pub const GPIO_PIN3_INT_ENA_V: u32 = 31;
pub const GPIO_PIN3_INT_ENA_S: u32 = 13;
pub const GPIO_PIN3_CONFIG: u32 = 3;
pub const GPIO_PIN3_CONFIG_V: u32 = 3;
pub const GPIO_PIN3_CONFIG_S: u32 = 11;
pub const GPIO_PIN3_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN3_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN3_INT_TYPE: u32 = 7;
pub const GPIO_PIN3_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN3_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN3_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN3_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN4_REG: u32 = 1072971928;
pub const GPIO_PIN4_INT_ENA: u32 = 31;
pub const GPIO_PIN4_INT_ENA_V: u32 = 31;
pub const GPIO_PIN4_INT_ENA_S: u32 = 13;
pub const GPIO_PIN4_CONFIG: u32 = 3;
pub const GPIO_PIN4_CONFIG_V: u32 = 3;
pub const GPIO_PIN4_CONFIG_S: u32 = 11;
pub const GPIO_PIN4_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN4_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN4_INT_TYPE: u32 = 7;
pub const GPIO_PIN4_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN4_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN4_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN4_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN5_REG: u32 = 1072971932;
pub const GPIO_PIN5_INT_ENA: u32 = 31;
pub const GPIO_PIN5_INT_ENA_V: u32 = 31;
pub const GPIO_PIN5_INT_ENA_S: u32 = 13;
pub const GPIO_PIN5_CONFIG: u32 = 3;
pub const GPIO_PIN5_CONFIG_V: u32 = 3;
pub const GPIO_PIN5_CONFIG_S: u32 = 11;
pub const GPIO_PIN5_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN5_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN5_INT_TYPE: u32 = 7;
pub const GPIO_PIN5_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN5_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN5_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN5_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN6_REG: u32 = 1072971936;
pub const GPIO_PIN6_INT_ENA: u32 = 31;
pub const GPIO_PIN6_INT_ENA_V: u32 = 31;
pub const GPIO_PIN6_INT_ENA_S: u32 = 13;
pub const GPIO_PIN6_CONFIG: u32 = 3;
pub const GPIO_PIN6_CONFIG_V: u32 = 3;
pub const GPIO_PIN6_CONFIG_S: u32 = 11;
pub const GPIO_PIN6_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN6_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN6_INT_TYPE: u32 = 7;
pub const GPIO_PIN6_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN6_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN6_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN6_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN7_REG: u32 = 1072971940;
pub const GPIO_PIN7_INT_ENA: u32 = 31;
pub const GPIO_PIN7_INT_ENA_V: u32 = 31;
pub const GPIO_PIN7_INT_ENA_S: u32 = 13;
pub const GPIO_PIN7_CONFIG: u32 = 3;
pub const GPIO_PIN7_CONFIG_V: u32 = 3;
pub const GPIO_PIN7_CONFIG_S: u32 = 11;
pub const GPIO_PIN7_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN7_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN7_INT_TYPE: u32 = 7;
pub const GPIO_PIN7_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN7_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN7_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN7_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN8_REG: u32 = 1072971944;
pub const GPIO_PIN8_INT_ENA: u32 = 31;
pub const GPIO_PIN8_INT_ENA_V: u32 = 31;
pub const GPIO_PIN8_INT_ENA_S: u32 = 13;
pub const GPIO_PIN8_CONFIG: u32 = 3;
pub const GPIO_PIN8_CONFIG_V: u32 = 3;
pub const GPIO_PIN8_CONFIG_S: u32 = 11;
pub const GPIO_PIN8_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN8_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN8_INT_TYPE: u32 = 7;
pub const GPIO_PIN8_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN8_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN8_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN8_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN9_REG: u32 = 1072971948;
pub const GPIO_PIN9_INT_ENA: u32 = 31;
pub const GPIO_PIN9_INT_ENA_V: u32 = 31;
pub const GPIO_PIN9_INT_ENA_S: u32 = 13;
pub const GPIO_PIN9_CONFIG: u32 = 3;
pub const GPIO_PIN9_CONFIG_V: u32 = 3;
pub const GPIO_PIN9_CONFIG_S: u32 = 11;
pub const GPIO_PIN9_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN9_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN9_INT_TYPE: u32 = 7;
pub const GPIO_PIN9_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN9_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN9_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN9_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN10_REG: u32 = 1072971952;
pub const GPIO_PIN10_INT_ENA: u32 = 31;
pub const GPIO_PIN10_INT_ENA_V: u32 = 31;
pub const GPIO_PIN10_INT_ENA_S: u32 = 13;
pub const GPIO_PIN10_CONFIG: u32 = 3;
pub const GPIO_PIN10_CONFIG_V: u32 = 3;
pub const GPIO_PIN10_CONFIG_S: u32 = 11;
pub const GPIO_PIN10_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN10_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN10_INT_TYPE: u32 = 7;
pub const GPIO_PIN10_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN10_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN10_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN10_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN11_REG: u32 = 1072971956;
pub const GPIO_PIN11_INT_ENA: u32 = 31;
pub const GPIO_PIN11_INT_ENA_V: u32 = 31;
pub const GPIO_PIN11_INT_ENA_S: u32 = 13;
pub const GPIO_PIN11_CONFIG: u32 = 3;
pub const GPIO_PIN11_CONFIG_V: u32 = 3;
pub const GPIO_PIN11_CONFIG_S: u32 = 11;
pub const GPIO_PIN11_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN11_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN11_INT_TYPE: u32 = 7;
pub const GPIO_PIN11_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN11_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN11_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN11_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN12_REG: u32 = 1072971960;
pub const GPIO_PIN12_INT_ENA: u32 = 31;
pub const GPIO_PIN12_INT_ENA_V: u32 = 31;
pub const GPIO_PIN12_INT_ENA_S: u32 = 13;
pub const GPIO_PIN12_CONFIG: u32 = 3;
pub const GPIO_PIN12_CONFIG_V: u32 = 3;
pub const GPIO_PIN12_CONFIG_S: u32 = 11;
pub const GPIO_PIN12_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN12_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN12_INT_TYPE: u32 = 7;
pub const GPIO_PIN12_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN12_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN12_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN12_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN13_REG: u32 = 1072971964;
pub const GPIO_PIN13_INT_ENA: u32 = 31;
pub const GPIO_PIN13_INT_ENA_V: u32 = 31;
pub const GPIO_PIN13_INT_ENA_S: u32 = 13;
pub const GPIO_PIN13_CONFIG: u32 = 3;
pub const GPIO_PIN13_CONFIG_V: u32 = 3;
pub const GPIO_PIN13_CONFIG_S: u32 = 11;
pub const GPIO_PIN13_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN13_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN13_INT_TYPE: u32 = 7;
pub const GPIO_PIN13_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN13_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN13_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN13_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN14_REG: u32 = 1072971968;
pub const GPIO_PIN14_INT_ENA: u32 = 31;
pub const GPIO_PIN14_INT_ENA_V: u32 = 31;
pub const GPIO_PIN14_INT_ENA_S: u32 = 13;
pub const GPIO_PIN14_CONFIG: u32 = 3;
pub const GPIO_PIN14_CONFIG_V: u32 = 3;
pub const GPIO_PIN14_CONFIG_S: u32 = 11;
pub const GPIO_PIN14_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN14_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN14_INT_TYPE: u32 = 7;
pub const GPIO_PIN14_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN14_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN14_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN14_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN15_REG: u32 = 1072971972;
pub const GPIO_PIN15_INT_ENA: u32 = 31;
pub const GPIO_PIN15_INT_ENA_V: u32 = 31;
pub const GPIO_PIN15_INT_ENA_S: u32 = 13;
pub const GPIO_PIN15_CONFIG: u32 = 3;
pub const GPIO_PIN15_CONFIG_V: u32 = 3;
pub const GPIO_PIN15_CONFIG_S: u32 = 11;
pub const GPIO_PIN15_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN15_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN15_INT_TYPE: u32 = 7;
pub const GPIO_PIN15_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN15_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN15_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN15_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN16_REG: u32 = 1072971976;
pub const GPIO_PIN16_INT_ENA: u32 = 31;
pub const GPIO_PIN16_INT_ENA_V: u32 = 31;
pub const GPIO_PIN16_INT_ENA_S: u32 = 13;
pub const GPIO_PIN16_CONFIG: u32 = 3;
pub const GPIO_PIN16_CONFIG_V: u32 = 3;
pub const GPIO_PIN16_CONFIG_S: u32 = 11;
pub const GPIO_PIN16_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN16_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN16_INT_TYPE: u32 = 7;
pub const GPIO_PIN16_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN16_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN16_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN16_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN17_REG: u32 = 1072971980;
pub const GPIO_PIN17_INT_ENA: u32 = 31;
pub const GPIO_PIN17_INT_ENA_V: u32 = 31;
pub const GPIO_PIN17_INT_ENA_S: u32 = 13;
pub const GPIO_PIN17_CONFIG: u32 = 3;
pub const GPIO_PIN17_CONFIG_V: u32 = 3;
pub const GPIO_PIN17_CONFIG_S: u32 = 11;
pub const GPIO_PIN17_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN17_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN17_INT_TYPE: u32 = 7;
pub const GPIO_PIN17_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN17_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN17_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN17_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN18_REG: u32 = 1072971984;
pub const GPIO_PIN18_INT_ENA: u32 = 31;
pub const GPIO_PIN18_INT_ENA_V: u32 = 31;
pub const GPIO_PIN18_INT_ENA_S: u32 = 13;
pub const GPIO_PIN18_CONFIG: u32 = 3;
pub const GPIO_PIN18_CONFIG_V: u32 = 3;
pub const GPIO_PIN18_CONFIG_S: u32 = 11;
pub const GPIO_PIN18_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN18_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN18_INT_TYPE: u32 = 7;
pub const GPIO_PIN18_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN18_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN18_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN18_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN19_REG: u32 = 1072971988;
pub const GPIO_PIN19_INT_ENA: u32 = 31;
pub const GPIO_PIN19_INT_ENA_V: u32 = 31;
pub const GPIO_PIN19_INT_ENA_S: u32 = 13;
pub const GPIO_PIN19_CONFIG: u32 = 3;
pub const GPIO_PIN19_CONFIG_V: u32 = 3;
pub const GPIO_PIN19_CONFIG_S: u32 = 11;
pub const GPIO_PIN19_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN19_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN19_INT_TYPE: u32 = 7;
pub const GPIO_PIN19_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN19_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN19_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN19_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN20_REG: u32 = 1072971992;
pub const GPIO_PIN20_INT_ENA: u32 = 31;
pub const GPIO_PIN20_INT_ENA_V: u32 = 31;
pub const GPIO_PIN20_INT_ENA_S: u32 = 13;
pub const GPIO_PIN20_CONFIG: u32 = 3;
pub const GPIO_PIN20_CONFIG_V: u32 = 3;
pub const GPIO_PIN20_CONFIG_S: u32 = 11;
pub const GPIO_PIN20_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN20_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN20_INT_TYPE: u32 = 7;
pub const GPIO_PIN20_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN20_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN20_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN20_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN21_REG: u32 = 1072971996;
pub const GPIO_PIN21_INT_ENA: u32 = 31;
pub const GPIO_PIN21_INT_ENA_V: u32 = 31;
pub const GPIO_PIN21_INT_ENA_S: u32 = 13;
pub const GPIO_PIN21_CONFIG: u32 = 3;
pub const GPIO_PIN21_CONFIG_V: u32 = 3;
pub const GPIO_PIN21_CONFIG_S: u32 = 11;
pub const GPIO_PIN21_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN21_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN21_INT_TYPE: u32 = 7;
pub const GPIO_PIN21_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN21_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN21_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN21_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN22_REG: u32 = 1072972000;
pub const GPIO_PIN22_INT_ENA: u32 = 31;
pub const GPIO_PIN22_INT_ENA_V: u32 = 31;
pub const GPIO_PIN22_INT_ENA_S: u32 = 13;
pub const GPIO_PIN22_CONFIG: u32 = 3;
pub const GPIO_PIN22_CONFIG_V: u32 = 3;
pub const GPIO_PIN22_CONFIG_S: u32 = 11;
pub const GPIO_PIN22_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN22_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN22_INT_TYPE: u32 = 7;
pub const GPIO_PIN22_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN22_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN22_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN22_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN23_REG: u32 = 1072972004;
pub const GPIO_PIN23_INT_ENA: u32 = 31;
pub const GPIO_PIN23_INT_ENA_V: u32 = 31;
pub const GPIO_PIN23_INT_ENA_S: u32 = 13;
pub const GPIO_PIN23_CONFIG: u32 = 3;
pub const GPIO_PIN23_CONFIG_V: u32 = 3;
pub const GPIO_PIN23_CONFIG_S: u32 = 11;
pub const GPIO_PIN23_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN23_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN23_INT_TYPE: u32 = 7;
pub const GPIO_PIN23_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN23_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN23_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN23_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN24_REG: u32 = 1072972008;
pub const GPIO_PIN24_INT_ENA: u32 = 31;
pub const GPIO_PIN24_INT_ENA_V: u32 = 31;
pub const GPIO_PIN24_INT_ENA_S: u32 = 13;
pub const GPIO_PIN24_CONFIG: u32 = 3;
pub const GPIO_PIN24_CONFIG_V: u32 = 3;
pub const GPIO_PIN24_CONFIG_S: u32 = 11;
pub const GPIO_PIN24_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN24_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN24_INT_TYPE: u32 = 7;
pub const GPIO_PIN24_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN24_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN24_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN24_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN25_REG: u32 = 1072972012;
pub const GPIO_PIN25_INT_ENA: u32 = 31;
pub const GPIO_PIN25_INT_ENA_V: u32 = 31;
pub const GPIO_PIN25_INT_ENA_S: u32 = 13;
pub const GPIO_PIN25_CONFIG: u32 = 3;
pub const GPIO_PIN25_CONFIG_V: u32 = 3;
pub const GPIO_PIN25_CONFIG_S: u32 = 11;
pub const GPIO_PIN25_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN25_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN25_INT_TYPE: u32 = 7;
pub const GPIO_PIN25_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN25_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN25_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN25_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN26_REG: u32 = 1072972016;
pub const GPIO_PIN26_INT_ENA: u32 = 31;
pub const GPIO_PIN26_INT_ENA_V: u32 = 31;
pub const GPIO_PIN26_INT_ENA_S: u32 = 13;
pub const GPIO_PIN26_CONFIG: u32 = 3;
pub const GPIO_PIN26_CONFIG_V: u32 = 3;
pub const GPIO_PIN26_CONFIG_S: u32 = 11;
pub const GPIO_PIN26_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN26_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN26_INT_TYPE: u32 = 7;
pub const GPIO_PIN26_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN26_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN26_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN26_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN27_REG: u32 = 1072972020;
pub const GPIO_PIN27_INT_ENA: u32 = 31;
pub const GPIO_PIN27_INT_ENA_V: u32 = 31;
pub const GPIO_PIN27_INT_ENA_S: u32 = 13;
pub const GPIO_PIN27_CONFIG: u32 = 3;
pub const GPIO_PIN27_CONFIG_V: u32 = 3;
pub const GPIO_PIN27_CONFIG_S: u32 = 11;
pub const GPIO_PIN27_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN27_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN27_INT_TYPE: u32 = 7;
pub const GPIO_PIN27_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN27_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN27_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN27_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN28_REG: u32 = 1072972024;
pub const GPIO_PIN28_INT_ENA: u32 = 31;
pub const GPIO_PIN28_INT_ENA_V: u32 = 31;
pub const GPIO_PIN28_INT_ENA_S: u32 = 13;
pub const GPIO_PIN28_CONFIG: u32 = 3;
pub const GPIO_PIN28_CONFIG_V: u32 = 3;
pub const GPIO_PIN28_CONFIG_S: u32 = 11;
pub const GPIO_PIN28_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN28_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN28_INT_TYPE: u32 = 7;
pub const GPIO_PIN28_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN28_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN28_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN28_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN29_REG: u32 = 1072972028;
pub const GPIO_PIN29_INT_ENA: u32 = 31;
pub const GPIO_PIN29_INT_ENA_V: u32 = 31;
pub const GPIO_PIN29_INT_ENA_S: u32 = 13;
pub const GPIO_PIN29_CONFIG: u32 = 3;
pub const GPIO_PIN29_CONFIG_V: u32 = 3;
pub const GPIO_PIN29_CONFIG_S: u32 = 11;
pub const GPIO_PIN29_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN29_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN29_INT_TYPE: u32 = 7;
pub const GPIO_PIN29_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN29_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN29_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN29_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN30_REG: u32 = 1072972032;
pub const GPIO_PIN30_INT_ENA: u32 = 31;
pub const GPIO_PIN30_INT_ENA_V: u32 = 31;
pub const GPIO_PIN30_INT_ENA_S: u32 = 13;
pub const GPIO_PIN30_CONFIG: u32 = 3;
pub const GPIO_PIN30_CONFIG_V: u32 = 3;
pub const GPIO_PIN30_CONFIG_S: u32 = 11;
pub const GPIO_PIN30_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN30_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN30_INT_TYPE: u32 = 7;
pub const GPIO_PIN30_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN30_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN30_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN30_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN31_REG: u32 = 1072972036;
pub const GPIO_PIN31_INT_ENA: u32 = 31;
pub const GPIO_PIN31_INT_ENA_V: u32 = 31;
pub const GPIO_PIN31_INT_ENA_S: u32 = 13;
pub const GPIO_PIN31_CONFIG: u32 = 3;
pub const GPIO_PIN31_CONFIG_V: u32 = 3;
pub const GPIO_PIN31_CONFIG_S: u32 = 11;
pub const GPIO_PIN31_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN31_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN31_INT_TYPE: u32 = 7;
pub const GPIO_PIN31_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN31_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN31_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN31_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN32_REG: u32 = 1072972040;
pub const GPIO_PIN32_INT_ENA: u32 = 31;
pub const GPIO_PIN32_INT_ENA_V: u32 = 31;
pub const GPIO_PIN32_INT_ENA_S: u32 = 13;
pub const GPIO_PIN32_CONFIG: u32 = 3;
pub const GPIO_PIN32_CONFIG_V: u32 = 3;
pub const GPIO_PIN32_CONFIG_S: u32 = 11;
pub const GPIO_PIN32_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN32_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN32_INT_TYPE: u32 = 7;
pub const GPIO_PIN32_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN32_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN32_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN32_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN33_REG: u32 = 1072972044;
pub const GPIO_PIN33_INT_ENA: u32 = 31;
pub const GPIO_PIN33_INT_ENA_V: u32 = 31;
pub const GPIO_PIN33_INT_ENA_S: u32 = 13;
pub const GPIO_PIN33_CONFIG: u32 = 3;
pub const GPIO_PIN33_CONFIG_V: u32 = 3;
pub const GPIO_PIN33_CONFIG_S: u32 = 11;
pub const GPIO_PIN33_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN33_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN33_INT_TYPE: u32 = 7;
pub const GPIO_PIN33_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN33_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN33_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN33_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN34_REG: u32 = 1072972048;
pub const GPIO_PIN34_INT_ENA: u32 = 31;
pub const GPIO_PIN34_INT_ENA_V: u32 = 31;
pub const GPIO_PIN34_INT_ENA_S: u32 = 13;
pub const GPIO_PIN34_CONFIG: u32 = 3;
pub const GPIO_PIN34_CONFIG_V: u32 = 3;
pub const GPIO_PIN34_CONFIG_S: u32 = 11;
pub const GPIO_PIN34_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN34_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN34_INT_TYPE: u32 = 7;
pub const GPIO_PIN34_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN34_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN34_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN34_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN35_REG: u32 = 1072972052;
pub const GPIO_PIN35_INT_ENA: u32 = 31;
pub const GPIO_PIN35_INT_ENA_V: u32 = 31;
pub const GPIO_PIN35_INT_ENA_S: u32 = 13;
pub const GPIO_PIN35_CONFIG: u32 = 3;
pub const GPIO_PIN35_CONFIG_V: u32 = 3;
pub const GPIO_PIN35_CONFIG_S: u32 = 11;
pub const GPIO_PIN35_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN35_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN35_INT_TYPE: u32 = 7;
pub const GPIO_PIN35_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN35_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN35_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN35_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN36_REG: u32 = 1072972056;
pub const GPIO_PIN36_INT_ENA: u32 = 31;
pub const GPIO_PIN36_INT_ENA_V: u32 = 31;
pub const GPIO_PIN36_INT_ENA_S: u32 = 13;
pub const GPIO_PIN36_CONFIG: u32 = 3;
pub const GPIO_PIN36_CONFIG_V: u32 = 3;
pub const GPIO_PIN36_CONFIG_S: u32 = 11;
pub const GPIO_PIN36_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN36_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN36_INT_TYPE: u32 = 7;
pub const GPIO_PIN36_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN36_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN36_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN36_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN37_REG: u32 = 1072972060;
pub const GPIO_PIN37_INT_ENA: u32 = 31;
pub const GPIO_PIN37_INT_ENA_V: u32 = 31;
pub const GPIO_PIN37_INT_ENA_S: u32 = 13;
pub const GPIO_PIN37_CONFIG: u32 = 3;
pub const GPIO_PIN37_CONFIG_V: u32 = 3;
pub const GPIO_PIN37_CONFIG_S: u32 = 11;
pub const GPIO_PIN37_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN37_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN37_INT_TYPE: u32 = 7;
pub const GPIO_PIN37_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN37_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN37_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN37_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN38_REG: u32 = 1072972064;
pub const GPIO_PIN38_INT_ENA: u32 = 31;
pub const GPIO_PIN38_INT_ENA_V: u32 = 31;
pub const GPIO_PIN38_INT_ENA_S: u32 = 13;
pub const GPIO_PIN38_CONFIG: u32 = 3;
pub const GPIO_PIN38_CONFIG_V: u32 = 3;
pub const GPIO_PIN38_CONFIG_S: u32 = 11;
pub const GPIO_PIN38_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN38_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN38_INT_TYPE: u32 = 7;
pub const GPIO_PIN38_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN38_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN38_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN38_PAD_DRIVER_S: u32 = 2;
pub const GPIO_PIN39_REG: u32 = 1072972068;
pub const GPIO_PIN39_INT_ENA: u32 = 31;
pub const GPIO_PIN39_INT_ENA_V: u32 = 31;
pub const GPIO_PIN39_INT_ENA_S: u32 = 13;
pub const GPIO_PIN39_CONFIG: u32 = 3;
pub const GPIO_PIN39_CONFIG_V: u32 = 3;
pub const GPIO_PIN39_CONFIG_S: u32 = 11;
pub const GPIO_PIN39_WAKEUP_ENABLE_V: u32 = 1;
pub const GPIO_PIN39_WAKEUP_ENABLE_S: u32 = 10;
pub const GPIO_PIN39_INT_TYPE: u32 = 7;
pub const GPIO_PIN39_INT_TYPE_V: u32 = 7;
pub const GPIO_PIN39_INT_TYPE_S: u32 = 7;
pub const GPIO_PIN39_PAD_DRIVER_V: u32 = 1;
pub const GPIO_PIN39_PAD_DRIVER_S: u32 = 2;
pub const GPIO_cali_conf_REG: u32 = 1072972072;
pub const GPIO_CALI_START_V: u32 = 1;
pub const GPIO_CALI_START_S: u32 = 31;
pub const GPIO_CALI_RTC_MAX: u32 = 1023;
pub const GPIO_CALI_RTC_MAX_V: u32 = 1023;
pub const GPIO_CALI_RTC_MAX_S: u32 = 0;
pub const GPIO_cali_data_REG: u32 = 1072972076;
pub const GPIO_CALI_RDY_SYNC2_V: u32 = 1;
pub const GPIO_CALI_RDY_SYNC2_S: u32 = 31;
pub const GPIO_CALI_RDY_REAL_V: u32 = 1;
pub const GPIO_CALI_RDY_REAL_S: u32 = 30;
pub const GPIO_CALI_VALUE_SYNC2: u32 = 1048575;
pub const GPIO_CALI_VALUE_SYNC2_V: u32 = 1048575;
pub const GPIO_CALI_VALUE_SYNC2_S: u32 = 0;
pub const GPIO_FUNC0_IN_SEL_CFG_REG: u32 = 1072972080;
pub const GPIO_SIG0_IN_SEL_V: u32 = 1;
pub const GPIO_SIG0_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC0_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC0_IN_SEL: u32 = 63;
pub const GPIO_FUNC0_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC0_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC1_IN_SEL_CFG_REG: u32 = 1072972084;
pub const GPIO_SIG1_IN_SEL_V: u32 = 1;
pub const GPIO_SIG1_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC1_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC1_IN_SEL: u32 = 63;
pub const GPIO_FUNC1_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC1_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC2_IN_SEL_CFG_REG: u32 = 1072972088;
pub const GPIO_SIG2_IN_SEL_V: u32 = 1;
pub const GPIO_SIG2_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC2_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC2_IN_SEL: u32 = 63;
pub const GPIO_FUNC2_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC2_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC3_IN_SEL_CFG_REG: u32 = 1072972092;
pub const GPIO_SIG3_IN_SEL_V: u32 = 1;
pub const GPIO_SIG3_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC3_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC3_IN_SEL: u32 = 63;
pub const GPIO_FUNC3_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC3_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC4_IN_SEL_CFG_REG: u32 = 1072972096;
pub const GPIO_SIG4_IN_SEL_V: u32 = 1;
pub const GPIO_SIG4_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC4_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC4_IN_SEL: u32 = 63;
pub const GPIO_FUNC4_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC4_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC5_IN_SEL_CFG_REG: u32 = 1072972100;
pub const GPIO_SIG5_IN_SEL_V: u32 = 1;
pub const GPIO_SIG5_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC5_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC5_IN_SEL: u32 = 63;
pub const GPIO_FUNC5_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC5_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC6_IN_SEL_CFG_REG: u32 = 1072972104;
pub const GPIO_SIG6_IN_SEL_V: u32 = 1;
pub const GPIO_SIG6_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC6_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC6_IN_SEL: u32 = 63;
pub const GPIO_FUNC6_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC6_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC7_IN_SEL_CFG_REG: u32 = 1072972108;
pub const GPIO_SIG7_IN_SEL_V: u32 = 1;
pub const GPIO_SIG7_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC7_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC7_IN_SEL: u32 = 63;
pub const GPIO_FUNC7_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC7_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC8_IN_SEL_CFG_REG: u32 = 1072972112;
pub const GPIO_SIG8_IN_SEL_V: u32 = 1;
pub const GPIO_SIG8_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC8_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC8_IN_SEL: u32 = 63;
pub const GPIO_FUNC8_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC8_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC9_IN_SEL_CFG_REG: u32 = 1072972116;
pub const GPIO_SIG9_IN_SEL_V: u32 = 1;
pub const GPIO_SIG9_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC9_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC9_IN_SEL: u32 = 63;
pub const GPIO_FUNC9_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC9_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC10_IN_SEL_CFG_REG: u32 = 1072972120;
pub const GPIO_SIG10_IN_SEL_V: u32 = 1;
pub const GPIO_SIG10_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC10_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC10_IN_SEL: u32 = 63;
pub const GPIO_FUNC10_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC10_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC11_IN_SEL_CFG_REG: u32 = 1072972124;
pub const GPIO_SIG11_IN_SEL_V: u32 = 1;
pub const GPIO_SIG11_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC11_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC11_IN_SEL: u32 = 63;
pub const GPIO_FUNC11_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC11_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC12_IN_SEL_CFG_REG: u32 = 1072972128;
pub const GPIO_SIG12_IN_SEL_V: u32 = 1;
pub const GPIO_SIG12_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC12_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC12_IN_SEL: u32 = 63;
pub const GPIO_FUNC12_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC12_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC13_IN_SEL_CFG_REG: u32 = 1072972132;
pub const GPIO_SIG13_IN_SEL_V: u32 = 1;
pub const GPIO_SIG13_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC13_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC13_IN_SEL: u32 = 63;
pub const GPIO_FUNC13_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC13_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC14_IN_SEL_CFG_REG: u32 = 1072972136;
pub const GPIO_SIG14_IN_SEL_V: u32 = 1;
pub const GPIO_SIG14_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC14_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC14_IN_SEL: u32 = 63;
pub const GPIO_FUNC14_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC14_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC15_IN_SEL_CFG_REG: u32 = 1072972140;
pub const GPIO_SIG15_IN_SEL_V: u32 = 1;
pub const GPIO_SIG15_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC15_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC15_IN_SEL: u32 = 63;
pub const GPIO_FUNC15_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC15_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC16_IN_SEL_CFG_REG: u32 = 1072972144;
pub const GPIO_SIG16_IN_SEL_V: u32 = 1;
pub const GPIO_SIG16_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC16_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC16_IN_SEL: u32 = 63;
pub const GPIO_FUNC16_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC16_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC17_IN_SEL_CFG_REG: u32 = 1072972148;
pub const GPIO_SIG17_IN_SEL_V: u32 = 1;
pub const GPIO_SIG17_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC17_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC17_IN_SEL: u32 = 63;
pub const GPIO_FUNC17_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC17_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC18_IN_SEL_CFG_REG: u32 = 1072972152;
pub const GPIO_SIG18_IN_SEL_V: u32 = 1;
pub const GPIO_SIG18_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC18_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC18_IN_SEL: u32 = 63;
pub const GPIO_FUNC18_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC18_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC19_IN_SEL_CFG_REG: u32 = 1072972156;
pub const GPIO_SIG19_IN_SEL_V: u32 = 1;
pub const GPIO_SIG19_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC19_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC19_IN_SEL: u32 = 63;
pub const GPIO_FUNC19_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC19_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC20_IN_SEL_CFG_REG: u32 = 1072972160;
pub const GPIO_SIG20_IN_SEL_V: u32 = 1;
pub const GPIO_SIG20_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC20_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC20_IN_SEL: u32 = 63;
pub const GPIO_FUNC20_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC20_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC21_IN_SEL_CFG_REG: u32 = 1072972164;
pub const GPIO_SIG21_IN_SEL_V: u32 = 1;
pub const GPIO_SIG21_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC21_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC21_IN_SEL: u32 = 63;
pub const GPIO_FUNC21_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC21_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC22_IN_SEL_CFG_REG: u32 = 1072972168;
pub const GPIO_SIG22_IN_SEL_V: u32 = 1;
pub const GPIO_SIG22_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC22_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC22_IN_SEL: u32 = 63;
pub const GPIO_FUNC22_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC22_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC23_IN_SEL_CFG_REG: u32 = 1072972172;
pub const GPIO_SIG23_IN_SEL_V: u32 = 1;
pub const GPIO_SIG23_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC23_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC23_IN_SEL: u32 = 63;
pub const GPIO_FUNC23_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC23_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC24_IN_SEL_CFG_REG: u32 = 1072972176;
pub const GPIO_SIG24_IN_SEL_V: u32 = 1;
pub const GPIO_SIG24_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC24_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC24_IN_SEL: u32 = 63;
pub const GPIO_FUNC24_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC24_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC25_IN_SEL_CFG_REG: u32 = 1072972180;
pub const GPIO_SIG25_IN_SEL_V: u32 = 1;
pub const GPIO_SIG25_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC25_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC25_IN_SEL: u32 = 63;
pub const GPIO_FUNC25_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC25_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC26_IN_SEL_CFG_REG: u32 = 1072972184;
pub const GPIO_SIG26_IN_SEL_V: u32 = 1;
pub const GPIO_SIG26_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC26_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC26_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC26_IN_SEL: u32 = 63;
pub const GPIO_FUNC26_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC26_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC27_IN_SEL_CFG_REG: u32 = 1072972188;
pub const GPIO_SIG27_IN_SEL_V: u32 = 1;
pub const GPIO_SIG27_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC27_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC27_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC27_IN_SEL: u32 = 63;
pub const GPIO_FUNC27_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC27_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC28_IN_SEL_CFG_REG: u32 = 1072972192;
pub const GPIO_SIG28_IN_SEL_V: u32 = 1;
pub const GPIO_SIG28_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC28_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC28_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC28_IN_SEL: u32 = 63;
pub const GPIO_FUNC28_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC28_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC29_IN_SEL_CFG_REG: u32 = 1072972196;
pub const GPIO_SIG29_IN_SEL_V: u32 = 1;
pub const GPIO_SIG29_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC29_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC29_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC29_IN_SEL: u32 = 63;
pub const GPIO_FUNC29_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC29_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC30_IN_SEL_CFG_REG: u32 = 1072972200;
pub const GPIO_SIG30_IN_SEL_V: u32 = 1;
pub const GPIO_SIG30_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC30_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC30_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC30_IN_SEL: u32 = 63;
pub const GPIO_FUNC30_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC30_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC31_IN_SEL_CFG_REG: u32 = 1072972204;
pub const GPIO_SIG31_IN_SEL_V: u32 = 1;
pub const GPIO_SIG31_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC31_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC31_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC31_IN_SEL: u32 = 63;
pub const GPIO_FUNC31_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC31_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC32_IN_SEL_CFG_REG: u32 = 1072972208;
pub const GPIO_SIG32_IN_SEL_V: u32 = 1;
pub const GPIO_SIG32_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC32_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC32_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC32_IN_SEL: u32 = 63;
pub const GPIO_FUNC32_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC32_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC33_IN_SEL_CFG_REG: u32 = 1072972212;
pub const GPIO_SIG33_IN_SEL_V: u32 = 1;
pub const GPIO_SIG33_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC33_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC33_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC33_IN_SEL: u32 = 63;
pub const GPIO_FUNC33_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC33_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC34_IN_SEL_CFG_REG: u32 = 1072972216;
pub const GPIO_SIG34_IN_SEL_V: u32 = 1;
pub const GPIO_SIG34_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC34_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC34_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC34_IN_SEL: u32 = 63;
pub const GPIO_FUNC34_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC34_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC35_IN_SEL_CFG_REG: u32 = 1072972220;
pub const GPIO_SIG35_IN_SEL_V: u32 = 1;
pub const GPIO_SIG35_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC35_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC35_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC35_IN_SEL: u32 = 63;
pub const GPIO_FUNC35_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC35_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC36_IN_SEL_CFG_REG: u32 = 1072972224;
pub const GPIO_SIG36_IN_SEL_V: u32 = 1;
pub const GPIO_SIG36_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC36_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC36_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC36_IN_SEL: u32 = 63;
pub const GPIO_FUNC36_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC36_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC37_IN_SEL_CFG_REG: u32 = 1072972228;
pub const GPIO_SIG37_IN_SEL_V: u32 = 1;
pub const GPIO_SIG37_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC37_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC37_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC37_IN_SEL: u32 = 63;
pub const GPIO_FUNC37_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC37_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC38_IN_SEL_CFG_REG: u32 = 1072972232;
pub const GPIO_SIG38_IN_SEL_V: u32 = 1;
pub const GPIO_SIG38_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC38_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC38_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC38_IN_SEL: u32 = 63;
pub const GPIO_FUNC38_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC38_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC39_IN_SEL_CFG_REG: u32 = 1072972236;
pub const GPIO_SIG39_IN_SEL_V: u32 = 1;
pub const GPIO_SIG39_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC39_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC39_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC39_IN_SEL: u32 = 63;
pub const GPIO_FUNC39_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC39_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC40_IN_SEL_CFG_REG: u32 = 1072972240;
pub const GPIO_SIG40_IN_SEL_V: u32 = 1;
pub const GPIO_SIG40_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC40_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC40_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC40_IN_SEL: u32 = 63;
pub const GPIO_FUNC40_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC40_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC41_IN_SEL_CFG_REG: u32 = 1072972244;
pub const GPIO_SIG41_IN_SEL_V: u32 = 1;
pub const GPIO_SIG41_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC41_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC41_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC41_IN_SEL: u32 = 63;
pub const GPIO_FUNC41_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC41_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC42_IN_SEL_CFG_REG: u32 = 1072972248;
pub const GPIO_SIG42_IN_SEL_V: u32 = 1;
pub const GPIO_SIG42_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC42_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC42_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC42_IN_SEL: u32 = 63;
pub const GPIO_FUNC42_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC42_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC43_IN_SEL_CFG_REG: u32 = 1072972252;
pub const GPIO_SIG43_IN_SEL_V: u32 = 1;
pub const GPIO_SIG43_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC43_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC43_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC43_IN_SEL: u32 = 63;
pub const GPIO_FUNC43_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC43_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC44_IN_SEL_CFG_REG: u32 = 1072972256;
pub const GPIO_SIG44_IN_SEL_V: u32 = 1;
pub const GPIO_SIG44_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC44_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC44_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC44_IN_SEL: u32 = 63;
pub const GPIO_FUNC44_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC44_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC45_IN_SEL_CFG_REG: u32 = 1072972260;
pub const GPIO_SIG45_IN_SEL_V: u32 = 1;
pub const GPIO_SIG45_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC45_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC45_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC45_IN_SEL: u32 = 63;
pub const GPIO_FUNC45_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC45_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC46_IN_SEL_CFG_REG: u32 = 1072972264;
pub const GPIO_SIG46_IN_SEL_V: u32 = 1;
pub const GPIO_SIG46_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC46_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC46_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC46_IN_SEL: u32 = 63;
pub const GPIO_FUNC46_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC46_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC47_IN_SEL_CFG_REG: u32 = 1072972268;
pub const GPIO_SIG47_IN_SEL_V: u32 = 1;
pub const GPIO_SIG47_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC47_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC47_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC47_IN_SEL: u32 = 63;
pub const GPIO_FUNC47_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC47_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC48_IN_SEL_CFG_REG: u32 = 1072972272;
pub const GPIO_SIG48_IN_SEL_V: u32 = 1;
pub const GPIO_SIG48_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC48_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC48_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC48_IN_SEL: u32 = 63;
pub const GPIO_FUNC48_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC48_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC49_IN_SEL_CFG_REG: u32 = 1072972276;
pub const GPIO_SIG49_IN_SEL_V: u32 = 1;
pub const GPIO_SIG49_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC49_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC49_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC49_IN_SEL: u32 = 63;
pub const GPIO_FUNC49_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC49_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC50_IN_SEL_CFG_REG: u32 = 1072972280;
pub const GPIO_SIG50_IN_SEL_V: u32 = 1;
pub const GPIO_SIG50_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC50_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC50_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC50_IN_SEL: u32 = 63;
pub const GPIO_FUNC50_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC50_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC51_IN_SEL_CFG_REG: u32 = 1072972284;
pub const GPIO_SIG51_IN_SEL_V: u32 = 1;
pub const GPIO_SIG51_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC51_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC51_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC51_IN_SEL: u32 = 63;
pub const GPIO_FUNC51_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC51_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC52_IN_SEL_CFG_REG: u32 = 1072972288;
pub const GPIO_SIG52_IN_SEL_V: u32 = 1;
pub const GPIO_SIG52_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC52_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC52_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC52_IN_SEL: u32 = 63;
pub const GPIO_FUNC52_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC52_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC53_IN_SEL_CFG_REG: u32 = 1072972292;
pub const GPIO_SIG53_IN_SEL_V: u32 = 1;
pub const GPIO_SIG53_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC53_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC53_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC53_IN_SEL: u32 = 63;
pub const GPIO_FUNC53_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC53_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC54_IN_SEL_CFG_REG: u32 = 1072972296;
pub const GPIO_SIG54_IN_SEL_V: u32 = 1;
pub const GPIO_SIG54_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC54_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC54_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC54_IN_SEL: u32 = 63;
pub const GPIO_FUNC54_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC54_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC55_IN_SEL_CFG_REG: u32 = 1072972300;
pub const GPIO_SIG55_IN_SEL_V: u32 = 1;
pub const GPIO_SIG55_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC55_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC55_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC55_IN_SEL: u32 = 63;
pub const GPIO_FUNC55_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC55_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC56_IN_SEL_CFG_REG: u32 = 1072972304;
pub const GPIO_SIG56_IN_SEL_V: u32 = 1;
pub const GPIO_SIG56_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC56_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC56_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC56_IN_SEL: u32 = 63;
pub const GPIO_FUNC56_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC56_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC57_IN_SEL_CFG_REG: u32 = 1072972308;
pub const GPIO_SIG57_IN_SEL_V: u32 = 1;
pub const GPIO_SIG57_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC57_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC57_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC57_IN_SEL: u32 = 63;
pub const GPIO_FUNC57_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC57_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC58_IN_SEL_CFG_REG: u32 = 1072972312;
pub const GPIO_SIG58_IN_SEL_V: u32 = 1;
pub const GPIO_SIG58_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC58_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC58_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC58_IN_SEL: u32 = 63;
pub const GPIO_FUNC58_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC58_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC59_IN_SEL_CFG_REG: u32 = 1072972316;
pub const GPIO_SIG59_IN_SEL_V: u32 = 1;
pub const GPIO_SIG59_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC59_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC59_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC59_IN_SEL: u32 = 63;
pub const GPIO_FUNC59_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC59_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC60_IN_SEL_CFG_REG: u32 = 1072972320;
pub const GPIO_SIG60_IN_SEL_V: u32 = 1;
pub const GPIO_SIG60_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC60_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC60_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC60_IN_SEL: u32 = 63;
pub const GPIO_FUNC60_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC60_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC61_IN_SEL_CFG_REG: u32 = 1072972324;
pub const GPIO_SIG61_IN_SEL_V: u32 = 1;
pub const GPIO_SIG61_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC61_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC61_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC61_IN_SEL: u32 = 63;
pub const GPIO_FUNC61_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC61_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC62_IN_SEL_CFG_REG: u32 = 1072972328;
pub const GPIO_SIG62_IN_SEL_V: u32 = 1;
pub const GPIO_SIG62_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC62_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC62_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC62_IN_SEL: u32 = 63;
pub const GPIO_FUNC62_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC62_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC63_IN_SEL_CFG_REG: u32 = 1072972332;
pub const GPIO_SIG63_IN_SEL_V: u32 = 1;
pub const GPIO_SIG63_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC63_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC63_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC63_IN_SEL: u32 = 63;
pub const GPIO_FUNC63_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC63_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC64_IN_SEL_CFG_REG: u32 = 1072972336;
pub const GPIO_SIG64_IN_SEL_V: u32 = 1;
pub const GPIO_SIG64_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC64_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC64_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC64_IN_SEL: u32 = 63;
pub const GPIO_FUNC64_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC64_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC65_IN_SEL_CFG_REG: u32 = 1072972340;
pub const GPIO_SIG65_IN_SEL_V: u32 = 1;
pub const GPIO_SIG65_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC65_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC65_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC65_IN_SEL: u32 = 63;
pub const GPIO_FUNC65_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC65_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC66_IN_SEL_CFG_REG: u32 = 1072972344;
pub const GPIO_SIG66_IN_SEL_V: u32 = 1;
pub const GPIO_SIG66_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC66_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC66_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC66_IN_SEL: u32 = 63;
pub const GPIO_FUNC66_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC66_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC67_IN_SEL_CFG_REG: u32 = 1072972348;
pub const GPIO_SIG67_IN_SEL_V: u32 = 1;
pub const GPIO_SIG67_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC67_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC67_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC67_IN_SEL: u32 = 63;
pub const GPIO_FUNC67_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC67_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC68_IN_SEL_CFG_REG: u32 = 1072972352;
pub const GPIO_SIG68_IN_SEL_V: u32 = 1;
pub const GPIO_SIG68_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC68_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC68_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC68_IN_SEL: u32 = 63;
pub const GPIO_FUNC68_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC68_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC69_IN_SEL_CFG_REG: u32 = 1072972356;
pub const GPIO_SIG69_IN_SEL_V: u32 = 1;
pub const GPIO_SIG69_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC69_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC69_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC69_IN_SEL: u32 = 63;
pub const GPIO_FUNC69_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC69_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC70_IN_SEL_CFG_REG: u32 = 1072972360;
pub const GPIO_SIG70_IN_SEL_V: u32 = 1;
pub const GPIO_SIG70_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC70_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC70_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC70_IN_SEL: u32 = 63;
pub const GPIO_FUNC70_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC70_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC71_IN_SEL_CFG_REG: u32 = 1072972364;
pub const GPIO_SIG71_IN_SEL_V: u32 = 1;
pub const GPIO_SIG71_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC71_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC71_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC71_IN_SEL: u32 = 63;
pub const GPIO_FUNC71_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC71_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC72_IN_SEL_CFG_REG: u32 = 1072972368;
pub const GPIO_SIG72_IN_SEL_V: u32 = 1;
pub const GPIO_SIG72_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC72_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC72_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC72_IN_SEL: u32 = 63;
pub const GPIO_FUNC72_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC72_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC73_IN_SEL_CFG_REG: u32 = 1072972372;
pub const GPIO_SIG73_IN_SEL_V: u32 = 1;
pub const GPIO_SIG73_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC73_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC73_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC73_IN_SEL: u32 = 63;
pub const GPIO_FUNC73_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC73_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC74_IN_SEL_CFG_REG: u32 = 1072972376;
pub const GPIO_SIG74_IN_SEL_V: u32 = 1;
pub const GPIO_SIG74_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC74_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC74_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC74_IN_SEL: u32 = 63;
pub const GPIO_FUNC74_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC74_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC75_IN_SEL_CFG_REG: u32 = 1072972380;
pub const GPIO_SIG75_IN_SEL_V: u32 = 1;
pub const GPIO_SIG75_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC75_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC75_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC75_IN_SEL: u32 = 63;
pub const GPIO_FUNC75_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC75_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC76_IN_SEL_CFG_REG: u32 = 1072972384;
pub const GPIO_SIG76_IN_SEL_V: u32 = 1;
pub const GPIO_SIG76_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC76_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC76_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC76_IN_SEL: u32 = 63;
pub const GPIO_FUNC76_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC76_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC77_IN_SEL_CFG_REG: u32 = 1072972388;
pub const GPIO_SIG77_IN_SEL_V: u32 = 1;
pub const GPIO_SIG77_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC77_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC77_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC77_IN_SEL: u32 = 63;
pub const GPIO_FUNC77_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC77_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC78_IN_SEL_CFG_REG: u32 = 1072972392;
pub const GPIO_SIG78_IN_SEL_V: u32 = 1;
pub const GPIO_SIG78_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC78_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC78_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC78_IN_SEL: u32 = 63;
pub const GPIO_FUNC78_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC78_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC79_IN_SEL_CFG_REG: u32 = 1072972396;
pub const GPIO_SIG79_IN_SEL_V: u32 = 1;
pub const GPIO_SIG79_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC79_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC79_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC79_IN_SEL: u32 = 63;
pub const GPIO_FUNC79_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC79_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC80_IN_SEL_CFG_REG: u32 = 1072972400;
pub const GPIO_SIG80_IN_SEL_V: u32 = 1;
pub const GPIO_SIG80_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC80_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC80_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC80_IN_SEL: u32 = 63;
pub const GPIO_FUNC80_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC80_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC81_IN_SEL_CFG_REG: u32 = 1072972404;
pub const GPIO_SIG81_IN_SEL_V: u32 = 1;
pub const GPIO_SIG81_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC81_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC81_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC81_IN_SEL: u32 = 63;
pub const GPIO_FUNC81_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC81_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC82_IN_SEL_CFG_REG: u32 = 1072972408;
pub const GPIO_SIG82_IN_SEL_V: u32 = 1;
pub const GPIO_SIG82_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC82_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC82_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC82_IN_SEL: u32 = 63;
pub const GPIO_FUNC82_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC82_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC83_IN_SEL_CFG_REG: u32 = 1072972412;
pub const GPIO_SIG83_IN_SEL_V: u32 = 1;
pub const GPIO_SIG83_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC83_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC83_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC83_IN_SEL: u32 = 63;
pub const GPIO_FUNC83_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC83_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC84_IN_SEL_CFG_REG: u32 = 1072972416;
pub const GPIO_SIG84_IN_SEL_V: u32 = 1;
pub const GPIO_SIG84_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC84_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC84_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC84_IN_SEL: u32 = 63;
pub const GPIO_FUNC84_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC84_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC85_IN_SEL_CFG_REG: u32 = 1072972420;
pub const GPIO_SIG85_IN_SEL_V: u32 = 1;
pub const GPIO_SIG85_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC85_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC85_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC85_IN_SEL: u32 = 63;
pub const GPIO_FUNC85_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC85_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC86_IN_SEL_CFG_REG: u32 = 1072972424;
pub const GPIO_SIG86_IN_SEL_V: u32 = 1;
pub const GPIO_SIG86_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC86_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC86_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC86_IN_SEL: u32 = 63;
pub const GPIO_FUNC86_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC86_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC87_IN_SEL_CFG_REG: u32 = 1072972428;
pub const GPIO_SIG87_IN_SEL_V: u32 = 1;
pub const GPIO_SIG87_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC87_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC87_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC87_IN_SEL: u32 = 63;
pub const GPIO_FUNC87_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC87_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC88_IN_SEL_CFG_REG: u32 = 1072972432;
pub const GPIO_SIG88_IN_SEL_V: u32 = 1;
pub const GPIO_SIG88_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC88_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC88_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC88_IN_SEL: u32 = 63;
pub const GPIO_FUNC88_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC88_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC89_IN_SEL_CFG_REG: u32 = 1072972436;
pub const GPIO_SIG89_IN_SEL_V: u32 = 1;
pub const GPIO_SIG89_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC89_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC89_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC89_IN_SEL: u32 = 63;
pub const GPIO_FUNC89_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC89_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC90_IN_SEL_CFG_REG: u32 = 1072972440;
pub const GPIO_SIG90_IN_SEL_V: u32 = 1;
pub const GPIO_SIG90_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC90_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC90_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC90_IN_SEL: u32 = 63;
pub const GPIO_FUNC90_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC90_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC91_IN_SEL_CFG_REG: u32 = 1072972444;
pub const GPIO_SIG91_IN_SEL_V: u32 = 1;
pub const GPIO_SIG91_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC91_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC91_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC91_IN_SEL: u32 = 63;
pub const GPIO_FUNC91_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC91_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC92_IN_SEL_CFG_REG: u32 = 1072972448;
pub const GPIO_SIG92_IN_SEL_V: u32 = 1;
pub const GPIO_SIG92_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC92_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC92_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC92_IN_SEL: u32 = 63;
pub const GPIO_FUNC92_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC92_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC93_IN_SEL_CFG_REG: u32 = 1072972452;
pub const GPIO_SIG93_IN_SEL_V: u32 = 1;
pub const GPIO_SIG93_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC93_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC93_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC93_IN_SEL: u32 = 63;
pub const GPIO_FUNC93_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC93_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC94_IN_SEL_CFG_REG: u32 = 1072972456;
pub const GPIO_SIG94_IN_SEL_V: u32 = 1;
pub const GPIO_SIG94_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC94_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC94_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC94_IN_SEL: u32 = 63;
pub const GPIO_FUNC94_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC94_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC95_IN_SEL_CFG_REG: u32 = 1072972460;
pub const GPIO_SIG95_IN_SEL_V: u32 = 1;
pub const GPIO_SIG95_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC95_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC95_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC95_IN_SEL: u32 = 63;
pub const GPIO_FUNC95_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC95_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC96_IN_SEL_CFG_REG: u32 = 1072972464;
pub const GPIO_SIG96_IN_SEL_V: u32 = 1;
pub const GPIO_SIG96_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC96_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC96_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC96_IN_SEL: u32 = 63;
pub const GPIO_FUNC96_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC96_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC97_IN_SEL_CFG_REG: u32 = 1072972468;
pub const GPIO_SIG97_IN_SEL_V: u32 = 1;
pub const GPIO_SIG97_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC97_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC97_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC97_IN_SEL: u32 = 63;
pub const GPIO_FUNC97_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC97_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC98_IN_SEL_CFG_REG: u32 = 1072972472;
pub const GPIO_SIG98_IN_SEL_V: u32 = 1;
pub const GPIO_SIG98_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC98_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC98_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC98_IN_SEL: u32 = 63;
pub const GPIO_FUNC98_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC98_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC99_IN_SEL_CFG_REG: u32 = 1072972476;
pub const GPIO_SIG99_IN_SEL_V: u32 = 1;
pub const GPIO_SIG99_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC99_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC99_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC99_IN_SEL: u32 = 63;
pub const GPIO_FUNC99_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC99_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC100_IN_SEL_CFG_REG: u32 = 1072972480;
pub const GPIO_SIG100_IN_SEL_V: u32 = 1;
pub const GPIO_SIG100_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC100_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC100_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC100_IN_SEL: u32 = 63;
pub const GPIO_FUNC100_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC100_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC101_IN_SEL_CFG_REG: u32 = 1072972484;
pub const GPIO_SIG101_IN_SEL_V: u32 = 1;
pub const GPIO_SIG101_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC101_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC101_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC101_IN_SEL: u32 = 63;
pub const GPIO_FUNC101_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC101_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC102_IN_SEL_CFG_REG: u32 = 1072972488;
pub const GPIO_SIG102_IN_SEL_V: u32 = 1;
pub const GPIO_SIG102_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC102_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC102_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC102_IN_SEL: u32 = 63;
pub const GPIO_FUNC102_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC102_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC103_IN_SEL_CFG_REG: u32 = 1072972492;
pub const GPIO_SIG103_IN_SEL_V: u32 = 1;
pub const GPIO_SIG103_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC103_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC103_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC103_IN_SEL: u32 = 63;
pub const GPIO_FUNC103_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC103_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC104_IN_SEL_CFG_REG: u32 = 1072972496;
pub const GPIO_SIG104_IN_SEL_V: u32 = 1;
pub const GPIO_SIG104_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC104_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC104_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC104_IN_SEL: u32 = 63;
pub const GPIO_FUNC104_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC104_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC105_IN_SEL_CFG_REG: u32 = 1072972500;
pub const GPIO_SIG105_IN_SEL_V: u32 = 1;
pub const GPIO_SIG105_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC105_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC105_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC105_IN_SEL: u32 = 63;
pub const GPIO_FUNC105_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC105_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC106_IN_SEL_CFG_REG: u32 = 1072972504;
pub const GPIO_SIG106_IN_SEL_V: u32 = 1;
pub const GPIO_SIG106_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC106_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC106_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC106_IN_SEL: u32 = 63;
pub const GPIO_FUNC106_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC106_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC107_IN_SEL_CFG_REG: u32 = 1072972508;
pub const GPIO_SIG107_IN_SEL_V: u32 = 1;
pub const GPIO_SIG107_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC107_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC107_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC107_IN_SEL: u32 = 63;
pub const GPIO_FUNC107_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC107_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC108_IN_SEL_CFG_REG: u32 = 1072972512;
pub const GPIO_SIG108_IN_SEL_V: u32 = 1;
pub const GPIO_SIG108_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC108_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC108_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC108_IN_SEL: u32 = 63;
pub const GPIO_FUNC108_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC108_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC109_IN_SEL_CFG_REG: u32 = 1072972516;
pub const GPIO_SIG109_IN_SEL_V: u32 = 1;
pub const GPIO_SIG109_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC109_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC109_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC109_IN_SEL: u32 = 63;
pub const GPIO_FUNC109_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC109_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC110_IN_SEL_CFG_REG: u32 = 1072972520;
pub const GPIO_SIG110_IN_SEL_V: u32 = 1;
pub const GPIO_SIG110_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC110_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC110_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC110_IN_SEL: u32 = 63;
pub const GPIO_FUNC110_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC110_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC111_IN_SEL_CFG_REG: u32 = 1072972524;
pub const GPIO_SIG111_IN_SEL_V: u32 = 1;
pub const GPIO_SIG111_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC111_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC111_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC111_IN_SEL: u32 = 63;
pub const GPIO_FUNC111_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC111_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC112_IN_SEL_CFG_REG: u32 = 1072972528;
pub const GPIO_SIG112_IN_SEL_V: u32 = 1;
pub const GPIO_SIG112_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC112_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC112_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC112_IN_SEL: u32 = 63;
pub const GPIO_FUNC112_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC112_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC113_IN_SEL_CFG_REG: u32 = 1072972532;
pub const GPIO_SIG113_IN_SEL_V: u32 = 1;
pub const GPIO_SIG113_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC113_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC113_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC113_IN_SEL: u32 = 63;
pub const GPIO_FUNC113_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC113_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC114_IN_SEL_CFG_REG: u32 = 1072972536;
pub const GPIO_SIG114_IN_SEL_V: u32 = 1;
pub const GPIO_SIG114_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC114_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC114_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC114_IN_SEL: u32 = 63;
pub const GPIO_FUNC114_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC114_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC115_IN_SEL_CFG_REG: u32 = 1072972540;
pub const GPIO_SIG115_IN_SEL_V: u32 = 1;
pub const GPIO_SIG115_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC115_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC115_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC115_IN_SEL: u32 = 63;
pub const GPIO_FUNC115_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC115_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC116_IN_SEL_CFG_REG: u32 = 1072972544;
pub const GPIO_SIG116_IN_SEL_V: u32 = 1;
pub const GPIO_SIG116_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC116_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC116_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC116_IN_SEL: u32 = 63;
pub const GPIO_FUNC116_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC116_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC117_IN_SEL_CFG_REG: u32 = 1072972548;
pub const GPIO_SIG117_IN_SEL_V: u32 = 1;
pub const GPIO_SIG117_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC117_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC117_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC117_IN_SEL: u32 = 63;
pub const GPIO_FUNC117_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC117_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC118_IN_SEL_CFG_REG: u32 = 1072972552;
pub const GPIO_SIG118_IN_SEL_V: u32 = 1;
pub const GPIO_SIG118_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC118_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC118_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC118_IN_SEL: u32 = 63;
pub const GPIO_FUNC118_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC118_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC119_IN_SEL_CFG_REG: u32 = 1072972556;
pub const GPIO_SIG119_IN_SEL_V: u32 = 1;
pub const GPIO_SIG119_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC119_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC119_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC119_IN_SEL: u32 = 63;
pub const GPIO_FUNC119_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC119_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC120_IN_SEL_CFG_REG: u32 = 1072972560;
pub const GPIO_SIG120_IN_SEL_V: u32 = 1;
pub const GPIO_SIG120_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC120_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC120_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC120_IN_SEL: u32 = 63;
pub const GPIO_FUNC120_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC120_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC121_IN_SEL_CFG_REG: u32 = 1072972564;
pub const GPIO_SIG121_IN_SEL_V: u32 = 1;
pub const GPIO_SIG121_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC121_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC121_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC121_IN_SEL: u32 = 63;
pub const GPIO_FUNC121_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC121_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC122_IN_SEL_CFG_REG: u32 = 1072972568;
pub const GPIO_SIG122_IN_SEL_V: u32 = 1;
pub const GPIO_SIG122_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC122_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC122_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC122_IN_SEL: u32 = 63;
pub const GPIO_FUNC122_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC122_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC123_IN_SEL_CFG_REG: u32 = 1072972572;
pub const GPIO_SIG123_IN_SEL_V: u32 = 1;
pub const GPIO_SIG123_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC123_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC123_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC123_IN_SEL: u32 = 63;
pub const GPIO_FUNC123_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC123_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC124_IN_SEL_CFG_REG: u32 = 1072972576;
pub const GPIO_SIG124_IN_SEL_V: u32 = 1;
pub const GPIO_SIG124_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC124_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC124_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC124_IN_SEL: u32 = 63;
pub const GPIO_FUNC124_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC124_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC125_IN_SEL_CFG_REG: u32 = 1072972580;
pub const GPIO_SIG125_IN_SEL_V: u32 = 1;
pub const GPIO_SIG125_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC125_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC125_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC125_IN_SEL: u32 = 63;
pub const GPIO_FUNC125_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC125_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC126_IN_SEL_CFG_REG: u32 = 1072972584;
pub const GPIO_SIG126_IN_SEL_V: u32 = 1;
pub const GPIO_SIG126_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC126_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC126_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC126_IN_SEL: u32 = 63;
pub const GPIO_FUNC126_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC126_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC127_IN_SEL_CFG_REG: u32 = 1072972588;
pub const GPIO_SIG127_IN_SEL_V: u32 = 1;
pub const GPIO_SIG127_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC127_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC127_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC127_IN_SEL: u32 = 63;
pub const GPIO_FUNC127_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC127_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC128_IN_SEL_CFG_REG: u32 = 1072972592;
pub const GPIO_SIG128_IN_SEL_V: u32 = 1;
pub const GPIO_SIG128_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC128_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC128_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC128_IN_SEL: u32 = 63;
pub const GPIO_FUNC128_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC128_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC129_IN_SEL_CFG_REG: u32 = 1072972596;
pub const GPIO_SIG129_IN_SEL_V: u32 = 1;
pub const GPIO_SIG129_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC129_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC129_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC129_IN_SEL: u32 = 63;
pub const GPIO_FUNC129_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC129_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC130_IN_SEL_CFG_REG: u32 = 1072972600;
pub const GPIO_SIG130_IN_SEL_V: u32 = 1;
pub const GPIO_SIG130_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC130_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC130_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC130_IN_SEL: u32 = 63;
pub const GPIO_FUNC130_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC130_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC131_IN_SEL_CFG_REG: u32 = 1072972604;
pub const GPIO_SIG131_IN_SEL_V: u32 = 1;
pub const GPIO_SIG131_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC131_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC131_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC131_IN_SEL: u32 = 63;
pub const GPIO_FUNC131_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC131_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC132_IN_SEL_CFG_REG: u32 = 1072972608;
pub const GPIO_SIG132_IN_SEL_V: u32 = 1;
pub const GPIO_SIG132_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC132_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC132_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC132_IN_SEL: u32 = 63;
pub const GPIO_FUNC132_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC132_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC133_IN_SEL_CFG_REG: u32 = 1072972612;
pub const GPIO_SIG133_IN_SEL_V: u32 = 1;
pub const GPIO_SIG133_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC133_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC133_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC133_IN_SEL: u32 = 63;
pub const GPIO_FUNC133_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC133_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC134_IN_SEL_CFG_REG: u32 = 1072972616;
pub const GPIO_SIG134_IN_SEL_V: u32 = 1;
pub const GPIO_SIG134_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC134_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC134_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC134_IN_SEL: u32 = 63;
pub const GPIO_FUNC134_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC134_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC135_IN_SEL_CFG_REG: u32 = 1072972620;
pub const GPIO_SIG135_IN_SEL_V: u32 = 1;
pub const GPIO_SIG135_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC135_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC135_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC135_IN_SEL: u32 = 63;
pub const GPIO_FUNC135_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC135_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC136_IN_SEL_CFG_REG: u32 = 1072972624;
pub const GPIO_SIG136_IN_SEL_V: u32 = 1;
pub const GPIO_SIG136_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC136_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC136_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC136_IN_SEL: u32 = 63;
pub const GPIO_FUNC136_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC136_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC137_IN_SEL_CFG_REG: u32 = 1072972628;
pub const GPIO_SIG137_IN_SEL_V: u32 = 1;
pub const GPIO_SIG137_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC137_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC137_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC137_IN_SEL: u32 = 63;
pub const GPIO_FUNC137_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC137_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC138_IN_SEL_CFG_REG: u32 = 1072972632;
pub const GPIO_SIG138_IN_SEL_V: u32 = 1;
pub const GPIO_SIG138_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC138_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC138_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC138_IN_SEL: u32 = 63;
pub const GPIO_FUNC138_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC138_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC139_IN_SEL_CFG_REG: u32 = 1072972636;
pub const GPIO_SIG139_IN_SEL_V: u32 = 1;
pub const GPIO_SIG139_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC139_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC139_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC139_IN_SEL: u32 = 63;
pub const GPIO_FUNC139_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC139_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC140_IN_SEL_CFG_REG: u32 = 1072972640;
pub const GPIO_SIG140_IN_SEL_V: u32 = 1;
pub const GPIO_SIG140_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC140_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC140_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC140_IN_SEL: u32 = 63;
pub const GPIO_FUNC140_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC140_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC141_IN_SEL_CFG_REG: u32 = 1072972644;
pub const GPIO_SIG141_IN_SEL_V: u32 = 1;
pub const GPIO_SIG141_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC141_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC141_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC141_IN_SEL: u32 = 63;
pub const GPIO_FUNC141_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC141_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC142_IN_SEL_CFG_REG: u32 = 1072972648;
pub const GPIO_SIG142_IN_SEL_V: u32 = 1;
pub const GPIO_SIG142_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC142_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC142_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC142_IN_SEL: u32 = 63;
pub const GPIO_FUNC142_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC142_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC143_IN_SEL_CFG_REG: u32 = 1072972652;
pub const GPIO_SIG143_IN_SEL_V: u32 = 1;
pub const GPIO_SIG143_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC143_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC143_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC143_IN_SEL: u32 = 63;
pub const GPIO_FUNC143_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC143_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC144_IN_SEL_CFG_REG: u32 = 1072972656;
pub const GPIO_SIG144_IN_SEL_V: u32 = 1;
pub const GPIO_SIG144_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC144_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC144_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC144_IN_SEL: u32 = 63;
pub const GPIO_FUNC144_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC144_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC145_IN_SEL_CFG_REG: u32 = 1072972660;
pub const GPIO_SIG145_IN_SEL_V: u32 = 1;
pub const GPIO_SIG145_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC145_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC145_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC145_IN_SEL: u32 = 63;
pub const GPIO_FUNC145_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC145_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC146_IN_SEL_CFG_REG: u32 = 1072972664;
pub const GPIO_SIG146_IN_SEL_V: u32 = 1;
pub const GPIO_SIG146_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC146_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC146_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC146_IN_SEL: u32 = 63;
pub const GPIO_FUNC146_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC146_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC147_IN_SEL_CFG_REG: u32 = 1072972668;
pub const GPIO_SIG147_IN_SEL_V: u32 = 1;
pub const GPIO_SIG147_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC147_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC147_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC147_IN_SEL: u32 = 63;
pub const GPIO_FUNC147_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC147_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC148_IN_SEL_CFG_REG: u32 = 1072972672;
pub const GPIO_SIG148_IN_SEL_V: u32 = 1;
pub const GPIO_SIG148_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC148_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC148_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC148_IN_SEL: u32 = 63;
pub const GPIO_FUNC148_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC148_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC149_IN_SEL_CFG_REG: u32 = 1072972676;
pub const GPIO_SIG149_IN_SEL_V: u32 = 1;
pub const GPIO_SIG149_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC149_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC149_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC149_IN_SEL: u32 = 63;
pub const GPIO_FUNC149_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC149_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC150_IN_SEL_CFG_REG: u32 = 1072972680;
pub const GPIO_SIG150_IN_SEL_V: u32 = 1;
pub const GPIO_SIG150_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC150_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC150_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC150_IN_SEL: u32 = 63;
pub const GPIO_FUNC150_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC150_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC151_IN_SEL_CFG_REG: u32 = 1072972684;
pub const GPIO_SIG151_IN_SEL_V: u32 = 1;
pub const GPIO_SIG151_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC151_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC151_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC151_IN_SEL: u32 = 63;
pub const GPIO_FUNC151_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC151_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC152_IN_SEL_CFG_REG: u32 = 1072972688;
pub const GPIO_SIG152_IN_SEL_V: u32 = 1;
pub const GPIO_SIG152_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC152_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC152_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC152_IN_SEL: u32 = 63;
pub const GPIO_FUNC152_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC152_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC153_IN_SEL_CFG_REG: u32 = 1072972692;
pub const GPIO_SIG153_IN_SEL_V: u32 = 1;
pub const GPIO_SIG153_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC153_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC153_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC153_IN_SEL: u32 = 63;
pub const GPIO_FUNC153_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC153_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC154_IN_SEL_CFG_REG: u32 = 1072972696;
pub const GPIO_SIG154_IN_SEL_V: u32 = 1;
pub const GPIO_SIG154_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC154_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC154_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC154_IN_SEL: u32 = 63;
pub const GPIO_FUNC154_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC154_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC155_IN_SEL_CFG_REG: u32 = 1072972700;
pub const GPIO_SIG155_IN_SEL_V: u32 = 1;
pub const GPIO_SIG155_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC155_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC155_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC155_IN_SEL: u32 = 63;
pub const GPIO_FUNC155_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC155_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC156_IN_SEL_CFG_REG: u32 = 1072972704;
pub const GPIO_SIG156_IN_SEL_V: u32 = 1;
pub const GPIO_SIG156_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC156_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC156_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC156_IN_SEL: u32 = 63;
pub const GPIO_FUNC156_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC156_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC157_IN_SEL_CFG_REG: u32 = 1072972708;
pub const GPIO_SIG157_IN_SEL_V: u32 = 1;
pub const GPIO_SIG157_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC157_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC157_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC157_IN_SEL: u32 = 63;
pub const GPIO_FUNC157_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC157_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC158_IN_SEL_CFG_REG: u32 = 1072972712;
pub const GPIO_SIG158_IN_SEL_V: u32 = 1;
pub const GPIO_SIG158_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC158_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC158_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC158_IN_SEL: u32 = 63;
pub const GPIO_FUNC158_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC158_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC159_IN_SEL_CFG_REG: u32 = 1072972716;
pub const GPIO_SIG159_IN_SEL_V: u32 = 1;
pub const GPIO_SIG159_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC159_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC159_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC159_IN_SEL: u32 = 63;
pub const GPIO_FUNC159_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC159_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC160_IN_SEL_CFG_REG: u32 = 1072972720;
pub const GPIO_SIG160_IN_SEL_V: u32 = 1;
pub const GPIO_SIG160_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC160_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC160_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC160_IN_SEL: u32 = 63;
pub const GPIO_FUNC160_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC160_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC161_IN_SEL_CFG_REG: u32 = 1072972724;
pub const GPIO_SIG161_IN_SEL_V: u32 = 1;
pub const GPIO_SIG161_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC161_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC161_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC161_IN_SEL: u32 = 63;
pub const GPIO_FUNC161_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC161_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC162_IN_SEL_CFG_REG: u32 = 1072972728;
pub const GPIO_SIG162_IN_SEL_V: u32 = 1;
pub const GPIO_SIG162_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC162_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC162_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC162_IN_SEL: u32 = 63;
pub const GPIO_FUNC162_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC162_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC163_IN_SEL_CFG_REG: u32 = 1072972732;
pub const GPIO_SIG163_IN_SEL_V: u32 = 1;
pub const GPIO_SIG163_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC163_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC163_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC163_IN_SEL: u32 = 63;
pub const GPIO_FUNC163_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC163_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC164_IN_SEL_CFG_REG: u32 = 1072972736;
pub const GPIO_SIG164_IN_SEL_V: u32 = 1;
pub const GPIO_SIG164_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC164_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC164_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC164_IN_SEL: u32 = 63;
pub const GPIO_FUNC164_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC164_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC165_IN_SEL_CFG_REG: u32 = 1072972740;
pub const GPIO_SIG165_IN_SEL_V: u32 = 1;
pub const GPIO_SIG165_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC165_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC165_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC165_IN_SEL: u32 = 63;
pub const GPIO_FUNC165_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC165_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC166_IN_SEL_CFG_REG: u32 = 1072972744;
pub const GPIO_SIG166_IN_SEL_V: u32 = 1;
pub const GPIO_SIG166_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC166_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC166_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC166_IN_SEL: u32 = 63;
pub const GPIO_FUNC166_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC166_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC167_IN_SEL_CFG_REG: u32 = 1072972748;
pub const GPIO_SIG167_IN_SEL_V: u32 = 1;
pub const GPIO_SIG167_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC167_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC167_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC167_IN_SEL: u32 = 63;
pub const GPIO_FUNC167_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC167_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC168_IN_SEL_CFG_REG: u32 = 1072972752;
pub const GPIO_SIG168_IN_SEL_V: u32 = 1;
pub const GPIO_SIG168_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC168_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC168_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC168_IN_SEL: u32 = 63;
pub const GPIO_FUNC168_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC168_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC169_IN_SEL_CFG_REG: u32 = 1072972756;
pub const GPIO_SIG169_IN_SEL_V: u32 = 1;
pub const GPIO_SIG169_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC169_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC169_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC169_IN_SEL: u32 = 63;
pub const GPIO_FUNC169_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC169_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC170_IN_SEL_CFG_REG: u32 = 1072972760;
pub const GPIO_SIG170_IN_SEL_V: u32 = 1;
pub const GPIO_SIG170_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC170_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC170_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC170_IN_SEL: u32 = 63;
pub const GPIO_FUNC170_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC170_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC171_IN_SEL_CFG_REG: u32 = 1072972764;
pub const GPIO_SIG171_IN_SEL_V: u32 = 1;
pub const GPIO_SIG171_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC171_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC171_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC171_IN_SEL: u32 = 63;
pub const GPIO_FUNC171_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC171_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC172_IN_SEL_CFG_REG: u32 = 1072972768;
pub const GPIO_SIG172_IN_SEL_V: u32 = 1;
pub const GPIO_SIG172_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC172_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC172_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC172_IN_SEL: u32 = 63;
pub const GPIO_FUNC172_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC172_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC173_IN_SEL_CFG_REG: u32 = 1072972772;
pub const GPIO_SIG173_IN_SEL_V: u32 = 1;
pub const GPIO_SIG173_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC173_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC173_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC173_IN_SEL: u32 = 63;
pub const GPIO_FUNC173_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC173_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC174_IN_SEL_CFG_REG: u32 = 1072972776;
pub const GPIO_SIG174_IN_SEL_V: u32 = 1;
pub const GPIO_SIG174_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC174_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC174_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC174_IN_SEL: u32 = 63;
pub const GPIO_FUNC174_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC174_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC175_IN_SEL_CFG_REG: u32 = 1072972780;
pub const GPIO_SIG175_IN_SEL_V: u32 = 1;
pub const GPIO_SIG175_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC175_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC175_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC175_IN_SEL: u32 = 63;
pub const GPIO_FUNC175_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC175_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC176_IN_SEL_CFG_REG: u32 = 1072972784;
pub const GPIO_SIG176_IN_SEL_V: u32 = 1;
pub const GPIO_SIG176_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC176_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC176_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC176_IN_SEL: u32 = 63;
pub const GPIO_FUNC176_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC176_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC177_IN_SEL_CFG_REG: u32 = 1072972788;
pub const GPIO_SIG177_IN_SEL_V: u32 = 1;
pub const GPIO_SIG177_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC177_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC177_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC177_IN_SEL: u32 = 63;
pub const GPIO_FUNC177_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC177_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC178_IN_SEL_CFG_REG: u32 = 1072972792;
pub const GPIO_SIG178_IN_SEL_V: u32 = 1;
pub const GPIO_SIG178_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC178_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC178_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC178_IN_SEL: u32 = 63;
pub const GPIO_FUNC178_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC178_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC179_IN_SEL_CFG_REG: u32 = 1072972796;
pub const GPIO_SIG179_IN_SEL_V: u32 = 1;
pub const GPIO_SIG179_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC179_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC179_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC179_IN_SEL: u32 = 63;
pub const GPIO_FUNC179_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC179_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC180_IN_SEL_CFG_REG: u32 = 1072972800;
pub const GPIO_SIG180_IN_SEL_V: u32 = 1;
pub const GPIO_SIG180_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC180_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC180_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC180_IN_SEL: u32 = 63;
pub const GPIO_FUNC180_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC180_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC181_IN_SEL_CFG_REG: u32 = 1072972804;
pub const GPIO_SIG181_IN_SEL_V: u32 = 1;
pub const GPIO_SIG181_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC181_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC181_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC181_IN_SEL: u32 = 63;
pub const GPIO_FUNC181_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC181_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC182_IN_SEL_CFG_REG: u32 = 1072972808;
pub const GPIO_SIG182_IN_SEL_V: u32 = 1;
pub const GPIO_SIG182_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC182_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC182_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC182_IN_SEL: u32 = 63;
pub const GPIO_FUNC182_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC182_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC183_IN_SEL_CFG_REG: u32 = 1072972812;
pub const GPIO_SIG183_IN_SEL_V: u32 = 1;
pub const GPIO_SIG183_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC183_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC183_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC183_IN_SEL: u32 = 63;
pub const GPIO_FUNC183_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC183_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC184_IN_SEL_CFG_REG: u32 = 1072972816;
pub const GPIO_SIG184_IN_SEL_V: u32 = 1;
pub const GPIO_SIG184_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC184_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC184_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC184_IN_SEL: u32 = 63;
pub const GPIO_FUNC184_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC184_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC185_IN_SEL_CFG_REG: u32 = 1072972820;
pub const GPIO_SIG185_IN_SEL_V: u32 = 1;
pub const GPIO_SIG185_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC185_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC185_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC185_IN_SEL: u32 = 63;
pub const GPIO_FUNC185_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC185_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC186_IN_SEL_CFG_REG: u32 = 1072972824;
pub const GPIO_SIG186_IN_SEL_V: u32 = 1;
pub const GPIO_SIG186_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC186_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC186_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC186_IN_SEL: u32 = 63;
pub const GPIO_FUNC186_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC186_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC187_IN_SEL_CFG_REG: u32 = 1072972828;
pub const GPIO_SIG187_IN_SEL_V: u32 = 1;
pub const GPIO_SIG187_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC187_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC187_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC187_IN_SEL: u32 = 63;
pub const GPIO_FUNC187_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC187_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC188_IN_SEL_CFG_REG: u32 = 1072972832;
pub const GPIO_SIG188_IN_SEL_V: u32 = 1;
pub const GPIO_SIG188_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC188_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC188_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC188_IN_SEL: u32 = 63;
pub const GPIO_FUNC188_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC188_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC189_IN_SEL_CFG_REG: u32 = 1072972836;
pub const GPIO_SIG189_IN_SEL_V: u32 = 1;
pub const GPIO_SIG189_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC189_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC189_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC189_IN_SEL: u32 = 63;
pub const GPIO_FUNC189_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC189_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC190_IN_SEL_CFG_REG: u32 = 1072972840;
pub const GPIO_SIG190_IN_SEL_V: u32 = 1;
pub const GPIO_SIG190_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC190_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC190_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC190_IN_SEL: u32 = 63;
pub const GPIO_FUNC190_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC190_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC191_IN_SEL_CFG_REG: u32 = 1072972844;
pub const GPIO_SIG191_IN_SEL_V: u32 = 1;
pub const GPIO_SIG191_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC191_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC191_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC191_IN_SEL: u32 = 63;
pub const GPIO_FUNC191_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC191_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC192_IN_SEL_CFG_REG: u32 = 1072972848;
pub const GPIO_SIG192_IN_SEL_V: u32 = 1;
pub const GPIO_SIG192_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC192_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC192_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC192_IN_SEL: u32 = 63;
pub const GPIO_FUNC192_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC192_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC193_IN_SEL_CFG_REG: u32 = 1072972852;
pub const GPIO_SIG193_IN_SEL_V: u32 = 1;
pub const GPIO_SIG193_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC193_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC193_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC193_IN_SEL: u32 = 63;
pub const GPIO_FUNC193_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC193_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC194_IN_SEL_CFG_REG: u32 = 1072972856;
pub const GPIO_SIG194_IN_SEL_V: u32 = 1;
pub const GPIO_SIG194_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC194_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC194_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC194_IN_SEL: u32 = 63;
pub const GPIO_FUNC194_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC194_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC195_IN_SEL_CFG_REG: u32 = 1072972860;
pub const GPIO_SIG195_IN_SEL_V: u32 = 1;
pub const GPIO_SIG195_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC195_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC195_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC195_IN_SEL: u32 = 63;
pub const GPIO_FUNC195_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC195_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC196_IN_SEL_CFG_REG: u32 = 1072972864;
pub const GPIO_SIG196_IN_SEL_V: u32 = 1;
pub const GPIO_SIG196_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC196_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC196_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC196_IN_SEL: u32 = 63;
pub const GPIO_FUNC196_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC196_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC197_IN_SEL_CFG_REG: u32 = 1072972868;
pub const GPIO_SIG197_IN_SEL_V: u32 = 1;
pub const GPIO_SIG197_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC197_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC197_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC197_IN_SEL: u32 = 63;
pub const GPIO_FUNC197_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC197_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC198_IN_SEL_CFG_REG: u32 = 1072972872;
pub const GPIO_SIG198_IN_SEL_V: u32 = 1;
pub const GPIO_SIG198_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC198_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC198_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC198_IN_SEL: u32 = 63;
pub const GPIO_FUNC198_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC198_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC199_IN_SEL_CFG_REG: u32 = 1072972876;
pub const GPIO_SIG199_IN_SEL_V: u32 = 1;
pub const GPIO_SIG199_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC199_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC199_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC199_IN_SEL: u32 = 63;
pub const GPIO_FUNC199_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC199_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC200_IN_SEL_CFG_REG: u32 = 1072972880;
pub const GPIO_SIG200_IN_SEL_V: u32 = 1;
pub const GPIO_SIG200_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC200_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC200_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC200_IN_SEL: u32 = 63;
pub const GPIO_FUNC200_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC200_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC201_IN_SEL_CFG_REG: u32 = 1072972884;
pub const GPIO_SIG201_IN_SEL_V: u32 = 1;
pub const GPIO_SIG201_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC201_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC201_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC201_IN_SEL: u32 = 63;
pub const GPIO_FUNC201_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC201_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC202_IN_SEL_CFG_REG: u32 = 1072972888;
pub const GPIO_SIG202_IN_SEL_V: u32 = 1;
pub const GPIO_SIG202_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC202_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC202_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC202_IN_SEL: u32 = 63;
pub const GPIO_FUNC202_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC202_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC203_IN_SEL_CFG_REG: u32 = 1072972892;
pub const GPIO_SIG203_IN_SEL_V: u32 = 1;
pub const GPIO_SIG203_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC203_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC203_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC203_IN_SEL: u32 = 63;
pub const GPIO_FUNC203_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC203_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC204_IN_SEL_CFG_REG: u32 = 1072972896;
pub const GPIO_SIG204_IN_SEL_V: u32 = 1;
pub const GPIO_SIG204_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC204_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC204_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC204_IN_SEL: u32 = 63;
pub const GPIO_FUNC204_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC204_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC205_IN_SEL_CFG_REG: u32 = 1072972900;
pub const GPIO_SIG205_IN_SEL_V: u32 = 1;
pub const GPIO_SIG205_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC205_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC205_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC205_IN_SEL: u32 = 63;
pub const GPIO_FUNC205_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC205_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC206_IN_SEL_CFG_REG: u32 = 1072972904;
pub const GPIO_SIG206_IN_SEL_V: u32 = 1;
pub const GPIO_SIG206_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC206_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC206_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC206_IN_SEL: u32 = 63;
pub const GPIO_FUNC206_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC206_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC207_IN_SEL_CFG_REG: u32 = 1072972908;
pub const GPIO_SIG207_IN_SEL_V: u32 = 1;
pub const GPIO_SIG207_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC207_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC207_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC207_IN_SEL: u32 = 63;
pub const GPIO_FUNC207_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC207_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC208_IN_SEL_CFG_REG: u32 = 1072972912;
pub const GPIO_SIG208_IN_SEL_V: u32 = 1;
pub const GPIO_SIG208_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC208_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC208_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC208_IN_SEL: u32 = 63;
pub const GPIO_FUNC208_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC208_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC209_IN_SEL_CFG_REG: u32 = 1072972916;
pub const GPIO_SIG209_IN_SEL_V: u32 = 1;
pub const GPIO_SIG209_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC209_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC209_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC209_IN_SEL: u32 = 63;
pub const GPIO_FUNC209_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC209_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC210_IN_SEL_CFG_REG: u32 = 1072972920;
pub const GPIO_SIG210_IN_SEL_V: u32 = 1;
pub const GPIO_SIG210_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC210_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC210_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC210_IN_SEL: u32 = 63;
pub const GPIO_FUNC210_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC210_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC211_IN_SEL_CFG_REG: u32 = 1072972924;
pub const GPIO_SIG211_IN_SEL_V: u32 = 1;
pub const GPIO_SIG211_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC211_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC211_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC211_IN_SEL: u32 = 63;
pub const GPIO_FUNC211_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC211_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC212_IN_SEL_CFG_REG: u32 = 1072972928;
pub const GPIO_SIG212_IN_SEL_V: u32 = 1;
pub const GPIO_SIG212_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC212_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC212_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC212_IN_SEL: u32 = 63;
pub const GPIO_FUNC212_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC212_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC213_IN_SEL_CFG_REG: u32 = 1072972932;
pub const GPIO_SIG213_IN_SEL_V: u32 = 1;
pub const GPIO_SIG213_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC213_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC213_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC213_IN_SEL: u32 = 63;
pub const GPIO_FUNC213_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC213_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC214_IN_SEL_CFG_REG: u32 = 1072972936;
pub const GPIO_SIG214_IN_SEL_V: u32 = 1;
pub const GPIO_SIG214_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC214_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC214_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC214_IN_SEL: u32 = 63;
pub const GPIO_FUNC214_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC214_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC215_IN_SEL_CFG_REG: u32 = 1072972940;
pub const GPIO_SIG215_IN_SEL_V: u32 = 1;
pub const GPIO_SIG215_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC215_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC215_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC215_IN_SEL: u32 = 63;
pub const GPIO_FUNC215_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC215_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC216_IN_SEL_CFG_REG: u32 = 1072972944;
pub const GPIO_SIG216_IN_SEL_V: u32 = 1;
pub const GPIO_SIG216_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC216_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC216_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC216_IN_SEL: u32 = 63;
pub const GPIO_FUNC216_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC216_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC217_IN_SEL_CFG_REG: u32 = 1072972948;
pub const GPIO_SIG217_IN_SEL_V: u32 = 1;
pub const GPIO_SIG217_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC217_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC217_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC217_IN_SEL: u32 = 63;
pub const GPIO_FUNC217_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC217_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC218_IN_SEL_CFG_REG: u32 = 1072972952;
pub const GPIO_SIG218_IN_SEL_V: u32 = 1;
pub const GPIO_SIG218_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC218_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC218_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC218_IN_SEL: u32 = 63;
pub const GPIO_FUNC218_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC218_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC219_IN_SEL_CFG_REG: u32 = 1072972956;
pub const GPIO_SIG219_IN_SEL_V: u32 = 1;
pub const GPIO_SIG219_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC219_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC219_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC219_IN_SEL: u32 = 63;
pub const GPIO_FUNC219_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC219_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC220_IN_SEL_CFG_REG: u32 = 1072972960;
pub const GPIO_SIG220_IN_SEL_V: u32 = 1;
pub const GPIO_SIG220_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC220_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC220_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC220_IN_SEL: u32 = 63;
pub const GPIO_FUNC220_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC220_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC221_IN_SEL_CFG_REG: u32 = 1072972964;
pub const GPIO_SIG221_IN_SEL_V: u32 = 1;
pub const GPIO_SIG221_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC221_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC221_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC221_IN_SEL: u32 = 63;
pub const GPIO_FUNC221_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC221_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC222_IN_SEL_CFG_REG: u32 = 1072972968;
pub const GPIO_SIG222_IN_SEL_V: u32 = 1;
pub const GPIO_SIG222_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC222_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC222_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC222_IN_SEL: u32 = 63;
pub const GPIO_FUNC222_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC222_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC223_IN_SEL_CFG_REG: u32 = 1072972972;
pub const GPIO_SIG223_IN_SEL_V: u32 = 1;
pub const GPIO_SIG223_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC223_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC223_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC223_IN_SEL: u32 = 63;
pub const GPIO_FUNC223_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC223_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC224_IN_SEL_CFG_REG: u32 = 1072972976;
pub const GPIO_SIG224_IN_SEL_V: u32 = 1;
pub const GPIO_SIG224_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC224_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC224_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC224_IN_SEL: u32 = 63;
pub const GPIO_FUNC224_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC224_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC225_IN_SEL_CFG_REG: u32 = 1072972980;
pub const GPIO_SIG225_IN_SEL_V: u32 = 1;
pub const GPIO_SIG225_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC225_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC225_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC225_IN_SEL: u32 = 63;
pub const GPIO_FUNC225_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC225_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC226_IN_SEL_CFG_REG: u32 = 1072972984;
pub const GPIO_SIG226_IN_SEL_V: u32 = 1;
pub const GPIO_SIG226_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC226_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC226_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC226_IN_SEL: u32 = 63;
pub const GPIO_FUNC226_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC226_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC227_IN_SEL_CFG_REG: u32 = 1072972988;
pub const GPIO_SIG227_IN_SEL_V: u32 = 1;
pub const GPIO_SIG227_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC227_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC227_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC227_IN_SEL: u32 = 63;
pub const GPIO_FUNC227_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC227_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC228_IN_SEL_CFG_REG: u32 = 1072972992;
pub const GPIO_SIG228_IN_SEL_V: u32 = 1;
pub const GPIO_SIG228_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC228_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC228_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC228_IN_SEL: u32 = 63;
pub const GPIO_FUNC228_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC228_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC229_IN_SEL_CFG_REG: u32 = 1072972996;
pub const GPIO_SIG229_IN_SEL_V: u32 = 1;
pub const GPIO_SIG229_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC229_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC229_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC229_IN_SEL: u32 = 63;
pub const GPIO_FUNC229_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC229_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC230_IN_SEL_CFG_REG: u32 = 1072973000;
pub const GPIO_SIG230_IN_SEL_V: u32 = 1;
pub const GPIO_SIG230_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC230_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC230_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC230_IN_SEL: u32 = 63;
pub const GPIO_FUNC230_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC230_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC231_IN_SEL_CFG_REG: u32 = 1072973004;
pub const GPIO_SIG231_IN_SEL_V: u32 = 1;
pub const GPIO_SIG231_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC231_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC231_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC231_IN_SEL: u32 = 63;
pub const GPIO_FUNC231_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC231_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC232_IN_SEL_CFG_REG: u32 = 1072973008;
pub const GPIO_SIG232_IN_SEL_V: u32 = 1;
pub const GPIO_SIG232_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC232_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC232_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC232_IN_SEL: u32 = 63;
pub const GPIO_FUNC232_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC232_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC233_IN_SEL_CFG_REG: u32 = 1072973012;
pub const GPIO_SIG233_IN_SEL_V: u32 = 1;
pub const GPIO_SIG233_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC233_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC233_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC233_IN_SEL: u32 = 63;
pub const GPIO_FUNC233_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC233_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC234_IN_SEL_CFG_REG: u32 = 1072973016;
pub const GPIO_SIG234_IN_SEL_V: u32 = 1;
pub const GPIO_SIG234_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC234_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC234_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC234_IN_SEL: u32 = 63;
pub const GPIO_FUNC234_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC234_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC235_IN_SEL_CFG_REG: u32 = 1072973020;
pub const GPIO_SIG235_IN_SEL_V: u32 = 1;
pub const GPIO_SIG235_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC235_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC235_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC235_IN_SEL: u32 = 63;
pub const GPIO_FUNC235_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC235_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC236_IN_SEL_CFG_REG: u32 = 1072973024;
pub const GPIO_SIG236_IN_SEL_V: u32 = 1;
pub const GPIO_SIG236_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC236_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC236_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC236_IN_SEL: u32 = 63;
pub const GPIO_FUNC236_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC236_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC237_IN_SEL_CFG_REG: u32 = 1072973028;
pub const GPIO_SIG237_IN_SEL_V: u32 = 1;
pub const GPIO_SIG237_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC237_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC237_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC237_IN_SEL: u32 = 63;
pub const GPIO_FUNC237_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC237_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC238_IN_SEL_CFG_REG: u32 = 1072973032;
pub const GPIO_SIG238_IN_SEL_V: u32 = 1;
pub const GPIO_SIG238_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC238_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC238_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC238_IN_SEL: u32 = 63;
pub const GPIO_FUNC238_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC238_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC239_IN_SEL_CFG_REG: u32 = 1072973036;
pub const GPIO_SIG239_IN_SEL_V: u32 = 1;
pub const GPIO_SIG239_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC239_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC239_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC239_IN_SEL: u32 = 63;
pub const GPIO_FUNC239_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC239_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC240_IN_SEL_CFG_REG: u32 = 1072973040;
pub const GPIO_SIG240_IN_SEL_V: u32 = 1;
pub const GPIO_SIG240_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC240_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC240_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC240_IN_SEL: u32 = 63;
pub const GPIO_FUNC240_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC240_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC241_IN_SEL_CFG_REG: u32 = 1072973044;
pub const GPIO_SIG241_IN_SEL_V: u32 = 1;
pub const GPIO_SIG241_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC241_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC241_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC241_IN_SEL: u32 = 63;
pub const GPIO_FUNC241_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC241_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC242_IN_SEL_CFG_REG: u32 = 1072973048;
pub const GPIO_SIG242_IN_SEL_V: u32 = 1;
pub const GPIO_SIG242_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC242_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC242_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC242_IN_SEL: u32 = 63;
pub const GPIO_FUNC242_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC242_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC243_IN_SEL_CFG_REG: u32 = 1072973052;
pub const GPIO_SIG243_IN_SEL_V: u32 = 1;
pub const GPIO_SIG243_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC243_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC243_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC243_IN_SEL: u32 = 63;
pub const GPIO_FUNC243_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC243_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC244_IN_SEL_CFG_REG: u32 = 1072973056;
pub const GPIO_SIG244_IN_SEL_V: u32 = 1;
pub const GPIO_SIG244_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC244_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC244_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC244_IN_SEL: u32 = 63;
pub const GPIO_FUNC244_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC244_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC245_IN_SEL_CFG_REG: u32 = 1072973060;
pub const GPIO_SIG245_IN_SEL_V: u32 = 1;
pub const GPIO_SIG245_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC245_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC245_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC245_IN_SEL: u32 = 63;
pub const GPIO_FUNC245_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC245_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC246_IN_SEL_CFG_REG: u32 = 1072973064;
pub const GPIO_SIG246_IN_SEL_V: u32 = 1;
pub const GPIO_SIG246_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC246_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC246_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC246_IN_SEL: u32 = 63;
pub const GPIO_FUNC246_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC246_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC247_IN_SEL_CFG_REG: u32 = 1072973068;
pub const GPIO_SIG247_IN_SEL_V: u32 = 1;
pub const GPIO_SIG247_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC247_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC247_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC247_IN_SEL: u32 = 63;
pub const GPIO_FUNC247_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC247_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC248_IN_SEL_CFG_REG: u32 = 1072973072;
pub const GPIO_SIG248_IN_SEL_V: u32 = 1;
pub const GPIO_SIG248_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC248_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC248_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC248_IN_SEL: u32 = 63;
pub const GPIO_FUNC248_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC248_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC249_IN_SEL_CFG_REG: u32 = 1072973076;
pub const GPIO_SIG249_IN_SEL_V: u32 = 1;
pub const GPIO_SIG249_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC249_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC249_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC249_IN_SEL: u32 = 63;
pub const GPIO_FUNC249_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC249_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC250_IN_SEL_CFG_REG: u32 = 1072973080;
pub const GPIO_SIG250_IN_SEL_V: u32 = 1;
pub const GPIO_SIG250_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC250_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC250_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC250_IN_SEL: u32 = 63;
pub const GPIO_FUNC250_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC250_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC251_IN_SEL_CFG_REG: u32 = 1072973084;
pub const GPIO_SIG251_IN_SEL_V: u32 = 1;
pub const GPIO_SIG251_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC251_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC251_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC251_IN_SEL: u32 = 63;
pub const GPIO_FUNC251_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC251_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC252_IN_SEL_CFG_REG: u32 = 1072973088;
pub const GPIO_SIG252_IN_SEL_V: u32 = 1;
pub const GPIO_SIG252_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC252_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC252_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC252_IN_SEL: u32 = 63;
pub const GPIO_FUNC252_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC252_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC253_IN_SEL_CFG_REG: u32 = 1072973092;
pub const GPIO_SIG253_IN_SEL_V: u32 = 1;
pub const GPIO_SIG253_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC253_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC253_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC253_IN_SEL: u32 = 63;
pub const GPIO_FUNC253_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC253_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC254_IN_SEL_CFG_REG: u32 = 1072973096;
pub const GPIO_SIG254_IN_SEL_V: u32 = 1;
pub const GPIO_SIG254_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC254_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC254_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC254_IN_SEL: u32 = 63;
pub const GPIO_FUNC254_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC254_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC255_IN_SEL_CFG_REG: u32 = 1072973100;
pub const GPIO_SIG255_IN_SEL_V: u32 = 1;
pub const GPIO_SIG255_IN_SEL_S: u32 = 7;
pub const GPIO_FUNC255_IN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC255_IN_INV_SEL_S: u32 = 6;
pub const GPIO_FUNC255_IN_SEL: u32 = 63;
pub const GPIO_FUNC255_IN_SEL_V: u32 = 63;
pub const GPIO_FUNC255_IN_SEL_S: u32 = 0;
pub const GPIO_FUNC0_OUT_SEL_CFG_REG: u32 = 1072973104;
pub const GPIO_FUNC0_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC0_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC0_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC0_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC0_OUT_SEL: u32 = 511;
pub const GPIO_FUNC0_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC0_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC1_OUT_SEL_CFG_REG: u32 = 1072973108;
pub const GPIO_FUNC1_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC1_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC1_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC1_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC1_OUT_SEL: u32 = 511;
pub const GPIO_FUNC1_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC1_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC2_OUT_SEL_CFG_REG: u32 = 1072973112;
pub const GPIO_FUNC2_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC2_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC2_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC2_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC2_OUT_SEL: u32 = 511;
pub const GPIO_FUNC2_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC2_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC3_OUT_SEL_CFG_REG: u32 = 1072973116;
pub const GPIO_FUNC3_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC3_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC3_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC3_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC3_OUT_SEL: u32 = 511;
pub const GPIO_FUNC3_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC3_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC4_OUT_SEL_CFG_REG: u32 = 1072973120;
pub const GPIO_FUNC4_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC4_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC4_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC4_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC4_OUT_SEL: u32 = 511;
pub const GPIO_FUNC4_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC4_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC5_OUT_SEL_CFG_REG: u32 = 1072973124;
pub const GPIO_FUNC5_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC5_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC5_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC5_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC5_OUT_SEL: u32 = 511;
pub const GPIO_FUNC5_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC5_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC6_OUT_SEL_CFG_REG: u32 = 1072973128;
pub const GPIO_FUNC6_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC6_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC6_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC6_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC6_OUT_SEL: u32 = 511;
pub const GPIO_FUNC6_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC6_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC7_OUT_SEL_CFG_REG: u32 = 1072973132;
pub const GPIO_FUNC7_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC7_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC7_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC7_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC7_OUT_SEL: u32 = 511;
pub const GPIO_FUNC7_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC7_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC8_OUT_SEL_CFG_REG: u32 = 1072973136;
pub const GPIO_FUNC8_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC8_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC8_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC8_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC8_OUT_SEL: u32 = 511;
pub const GPIO_FUNC8_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC8_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC9_OUT_SEL_CFG_REG: u32 = 1072973140;
pub const GPIO_FUNC9_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC9_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC9_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC9_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC9_OUT_SEL: u32 = 511;
pub const GPIO_FUNC9_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC9_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC10_OUT_SEL_CFG_REG: u32 = 1072973144;
pub const GPIO_FUNC10_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC10_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC10_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC10_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC10_OUT_SEL: u32 = 511;
pub const GPIO_FUNC10_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC10_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC11_OUT_SEL_CFG_REG: u32 = 1072973148;
pub const GPIO_FUNC11_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC11_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC11_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC11_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC11_OUT_SEL: u32 = 511;
pub const GPIO_FUNC11_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC11_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC12_OUT_SEL_CFG_REG: u32 = 1072973152;
pub const GPIO_FUNC12_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC12_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC12_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC12_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC12_OUT_SEL: u32 = 511;
pub const GPIO_FUNC12_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC12_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC13_OUT_SEL_CFG_REG: u32 = 1072973156;
pub const GPIO_FUNC13_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC13_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC13_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC13_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC13_OUT_SEL: u32 = 511;
pub const GPIO_FUNC13_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC13_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC14_OUT_SEL_CFG_REG: u32 = 1072973160;
pub const GPIO_FUNC14_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC14_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC14_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC14_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC14_OUT_SEL: u32 = 511;
pub const GPIO_FUNC14_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC14_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC15_OUT_SEL_CFG_REG: u32 = 1072973164;
pub const GPIO_FUNC15_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC15_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC15_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC15_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC15_OUT_SEL: u32 = 511;
pub const GPIO_FUNC15_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC15_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC16_OUT_SEL_CFG_REG: u32 = 1072973168;
pub const GPIO_FUNC16_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC16_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC16_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC16_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC16_OUT_SEL: u32 = 511;
pub const GPIO_FUNC16_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC16_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC17_OUT_SEL_CFG_REG: u32 = 1072973172;
pub const GPIO_FUNC17_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC17_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC17_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC17_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC17_OUT_SEL: u32 = 511;
pub const GPIO_FUNC17_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC17_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC18_OUT_SEL_CFG_REG: u32 = 1072973176;
pub const GPIO_FUNC18_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC18_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC18_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC18_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC18_OUT_SEL: u32 = 511;
pub const GPIO_FUNC18_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC18_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC19_OUT_SEL_CFG_REG: u32 = 1072973180;
pub const GPIO_FUNC19_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC19_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC19_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC19_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC19_OUT_SEL: u32 = 511;
pub const GPIO_FUNC19_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC19_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC20_OUT_SEL_CFG_REG: u32 = 1072973184;
pub const GPIO_FUNC20_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC20_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC20_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC20_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC20_OUT_SEL: u32 = 511;
pub const GPIO_FUNC20_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC20_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC21_OUT_SEL_CFG_REG: u32 = 1072973188;
pub const GPIO_FUNC21_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC21_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC21_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC21_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC21_OUT_SEL: u32 = 511;
pub const GPIO_FUNC21_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC21_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC22_OUT_SEL_CFG_REG: u32 = 1072973192;
pub const GPIO_FUNC22_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC22_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC22_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC22_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC22_OUT_SEL: u32 = 511;
pub const GPIO_FUNC22_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC22_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC23_OUT_SEL_CFG_REG: u32 = 1072973196;
pub const GPIO_FUNC23_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC23_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC23_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC23_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC23_OUT_SEL: u32 = 511;
pub const GPIO_FUNC23_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC23_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC24_OUT_SEL_CFG_REG: u32 = 1072973200;
pub const GPIO_FUNC24_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC24_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC24_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC24_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC24_OUT_SEL: u32 = 511;
pub const GPIO_FUNC24_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC24_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC25_OUT_SEL_CFG_REG: u32 = 1072973204;
pub const GPIO_FUNC25_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC25_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC25_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC25_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC25_OUT_SEL: u32 = 511;
pub const GPIO_FUNC25_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC25_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC26_OUT_SEL_CFG_REG: u32 = 1072973208;
pub const GPIO_FUNC26_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC26_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC26_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC26_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC26_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC26_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC26_OUT_SEL: u32 = 511;
pub const GPIO_FUNC26_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC26_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC27_OUT_SEL_CFG_REG: u32 = 1072973212;
pub const GPIO_FUNC27_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC27_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC27_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC27_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC27_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC27_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC27_OUT_SEL: u32 = 511;
pub const GPIO_FUNC27_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC27_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC28_OUT_SEL_CFG_REG: u32 = 1072973216;
pub const GPIO_FUNC28_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC28_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC28_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC28_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC28_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC28_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC28_OUT_SEL: u32 = 511;
pub const GPIO_FUNC28_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC28_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC29_OUT_SEL_CFG_REG: u32 = 1072973220;
pub const GPIO_FUNC29_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC29_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC29_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC29_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC29_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC29_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC29_OUT_SEL: u32 = 511;
pub const GPIO_FUNC29_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC29_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC30_OUT_SEL_CFG_REG: u32 = 1072973224;
pub const GPIO_FUNC30_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC30_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC30_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC30_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC30_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC30_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC30_OUT_SEL: u32 = 511;
pub const GPIO_FUNC30_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC30_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC31_OUT_SEL_CFG_REG: u32 = 1072973228;
pub const GPIO_FUNC31_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC31_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC31_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC31_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC31_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC31_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC31_OUT_SEL: u32 = 511;
pub const GPIO_FUNC31_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC31_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC32_OUT_SEL_CFG_REG: u32 = 1072973232;
pub const GPIO_FUNC32_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC32_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC32_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC32_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC32_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC32_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC32_OUT_SEL: u32 = 511;
pub const GPIO_FUNC32_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC32_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC33_OUT_SEL_CFG_REG: u32 = 1072973236;
pub const GPIO_FUNC33_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC33_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC33_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC33_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC33_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC33_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC33_OUT_SEL: u32 = 511;
pub const GPIO_FUNC33_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC33_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC34_OUT_SEL_CFG_REG: u32 = 1072973240;
pub const GPIO_FUNC34_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC34_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC34_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC34_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC34_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC34_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC34_OUT_SEL: u32 = 511;
pub const GPIO_FUNC34_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC34_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC35_OUT_SEL_CFG_REG: u32 = 1072973244;
pub const GPIO_FUNC35_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC35_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC35_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC35_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC35_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC35_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC35_OUT_SEL: u32 = 511;
pub const GPIO_FUNC35_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC35_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC36_OUT_SEL_CFG_REG: u32 = 1072973248;
pub const GPIO_FUNC36_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC36_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC36_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC36_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC36_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC36_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC36_OUT_SEL: u32 = 511;
pub const GPIO_FUNC36_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC36_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC37_OUT_SEL_CFG_REG: u32 = 1072973252;
pub const GPIO_FUNC37_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC37_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC37_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC37_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC37_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC37_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC37_OUT_SEL: u32 = 511;
pub const GPIO_FUNC37_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC37_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC38_OUT_SEL_CFG_REG: u32 = 1072973256;
pub const GPIO_FUNC38_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC38_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC38_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC38_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC38_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC38_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC38_OUT_SEL: u32 = 511;
pub const GPIO_FUNC38_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC38_OUT_SEL_S: u32 = 0;
pub const GPIO_FUNC39_OUT_SEL_CFG_REG: u32 = 1072973260;
pub const GPIO_FUNC39_OEN_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC39_OEN_INV_SEL_S: u32 = 11;
pub const GPIO_FUNC39_OEN_SEL_V: u32 = 1;
pub const GPIO_FUNC39_OEN_SEL_S: u32 = 10;
pub const GPIO_FUNC39_OUT_INV_SEL_V: u32 = 1;
pub const GPIO_FUNC39_OUT_INV_SEL_S: u32 = 9;
pub const GPIO_FUNC39_OUT_SEL: u32 = 511;
pub const GPIO_FUNC39_OUT_SEL_V: u32 = 511;
pub const GPIO_FUNC39_OUT_SEL_S: u32 = 0;
pub const SPICLK_IN_IDX: u32 = 0;
pub const SPICLK_OUT_IDX: u32 = 0;
pub const SPIQ_IN_IDX: u32 = 1;
pub const SPIQ_OUT_IDX: u32 = 1;
pub const SPID_IN_IDX: u32 = 2;
pub const SPID_OUT_IDX: u32 = 2;
pub const SPIHD_IN_IDX: u32 = 3;
pub const SPIHD_OUT_IDX: u32 = 3;
pub const SPIWP_IN_IDX: u32 = 4;
pub const SPIWP_OUT_IDX: u32 = 4;
pub const SPICS0_IN_IDX: u32 = 5;
pub const SPICS0_OUT_IDX: u32 = 5;
pub const SPICS1_IN_IDX: u32 = 6;
pub const SPICS1_OUT_IDX: u32 = 6;
pub const SPICS2_IN_IDX: u32 = 7;
pub const SPICS2_OUT_IDX: u32 = 7;
pub const HSPICLK_IN_IDX: u32 = 8;
pub const HSPICLK_OUT_IDX: u32 = 8;
pub const HSPIQ_IN_IDX: u32 = 9;
pub const HSPIQ_OUT_IDX: u32 = 9;
pub const HSPID_IN_IDX: u32 = 10;
pub const HSPID_OUT_IDX: u32 = 10;
pub const HSPICS0_IN_IDX: u32 = 11;
pub const HSPICS0_OUT_IDX: u32 = 11;
pub const HSPIHD_IN_IDX: u32 = 12;
pub const HSPIHD_OUT_IDX: u32 = 12;
pub const HSPIWP_IN_IDX: u32 = 13;
pub const HSPIWP_OUT_IDX: u32 = 13;
pub const U0RXD_IN_IDX: u32 = 14;
pub const U0TXD_OUT_IDX: u32 = 14;
pub const U0CTS_IN_IDX: u32 = 15;
pub const U0RTS_OUT_IDX: u32 = 15;
pub const U0DSR_IN_IDX: u32 = 16;
pub const U0DTR_OUT_IDX: u32 = 16;
pub const U1RXD_IN_IDX: u32 = 17;
pub const U1TXD_OUT_IDX: u32 = 17;
pub const U1CTS_IN_IDX: u32 = 18;
pub const U1RTS_OUT_IDX: u32 = 18;
pub const I2CM_SCL_O_IDX: u32 = 19;
pub const I2CM_SDA_I_IDX: u32 = 20;
pub const I2CM_SDA_O_IDX: u32 = 20;
pub const EXT_I2C_SCL_O_IDX: u32 = 21;
pub const EXT_I2C_SDA_O_IDX: u32 = 22;
pub const EXT_I2C_SDA_I_IDX: u32 = 22;
pub const I2S0O_BCK_IN_IDX: u32 = 23;
pub const I2S0O_BCK_OUT_IDX: u32 = 23;
pub const I2S1O_BCK_IN_IDX: u32 = 24;
pub const I2S1O_BCK_OUT_IDX: u32 = 24;
pub const I2S0O_WS_IN_IDX: u32 = 25;
pub const I2S0O_WS_OUT_IDX: u32 = 25;
pub const I2S1O_WS_IN_IDX: u32 = 26;
pub const I2S1O_WS_OUT_IDX: u32 = 26;
pub const I2S0I_BCK_IN_IDX: u32 = 27;
pub const I2S0I_BCK_OUT_IDX: u32 = 27;
pub const I2S0I_WS_IN_IDX: u32 = 28;
pub const I2S0I_WS_OUT_IDX: u32 = 28;
pub const I2CEXT0_SCL_IN_IDX: u32 = 29;
pub const I2CEXT0_SCL_OUT_IDX: u32 = 29;
pub const I2CEXT0_SDA_IN_IDX: u32 = 30;
pub const I2CEXT0_SDA_OUT_IDX: u32 = 30;
pub const PWM0_SYNC0_IN_IDX: u32 = 31;
pub const SDIO_TOHOST_INT_OUT_IDX: u32 = 31;
pub const PWM0_SYNC1_IN_IDX: u32 = 32;
pub const PWM0_OUT0A_IDX: u32 = 32;
pub const PWM0_SYNC2_IN_IDX: u32 = 33;
pub const PWM0_OUT0B_IDX: u32 = 33;
pub const PWM0_F0_IN_IDX: u32 = 34;
pub const PWM0_OUT1A_IDX: u32 = 34;
pub const PWM0_F1_IN_IDX: u32 = 35;
pub const PWM0_OUT1B_IDX: u32 = 35;
pub const PWM0_F2_IN_IDX: u32 = 36;
pub const PWM0_OUT2A_IDX: u32 = 36;
pub const GPIO_BT_ACTIVE_IDX: u32 = 37;
pub const PWM0_OUT2B_IDX: u32 = 37;
pub const GPIO_BT_PRIORITY_IDX: u32 = 38;
pub const PCNT_SIG_CH0_IN0_IDX: u32 = 39;
pub const PCNT_SIG_CH1_IN0_IDX: u32 = 40;
pub const GPIO_WLAN_ACTIVE_IDX: u32 = 40;
pub const PCNT_CTRL_CH0_IN0_IDX: u32 = 41;
pub const BB_DIAG0_IDX: u32 = 41;
pub const PCNT_CTRL_CH1_IN0_IDX: u32 = 42;
pub const BB_DIAG1_IDX: u32 = 42;
pub const PCNT_SIG_CH0_IN1_IDX: u32 = 43;
pub const BB_DIAG2_IDX: u32 = 43;
pub const PCNT_SIG_CH1_IN1_IDX: u32 = 44;
pub const BB_DIAG3_IDX: u32 = 44;
pub const PCNT_CTRL_CH0_IN1_IDX: u32 = 45;
pub const BB_DIAG4_IDX: u32 = 45;
pub const PCNT_CTRL_CH1_IN1_IDX: u32 = 46;
pub const BB_DIAG5_IDX: u32 = 46;
pub const PCNT_SIG_CH0_IN2_IDX: u32 = 47;
pub const BB_DIAG6_IDX: u32 = 47;
pub const PCNT_SIG_CH1_IN2_IDX: u32 = 48;
pub const BB_DIAG7_IDX: u32 = 48;
pub const PCNT_CTRL_CH0_IN2_IDX: u32 = 49;
pub const BB_DIAG8_IDX: u32 = 49;
pub const PCNT_CTRL_CH1_IN2_IDX: u32 = 50;
pub const BB_DIAG9_IDX: u32 = 50;
pub const PCNT_SIG_CH0_IN3_IDX: u32 = 51;
pub const BB_DIAG10_IDX: u32 = 51;
pub const PCNT_SIG_CH1_IN3_IDX: u32 = 52;
pub const BB_DIAG11_IDX: u32 = 52;
pub const PCNT_CTRL_CH0_IN3_IDX: u32 = 53;
pub const BB_DIAG12_IDX: u32 = 53;
pub const PCNT_CTRL_CH1_IN3_IDX: u32 = 54;
pub const BB_DIAG13_IDX: u32 = 54;
pub const PCNT_SIG_CH0_IN4_IDX: u32 = 55;
pub const BB_DIAG14_IDX: u32 = 55;
pub const PCNT_SIG_CH1_IN4_IDX: u32 = 56;
pub const BB_DIAG15_IDX: u32 = 56;
pub const PCNT_CTRL_CH0_IN4_IDX: u32 = 57;
pub const BB_DIAG16_IDX: u32 = 57;
pub const PCNT_CTRL_CH1_IN4_IDX: u32 = 58;
pub const BB_DIAG17_IDX: u32 = 58;
pub const BB_DIAG18_IDX: u32 = 59;
pub const BB_DIAG19_IDX: u32 = 60;
pub const HSPICS1_IN_IDX: u32 = 61;
pub const HSPICS1_OUT_IDX: u32 = 61;
pub const HSPICS2_IN_IDX: u32 = 62;
pub const HSPICS2_OUT_IDX: u32 = 62;
pub const VSPICLK_IN_IDX: u32 = 63;
pub const VSPICLK_OUT_IDX: u32 = 63;
pub const VSPIQ_IN_IDX: u32 = 64;
pub const VSPIQ_OUT_IDX: u32 = 64;
pub const VSPID_IN_IDX: u32 = 65;
pub const VSPID_OUT_IDX: u32 = 65;
pub const VSPIHD_IN_IDX: u32 = 66;
pub const VSPIHD_OUT_IDX: u32 = 66;
pub const VSPIWP_IN_IDX: u32 = 67;
pub const VSPIWP_OUT_IDX: u32 = 67;
pub const VSPICS0_IN_IDX: u32 = 68;
pub const VSPICS0_OUT_IDX: u32 = 68;
pub const VSPICS1_IN_IDX: u32 = 69;
pub const VSPICS1_OUT_IDX: u32 = 69;
pub const VSPICS2_IN_IDX: u32 = 70;
pub const VSPICS2_OUT_IDX: u32 = 70;
pub const PCNT_SIG_CH0_IN5_IDX: u32 = 71;
pub const LEDC_HS_SIG_OUT0_IDX: u32 = 71;
pub const PCNT_SIG_CH1_IN5_IDX: u32 = 72;
pub const LEDC_HS_SIG_OUT1_IDX: u32 = 72;
pub const PCNT_CTRL_CH0_IN5_IDX: u32 = 73;
pub const LEDC_HS_SIG_OUT2_IDX: u32 = 73;
pub const PCNT_CTRL_CH1_IN5_IDX: u32 = 74;
pub const LEDC_HS_SIG_OUT3_IDX: u32 = 74;
pub const PCNT_SIG_CH0_IN6_IDX: u32 = 75;
pub const LEDC_HS_SIG_OUT4_IDX: u32 = 75;
pub const PCNT_SIG_CH1_IN6_IDX: u32 = 76;
pub const LEDC_HS_SIG_OUT5_IDX: u32 = 76;
pub const PCNT_CTRL_CH0_IN6_IDX: u32 = 77;
pub const LEDC_HS_SIG_OUT6_IDX: u32 = 77;
pub const PCNT_CTRL_CH1_IN6_IDX: u32 = 78;
pub const LEDC_HS_SIG_OUT7_IDX: u32 = 78;
pub const PCNT_SIG_CH0_IN7_IDX: u32 = 79;
pub const LEDC_LS_SIG_OUT0_IDX: u32 = 79;
pub const PCNT_SIG_CH1_IN7_IDX: u32 = 80;
pub const LEDC_LS_SIG_OUT1_IDX: u32 = 80;
pub const PCNT_CTRL_CH0_IN7_IDX: u32 = 81;
pub const LEDC_LS_SIG_OUT2_IDX: u32 = 81;
pub const PCNT_CTRL_CH1_IN7_IDX: u32 = 82;
pub const LEDC_LS_SIG_OUT3_IDX: u32 = 82;
pub const RMT_SIG_IN0_IDX: u32 = 83;
pub const LEDC_LS_SIG_OUT4_IDX: u32 = 83;
pub const RMT_SIG_IN1_IDX: u32 = 84;
pub const LEDC_LS_SIG_OUT5_IDX: u32 = 84;
pub const RMT_SIG_IN2_IDX: u32 = 85;
pub const LEDC_LS_SIG_OUT6_IDX: u32 = 85;
pub const RMT_SIG_IN3_IDX: u32 = 86;
pub const LEDC_LS_SIG_OUT7_IDX: u32 = 86;
pub const RMT_SIG_IN4_IDX: u32 = 87;
pub const RMT_SIG_OUT0_IDX: u32 = 87;
pub const RMT_SIG_IN5_IDX: u32 = 88;
pub const RMT_SIG_OUT1_IDX: u32 = 88;
pub const RMT_SIG_IN6_IDX: u32 = 89;
pub const RMT_SIG_OUT2_IDX: u32 = 89;
pub const RMT_SIG_IN7_IDX: u32 = 90;
pub const RMT_SIG_OUT3_IDX: u32 = 90;
pub const RMT_SIG_OUT4_IDX: u32 = 91;
pub const RMT_SIG_OUT5_IDX: u32 = 92;
pub const EXT_ADC_START_IDX: u32 = 93;
pub const RMT_SIG_OUT6_IDX: u32 = 93;
pub const CAN_RX_IDX: u32 = 94;
pub const RMT_SIG_OUT7_IDX: u32 = 94;
pub const I2CEXT1_SCL_IN_IDX: u32 = 95;
pub const I2CEXT1_SCL_OUT_IDX: u32 = 95;
pub const I2CEXT1_SDA_IN_IDX: u32 = 96;
pub const I2CEXT1_SDA_OUT_IDX: u32 = 96;
pub const HOST_CARD_DETECT_N_1_IDX: u32 = 97;
pub const HOST_CCMD_OD_PULLUP_EN_N_IDX: u32 = 97;
pub const HOST_CARD_DETECT_N_2_IDX: u32 = 98;
pub const HOST_RST_N_1_IDX: u32 = 98;
pub const HOST_CARD_WRITE_PRT_1_IDX: u32 = 99;
pub const HOST_RST_N_2_IDX: u32 = 99;
pub const HOST_CARD_WRITE_PRT_2_IDX: u32 = 100;
pub const GPIO_SD0_OUT_IDX: u32 = 100;
pub const HOST_CARD_INT_N_1_IDX: u32 = 101;
pub const GPIO_SD1_OUT_IDX: u32 = 101;
pub const HOST_CARD_INT_N_2_IDX: u32 = 102;
pub const GPIO_SD2_OUT_IDX: u32 = 102;
pub const PWM1_SYNC0_IN_IDX: u32 = 103;
pub const GPIO_SD3_OUT_IDX: u32 = 103;
pub const PWM1_SYNC1_IN_IDX: u32 = 104;
pub const GPIO_SD4_OUT_IDX: u32 = 104;
pub const PWM1_SYNC2_IN_IDX: u32 = 105;
pub const GPIO_SD5_OUT_IDX: u32 = 105;
pub const PWM1_F0_IN_IDX: u32 = 106;
pub const GPIO_SD6_OUT_IDX: u32 = 106;
pub const PWM1_F1_IN_IDX: u32 = 107;
pub const GPIO_SD7_OUT_IDX: u32 = 107;
pub const PWM1_F2_IN_IDX: u32 = 108;
pub const PWM1_OUT0A_IDX: u32 = 108;
pub const PWM0_CAP0_IN_IDX: u32 = 109;
pub const PWM1_OUT0B_IDX: u32 = 109;
pub const PWM0_CAP1_IN_IDX: u32 = 110;
pub const PWM1_OUT1A_IDX: u32 = 110;
pub const PWM0_CAP2_IN_IDX: u32 = 111;
pub const PWM1_OUT1B_IDX: u32 = 111;
pub const PWM1_CAP0_IN_IDX: u32 = 112;
pub const PWM1_OUT2A_IDX: u32 = 112;
pub const PWM1_CAP1_IN_IDX: u32 = 113;
pub const PWM1_OUT2B_IDX: u32 = 113;
pub const PWM1_CAP2_IN_IDX: u32 = 114;
pub const PWM2_OUT1H_IDX: u32 = 114;
pub const PWM2_FLTA_IDX: u32 = 115;
pub const PWM2_OUT1L_IDX: u32 = 115;
pub const PWM2_FLTB_IDX: u32 = 116;
pub const PWM2_OUT2H_IDX: u32 = 116;
pub const PWM2_CAP1_IN_IDX: u32 = 117;
pub const PWM2_OUT2L_IDX: u32 = 117;
pub const PWM2_CAP2_IN_IDX: u32 = 118;
pub const PWM2_OUT3H_IDX: u32 = 118;
pub const PWM2_CAP3_IN_IDX: u32 = 119;
pub const PWM2_OUT3L_IDX: u32 = 119;
pub const PWM3_FLTA_IDX: u32 = 120;
pub const PWM2_OUT4H_IDX: u32 = 120;
pub const PWM3_FLTB_IDX: u32 = 121;
pub const PWM2_OUT4L_IDX: u32 = 121;
pub const PWM3_CAP1_IN_IDX: u32 = 122;
pub const PWM3_CAP2_IN_IDX: u32 = 123;
pub const CAN_TX_IDX: u32 = 123;
pub const PWM3_CAP3_IN_IDX: u32 = 124;
pub const CAN_BUS_OFF_ON_IDX: u32 = 124;
pub const CAN_CLKOUT_IDX: u32 = 125;
pub const SPID4_IN_IDX: u32 = 128;
pub const SPID4_OUT_IDX: u32 = 128;
pub const SPID5_IN_IDX: u32 = 129;
pub const SPID5_OUT_IDX: u32 = 129;
pub const SPID6_IN_IDX: u32 = 130;
pub const SPID6_OUT_IDX: u32 = 130;
pub const SPID7_IN_IDX: u32 = 131;
pub const SPID7_OUT_IDX: u32 = 131;
pub const HSPID4_IN_IDX: u32 = 132;
pub const HSPID4_OUT_IDX: u32 = 132;
pub const HSPID5_IN_IDX: u32 = 133;
pub const HSPID5_OUT_IDX: u32 = 133;
pub const HSPID6_IN_IDX: u32 = 134;
pub const HSPID6_OUT_IDX: u32 = 134;
pub const HSPID7_IN_IDX: u32 = 135;
pub const HSPID7_OUT_IDX: u32 = 135;
pub const VSPID4_IN_IDX: u32 = 136;
pub const VSPID4_OUT_IDX: u32 = 136;
pub const VSPID5_IN_IDX: u32 = 137;
pub const VSPID5_OUT_IDX: u32 = 137;
pub const VSPID6_IN_IDX: u32 = 138;
pub const VSPID6_OUT_IDX: u32 = 138;
pub const VSPID7_IN_IDX: u32 = 139;
pub const VSPID7_OUT_IDX: u32 = 139;
pub const I2S0I_DATA_IN0_IDX: u32 = 140;
pub const I2S0O_DATA_OUT0_IDX: u32 = 140;
pub const I2S0I_DATA_IN1_IDX: u32 = 141;
pub const I2S0O_DATA_OUT1_IDX: u32 = 141;
pub const I2S0I_DATA_IN2_IDX: u32 = 142;
pub const I2S0O_DATA_OUT2_IDX: u32 = 142;
pub const I2S0I_DATA_IN3_IDX: u32 = 143;
pub const I2S0O_DATA_OUT3_IDX: u32 = 143;
pub const I2S0I_DATA_IN4_IDX: u32 = 144;
pub const I2S0O_DATA_OUT4_IDX: u32 = 144;
pub const I2S0I_DATA_IN5_IDX: u32 = 145;
pub const I2S0O_DATA_OUT5_IDX: u32 = 145;
pub const I2S0I_DATA_IN6_IDX: u32 = 146;
pub const I2S0O_DATA_OUT6_IDX: u32 = 146;
pub const I2S0I_DATA_IN7_IDX: u32 = 147;
pub const I2S0O_DATA_OUT7_IDX: u32 = 147;
pub const I2S0I_DATA_IN8_IDX: u32 = 148;
pub const I2S0O_DATA_OUT8_IDX: u32 = 148;
pub const I2S0I_DATA_IN9_IDX: u32 = 149;
pub const I2S0O_DATA_OUT9_IDX: u32 = 149;
pub const I2S0I_DATA_IN10_IDX: u32 = 150;
pub const I2S0O_DATA_OUT10_IDX: u32 = 150;
pub const I2S0I_DATA_IN11_IDX: u32 = 151;
pub const I2S0O_DATA_OUT11_IDX: u32 = 151;
pub const I2S0I_DATA_IN12_IDX: u32 = 152;
pub const I2S0O_DATA_OUT12_IDX: u32 = 152;
pub const I2S0I_DATA_IN13_IDX: u32 = 153;
pub const I2S0O_DATA_OUT13_IDX: u32 = 153;
pub const I2S0I_DATA_IN14_IDX: u32 = 154;
pub const I2S0O_DATA_OUT14_IDX: u32 = 154;
pub const I2S0I_DATA_IN15_IDX: u32 = 155;
pub const I2S0O_DATA_OUT15_IDX: u32 = 155;
pub const I2S0O_DATA_OUT16_IDX: u32 = 156;
pub const I2S0O_DATA_OUT17_IDX: u32 = 157;
pub const I2S0O_DATA_OUT18_IDX: u32 = 158;
pub const I2S0O_DATA_OUT19_IDX: u32 = 159;
pub const I2S0O_DATA_OUT20_IDX: u32 = 160;
pub const I2S0O_DATA_OUT21_IDX: u32 = 161;
pub const I2S0O_DATA_OUT22_IDX: u32 = 162;
pub const I2S0O_DATA_OUT23_IDX: u32 = 163;
pub const I2S1I_BCK_IN_IDX: u32 = 164;
pub const I2S1I_BCK_OUT_IDX: u32 = 164;
pub const I2S1I_WS_IN_IDX: u32 = 165;
pub const I2S1I_WS_OUT_IDX: u32 = 165;
pub const I2S1I_DATA_IN0_IDX: u32 = 166;
pub const I2S1O_DATA_OUT0_IDX: u32 = 166;
pub const I2S1I_DATA_IN1_IDX: u32 = 167;
pub const I2S1O_DATA_OUT1_IDX: u32 = 167;
pub const I2S1I_DATA_IN2_IDX: u32 = 168;
pub const I2S1O_DATA_OUT2_IDX: u32 = 168;
pub const I2S1I_DATA_IN3_IDX: u32 = 169;
pub const I2S1O_DATA_OUT3_IDX: u32 = 169;
pub const I2S1I_DATA_IN4_IDX: u32 = 170;
pub const I2S1O_DATA_OUT4_IDX: u32 = 170;
pub const I2S1I_DATA_IN5_IDX: u32 = 171;
pub const I2S1O_DATA_OUT5_IDX: u32 = 171;
pub const I2S1I_DATA_IN6_IDX: u32 = 172;
pub const I2S1O_DATA_OUT6_IDX: u32 = 172;
pub const I2S1I_DATA_IN7_IDX: u32 = 173;
pub const I2S1O_DATA_OUT7_IDX: u32 = 173;
pub const I2S1I_DATA_IN8_IDX: u32 = 174;
pub const I2S1O_DATA_OUT8_IDX: u32 = 174;
pub const I2S1I_DATA_IN9_IDX: u32 = 175;
pub const I2S1O_DATA_OUT9_IDX: u32 = 175;
pub const I2S1I_DATA_IN10_IDX: u32 = 176;
pub const I2S1O_DATA_OUT10_IDX: u32 = 176;
pub const I2S1I_DATA_IN11_IDX: u32 = 177;
pub const I2S1O_DATA_OUT11_IDX: u32 = 177;
pub const I2S1I_DATA_IN12_IDX: u32 = 178;
pub const I2S1O_DATA_OUT12_IDX: u32 = 178;
pub const I2S1I_DATA_IN13_IDX: u32 = 179;
pub const I2S1O_DATA_OUT13_IDX: u32 = 179;
pub const I2S1I_DATA_IN14_IDX: u32 = 180;
pub const I2S1O_DATA_OUT14_IDX: u32 = 180;
pub const I2S1I_DATA_IN15_IDX: u32 = 181;
pub const I2S1O_DATA_OUT15_IDX: u32 = 181;
pub const I2S1O_DATA_OUT16_IDX: u32 = 182;
pub const I2S1O_DATA_OUT17_IDX: u32 = 183;
pub const I2S1O_DATA_OUT18_IDX: u32 = 184;
pub const I2S1O_DATA_OUT19_IDX: u32 = 185;
pub const I2S1O_DATA_OUT20_IDX: u32 = 186;
pub const I2S1O_DATA_OUT21_IDX: u32 = 187;
pub const I2S1O_DATA_OUT22_IDX: u32 = 188;
pub const I2S1O_DATA_OUT23_IDX: u32 = 189;
pub const I2S0I_H_SYNC_IDX: u32 = 190;
pub const PWM3_OUT1H_IDX: u32 = 190;
pub const I2S0I_V_SYNC_IDX: u32 = 191;
pub const PWM3_OUT1L_IDX: u32 = 191;
pub const I2S0I_H_ENABLE_IDX: u32 = 192;
pub const PWM3_OUT2H_IDX: u32 = 192;
pub const I2S1I_H_SYNC_IDX: u32 = 193;
pub const PWM3_OUT2L_IDX: u32 = 193;
pub const I2S1I_V_SYNC_IDX: u32 = 194;
pub const PWM3_OUT3H_IDX: u32 = 194;
pub const I2S1I_H_ENABLE_IDX: u32 = 195;
pub const PWM3_OUT3L_IDX: u32 = 195;
pub const PWM3_OUT4H_IDX: u32 = 196;
pub const PWM3_OUT4L_IDX: u32 = 197;
pub const U2RXD_IN_IDX: u32 = 198;
pub const U2TXD_OUT_IDX: u32 = 198;
pub const U2CTS_IN_IDX: u32 = 199;
pub const U2RTS_OUT_IDX: u32 = 199;
pub const EMAC_MDC_I_IDX: u32 = 200;
pub const EMAC_MDC_O_IDX: u32 = 200;
pub const EMAC_MDI_I_IDX: u32 = 201;
pub const EMAC_MDO_O_IDX: u32 = 201;
pub const EMAC_CRS_I_IDX: u32 = 202;
pub const EMAC_CRS_O_IDX: u32 = 202;
pub const EMAC_COL_I_IDX: u32 = 203;
pub const EMAC_COL_O_IDX: u32 = 203;
pub const PCMFSYNC_IN_IDX: u32 = 204;
pub const BT_AUDIO0_IRQ_IDX: u32 = 204;
pub const PCMCLK_IN_IDX: u32 = 205;
pub const BT_AUDIO1_IRQ_IDX: u32 = 205;
pub const PCMDIN_IDX: u32 = 206;
pub const BT_AUDIO2_IRQ_IDX: u32 = 206;
pub const BLE_AUDIO0_IRQ_IDX: u32 = 207;
pub const BLE_AUDIO1_IRQ_IDX: u32 = 208;
pub const BLE_AUDIO2_IRQ_IDX: u32 = 209;
pub const PCMFSYNC_OUT_IDX: u32 = 210;
pub const PCMCLK_OUT_IDX: u32 = 211;
pub const PCMDOUT_IDX: u32 = 212;
pub const BLE_AUDIO_SYNC0_P_IDX: u32 = 213;
pub const BLE_AUDIO_SYNC1_P_IDX: u32 = 214;
pub const BLE_AUDIO_SYNC2_P_IDX: u32 = 215;
pub const ANT_SEL0_IDX: u32 = 216;
pub const ANT_SEL1_IDX: u32 = 217;
pub const ANT_SEL2_IDX: u32 = 218;
pub const ANT_SEL3_IDX: u32 = 219;
pub const ANT_SEL4_IDX: u32 = 220;
pub const ANT_SEL5_IDX: u32 = 221;
pub const ANT_SEL6_IDX: u32 = 222;
pub const ANT_SEL7_IDX: u32 = 223;
pub const SIG_IN_FUNC224_IDX: u32 = 224;
pub const SIG_IN_FUNC225_IDX: u32 = 225;
pub const SIG_IN_FUNC226_IDX: u32 = 226;
pub const SIG_IN_FUNC227_IDX: u32 = 227;
pub const SIG_IN_FUNC228_IDX: u32 = 228;
pub const SIG_GPIO_OUT_IDX: u32 = 256;
pub const GPIO_PIN_REG_0: u32 = 1072992324;
pub const GPIO_PIN_REG_1: u32 = 1072992392;
pub const GPIO_PIN_REG_2: u32 = 1072992320;
pub const GPIO_PIN_REG_3: u32 = 1072992388;
pub const GPIO_PIN_REG_4: u32 = 1072992328;
pub const GPIO_PIN_REG_5: u32 = 1072992364;
pub const GPIO_PIN_REG_6: u32 = 1072992352;
pub const GPIO_PIN_REG_7: u32 = 1072992356;
pub const GPIO_PIN_REG_8: u32 = 1072992360;
pub const GPIO_PIN_REG_9: u32 = 1072992340;
pub const GPIO_PIN_REG_10: u32 = 1072992344;
pub const GPIO_PIN_REG_11: u32 = 1072992348;
pub const GPIO_PIN_REG_12: u32 = 1072992308;
pub const GPIO_PIN_REG_13: u32 = 1072992312;
pub const GPIO_PIN_REG_14: u32 = 1072992304;
pub const GPIO_PIN_REG_15: u32 = 1072992316;
pub const GPIO_PIN_REG_16: u32 = 1072992332;
pub const GPIO_PIN_REG_17: u32 = 1072992336;
pub const GPIO_PIN_REG_18: u32 = 1072992368;
pub const GPIO_PIN_REG_19: u32 = 1072992372;
pub const GPIO_PIN_REG_20: u32 = 1072992376;
pub const GPIO_PIN_REG_21: u32 = 1072992380;
pub const GPIO_PIN_REG_22: u32 = 1072992384;
pub const GPIO_PIN_REG_23: u32 = 1072992396;
pub const GPIO_PIN_REG_25: u32 = 1072992292;
pub const GPIO_PIN_REG_26: u32 = 1072992296;
pub const GPIO_PIN_REG_27: u32 = 1072992300;
pub const GPIO_PIN_REG_32: u32 = 1072992284;
pub const GPIO_PIN_REG_33: u32 = 1072992288;
pub const GPIO_PIN_REG_34: u32 = 1072992276;
pub const GPIO_PIN_REG_35: u32 = 1072992280;
pub const GPIO_PIN_REG_36: u32 = 1072992260;
pub const GPIO_PIN_REG_37: u32 = 1072992264;
pub const GPIO_PIN_REG_38: u32 = 1072992268;
pub const GPIO_PIN_REG_39: u32 = 1072992272;
pub const GPIO_MODE_DEF_DISABLE: u32 = 0;
pub const GPIO_MODE_DEF_INPUT: u32 = 1;
pub const GPIO_MODE_DEF_OUTPUT: u32 = 2;
pub const GPIO_MODE_DEF_OD: u32 = 4;
pub const LOG_LOCAL_LEVEL: u32 = 3;
pub const MYNEWT_VAL_HARDFLOAT: u32 = 0;
pub const MYNEWT_VAL_BSP_NRF52840: u32 = 1;
pub const MYNEWT_VAL_I2C_0_FREQ_KHZ: u32 = 100;
pub const MYNEWT_VAL_I2C_0_PIN_SCL: u32 = 27;
pub const MYNEWT_VAL_I2C_0_PIN_SDA: u32 = 26;
pub const MYNEWT_VAL_PWM_3: u32 = 0;
pub const MYNEWT_VAL_SPI_0_MASTER_PIN_MISO: u32 = 47;
pub const MYNEWT_VAL_SPI_0_MASTER_PIN_MOSI: u32 = 46;
pub const MYNEWT_VAL_SPI_0_MASTER_PIN_SCK: u32 = 45;
pub const MYNEWT_VAL_SPI_0_SLAVE_PIN_MISO: u32 = 47;
pub const MYNEWT_VAL_SPI_0_SLAVE_PIN_MOSI: u32 = 46;
pub const MYNEWT_VAL_SPI_0_SLAVE_PIN_SCK: u32 = 45;
pub const MYNEWT_VAL_SPI_0_SLAVE_PIN_SS: u32 = 44;
pub const MYNEWT_VAL_TIMER_0: u32 = 0;
pub const MYNEWT_VAL_TIMER_1: u32 = 0;
pub const MYNEWT_VAL_TIMER_2: u32 = 0;
pub const MYNEWT_VAL_TIMER_3: u32 = 0;
pub const MYNEWT_VAL_TIMER_4: u32 = 0;
pub const MYNEWT_VAL_TIMER_5: u32 = 1;
pub const MYNEWT_VAL_UART_0: u32 = 1;
pub const MYNEWT_VAL_UART_0_PIN_CTS: u32 = 7;
pub const MYNEWT_VAL_UART_0_PIN_RTS: u32 = 5;
pub const MYNEWT_VAL_UART_0_PIN_RX: u32 = 8;
pub const MYNEWT_VAL_UART_0_PIN_TX: u32 = 6;
pub const MYNEWT_VAL_UART_1: u32 = 0;
pub const MYNEWT_VAL_UART_1_PIN_CTS: i32 = -1;
pub const MYNEWT_VAL_UART_1_PIN_RTS: i32 = -1;
pub const MYNEWT_VAL_UART_1_PIN_RX: i32 = -1;
pub const MYNEWT_VAL_UART_1_PIN_TX: i32 = -1;
pub const MYNEWT_VAL_ADC_0: u32 = 0;
pub const MYNEWT_VAL_ADC_0_REFMV_0: u32 = 0;
pub const MYNEWT_VAL_I2C_0: u32 = 0;
pub const MYNEWT_VAL_I2C_1: u32 = 0;
pub const MYNEWT_VAL_MCU_DCDC_ENABLED: u32 = 1;
pub const MYNEWT_VAL_MCU_FLASH_MIN_WRITE_SIZE: u32 = 1;
pub const MYNEWT_VAL_PWM_0: u32 = 0;
pub const MYNEWT_VAL_PWM_1: u32 = 0;
pub const MYNEWT_VAL_PWM_2: u32 = 0;
pub const MYNEWT_VAL_QSPI_ADDRMODE: u32 = 0;
pub const MYNEWT_VAL_QSPI_DPMCONFIG: u32 = 0;
pub const MYNEWT_VAL_QSPI_ENABLE: u32 = 0;
pub const MYNEWT_VAL_QSPI_FLASH_PAGE_SIZE: u32 = 256;
pub const MYNEWT_VAL_QSPI_FLASH_SECTOR_COUNT: u32 = 4096;
pub const MYNEWT_VAL_QSPI_FLASH_SECTOR_SIZE: u32 = 4096;
pub const MYNEWT_VAL_QSPI_PIN_CS: u32 = 17;
pub const MYNEWT_VAL_QSPI_PIN_DIO0: u32 = 20;
pub const MYNEWT_VAL_QSPI_PIN_DIO1: u32 = 21;
pub const MYNEWT_VAL_QSPI_PIN_DIO2: u32 = 22;
pub const MYNEWT_VAL_QSPI_PIN_DIO3: u32 = 23;
pub const MYNEWT_VAL_QSPI_PIN_SCK: u32 = 19;
pub const MYNEWT_VAL_QSPI_READOC: u32 = 0;
pub const MYNEWT_VAL_QSPI_SCK_DELAY: u32 = 0;
pub const MYNEWT_VAL_QSPI_SCK_FREQ: u32 = 0;
pub const MYNEWT_VAL_QSPI_SPI_MODE: u32 = 0;
pub const MYNEWT_VAL_QSPI_WRITEOC: u32 = 0;
pub const MYNEWT_VAL_SOFT_PWM: u32 = 0;
pub const MYNEWT_VAL_SPI_0_MASTER: u32 = 0;
pub const MYNEWT_VAL_SPI_0_SLAVE: u32 = 0;
pub const MYNEWT_VAL_SPI_1_MASTER: u32 = 0;
pub const MYNEWT_VAL_SPI_1_SLAVE: u32 = 0;
pub const MYNEWT_VAL_SPI_2_MASTER: u32 = 0;
pub const MYNEWT_VAL_SPI_2_SLAVE: u32 = 0;
pub const MYNEWT_VAL_XTAL_32768: u32 = 1;
pub const MYNEWT_VAL_XTAL_32768_SYNTH: u32 = 0;
pub const MYNEWT_VAL_XTAL_RC: u32 = 0;
pub const MYNEWT_VAL_FLOAT_USER: u32 = 0;
pub const MYNEWT_VAL_MSYS_1_BLOCK_COUNT: u32 = 12;
pub const MYNEWT_VAL_MSYS_1_BLOCK_SIZE: u32 = 292;
pub const MYNEWT_VAL_MSYS_2_BLOCK_COUNT: u32 = 0;
pub const MYNEWT_VAL_MSYS_2_BLOCK_SIZE: u32 = 0;
pub const MYNEWT_VAL_OS_CLI: u32 = 0;
pub const MYNEWT_VAL_OS_COREDUMP: u32 = 0;
pub const MYNEWT_VAL_OS_CPUTIME_FREQ: u32 = 32768;
pub const MYNEWT_VAL_OS_CPUTIME_TIMER_NUM: u32 = 5;
pub const MYNEWT_VAL_OS_CTX_SW_STACK_CHECK: u32 = 0;
pub const MYNEWT_VAL_OS_CTX_SW_STACK_GUARD: u32 = 4;
pub const MYNEWT_VAL_OS_MAIN_STACK_SIZE: u32 = 1024;
pub const MYNEWT_VAL_OS_MAIN_TASK_PRIO: u32 = 127;
pub const MYNEWT_VAL_OS_MEMPOOL_CHECK: u32 = 0;
pub const MYNEWT_VAL_OS_MEMPOOL_POISON: u32 = 0;
pub const MYNEWT_VAL_OS_SCHEDULING: u32 = 1;
pub const MYNEWT_VAL_OS_SYSVIEW: u32 = 0;
pub const MYNEWT_VAL_SANITY_INTERVAL: u32 = 15000;
pub const MYNEWT_VAL_WATCHDOG_INTERVAL: u32 = 30000;
pub const MYNEWT_VAL_BASELIBC_ASSERT_FILE_LINE: u32 = 0;
pub const MYNEWT_VAL_BASELIBC_PRESENT: u32 = 1;
pub const MYNEWT_VAL_BLE_EXT_ADV: u32 = 0;
pub const MYNEWT_VAL_BLE_EXT_ADV_MAX_SIZE: u32 = 31;
pub const MYNEWT_VAL_BLE_MAX_CONNECTIONS: u32 = 1;
pub const MYNEWT_VAL_BLE_MULTI_ADV_INSTANCES: u32 = 0;
pub const MYNEWT_VAL_BLE_ROLE_BROADCASTER: u32 = 1;
pub const MYNEWT_VAL_BLE_ROLE_CENTRAL: u32 = 1;
pub const MYNEWT_VAL_BLE_ROLE_OBSERVER: u32 = 1;
pub const MYNEWT_VAL_BLE_ROLE_PERIPHERAL: u32 = 1;
pub const MYNEWT_VAL_BLE_WHITELIST: u32 = 1;
pub const MYNEWT_VAL_BLE_CONTROLLER: u32 = 1;
pub const MYNEWT_VAL_BLE_HW_WHITELIST_ENABLE: u32 = 0;
pub const MYNEWT_VAL_BLE_LL_ADD_STRICT_SCHED_PERIODS: u32 = 0;
pub const MYNEWT_VAL_BLE_LL_CFG_FEAT_CONN_PARAM_REQ: u32 = 1;
pub const MYNEWT_VAL_BLE_LL_CFG_FEAT_DATA_LEN_EXT: u32 = 1;
pub const MYNEWT_VAL_BLE_LL_CFG_FEAT_EXT_SCAN_FILT: u32 = 0;
pub const MYNEWT_VAL_BLE_LL_CFG_FEAT_LE_2M_PHY: u32 = 0;
pub const MYNEWT_VAL_BLE_LL_CFG_FEAT_LE_CODED_PHY: u32 = 0;
pub const MYNEWT_VAL_BLE_LL_CFG_FEAT_LE_CSA2: u32 = 1;
pub const MYNEWT_VAL_BLE_LL_CFG_FEAT_LE_ENCRYPTION: u32 = 1;
pub const MYNEWT_VAL_BLE_LL_CFG_FEAT_LE_PING: u32 = 1;
pub const MYNEWT_VAL_BLE_LL_CFG_FEAT_LL_EXT_ADV: u32 = 0;
pub const MYNEWT_VAL_BLE_LL_CFG_FEAT_LL_PRIVACY: u32 = 1;
pub const MYNEWT_VAL_BLE_LL_CFG_FEAT_SLAVE_INIT_FEAT_XCHG: u32 = 1;
pub const MYNEWT_VAL_BLE_LL_CONN_INIT_MAX_TX_BYTES: u32 = 27;
pub const MYNEWT_VAL_BLE_LL_CONN_INIT_MIN_WIN_OFFSET: u32 = 0;
pub const MYNEWT_VAL_BLE_LL_CONN_INIT_SLOTS: u32 = 4;
pub const MYNEWT_VAL_BLE_LL_DIRECT_TEST_MODE: u32 = 0;
pub const MYNEWT_VAL_BLE_LL_EXT_ADV_AUX_PTR_CNT: u32 = 5;
pub const MYNEWT_VAL_BLE_LL_MASTER_SCA: u32 = 4;
pub const MYNEWT_VAL_BLE_LL_MAX_PKT_SIZE: u32 = 251;
pub const MYNEWT_VAL_BLE_LL_MFRG_ID: u32 = 65535;
pub const MYNEWT_VAL_BLE_LL_NUM_SCAN_DUP_ADVS: u32 = 8;
pub const MYNEWT_VAL_BLE_LL_NUM_SCAN_RSP_ADVS: u32 = 8;
pub const MYNEWT_VAL_BLE_LL_OUR_SCA: u32 = 60;
pub const MYNEWT_VAL_BLE_LL_PRIO: u32 = 0;
pub const MYNEWT_VAL_BLE_LL_RESOLV_LIST_SIZE: u32 = 4;
pub const MYNEWT_VAL_BLE_LL_RNG_BUFSIZE: u32 = 32;
pub const MYNEWT_VAL_BLE_LL_STRICT_CONN_SCHEDULING: u32 = 0;
pub const MYNEWT_VAL_BLE_LL_SUPP_MAX_RX_BYTES: u32 = 251;
pub const MYNEWT_VAL_BLE_LL_SUPP_MAX_TX_BYTES: u32 = 251;
pub const MYNEWT_VAL_BLE_LL_TX_PWR_DBM: u32 = 0;
pub const MYNEWT_VAL_BLE_LL_USECS_PER_PERIOD: u32 = 3250;
pub const MYNEWT_VAL_BLE_LL_WHITELIST_SIZE: u32 = 8;
pub const MYNEWT_VAL_BLE_LP_CLOCK: u32 = 1;
pub const MYNEWT_VAL_BLE_NUM_COMP_PKT_RATE: u32 = 256;
pub const MYNEWT_VAL_BLE_XTAL_SETTLE_TIME: u32 = 1500;
pub const MYNEWT_VAL_BLE_PHY_CODED_RX_IFS_EXTRA_MARGIN: u32 = 0;
pub const MYNEWT_VAL_BLE_PHY_DBG_TIME_ADDRESS_END_PIN: i32 = -1;
pub const MYNEWT_VAL_BLE_PHY_DBG_TIME_TXRXEN_READY_PIN: i32 = -1;
pub const MYNEWT_VAL_BLE_PHY_DBG_TIME_WFR_PIN: i32 = -1;
pub const MYNEWT_VAL_BLE_PHY_NRF52840_ERRATA_164: u32 = 0;
pub const MYNEWT_VAL_BLE_PHY_NRF52840_ERRATA_191: u32 = 1;
pub const MYNEWT_VAL_BLE_ATT_PREFERRED_MTU: u32 = 256;
pub const MYNEWT_VAL_BLE_ATT_SVR_FIND_INFO: u32 = 1;
pub const MYNEWT_VAL_BLE_ATT_SVR_FIND_TYPE: u32 = 1;
pub const MYNEWT_VAL_BLE_ATT_SVR_INDICATE: u32 = 1;
pub const MYNEWT_VAL_BLE_ATT_SVR_MAX_PREP_ENTRIES: u32 = 64;
pub const MYNEWT_VAL_BLE_ATT_SVR_NOTIFY: u32 = 1;
pub const MYNEWT_VAL_BLE_ATT_SVR_QUEUED_WRITE: u32 = 1;
pub const MYNEWT_VAL_BLE_ATT_SVR_QUEUED_WRITE_TMO: u32 = 30000;
pub const MYNEWT_VAL_BLE_ATT_SVR_READ: u32 = 1;
pub const MYNEWT_VAL_BLE_ATT_SVR_READ_BLOB: u32 = 1;
pub const MYNEWT_VAL_BLE_ATT_SVR_READ_GROUP_TYPE: u32 = 1;
pub const MYNEWT_VAL_BLE_ATT_SVR_READ_MULT: u32 = 1;
pub const MYNEWT_VAL_BLE_ATT_SVR_READ_TYPE: u32 = 1;
pub const MYNEWT_VAL_BLE_ATT_SVR_SIGNED_WRITE: u32 = 1;
pub const MYNEWT_VAL_BLE_ATT_SVR_WRITE: u32 = 1;
pub const MYNEWT_VAL_BLE_ATT_SVR_WRITE_NO_RSP: u32 = 1;
pub const MYNEWT_VAL_BLE_GAP_MAX_PENDING_CONN_PARAM_UPDATE: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_DISC_ALL_CHRS: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_DISC_ALL_DSCS: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_DISC_ALL_SVCS: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_DISC_CHR_UUID: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_DISC_SVC_UUID: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_FIND_INC_SVCS: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_INDICATE: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_MAX_PROCS: u32 = 4;
pub const MYNEWT_VAL_BLE_GATT_NOTIFY: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_READ: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_READ_LONG: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_READ_MAX_ATTRS: u32 = 8;
pub const MYNEWT_VAL_BLE_GATT_READ_MULT: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_READ_UUID: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_RESUME_RATE: u32 = 1000;
pub const MYNEWT_VAL_BLE_GATT_SIGNED_WRITE: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_WRITE: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_WRITE_LONG: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_WRITE_MAX_ATTRS: u32 = 4;
pub const MYNEWT_VAL_BLE_GATT_WRITE_NO_RSP: u32 = 1;
pub const MYNEWT_VAL_BLE_GATT_WRITE_RELIABLE: u32 = 1;
pub const MYNEWT_VAL_BLE_HOST: u32 = 1;
pub const MYNEWT_VAL_BLE_HS_DEBUG: u32 = 0;
pub const MYNEWT_VAL_BLE_HS_AUTO_START: u32 = 1;
pub const MYNEWT_VAL_BLE_HS_FLOW_CTRL: u32 = 0;
pub const MYNEWT_VAL_BLE_HS_FLOW_CTRL_ITVL: u32 = 1000;
pub const MYNEWT_VAL_BLE_HS_FLOW_CTRL_THRESH: u32 = 2;
pub const MYNEWT_VAL_BLE_HS_FLOW_CTRL_TX_ON_DISCONNECT: u32 = 0;
pub const MYNEWT_VAL_BLE_HS_PHONY_HCI_ACKS: u32 = 0;
pub const MYNEWT_VAL_BLE_HS_REQUIRE_OS: u32 = 1;
pub const MYNEWT_VAL_BLE_L2CAP_COC_MAX_NUM: u32 = 0;
pub const MYNEWT_VAL_BLE_L2CAP_COC_MPS: u32 = 284;
pub const MYNEWT_VAL_BLE_L2CAP_JOIN_RX_FRAGS: u32 = 1;
pub const MYNEWT_VAL_BLE_L2CAP_MAX_CHANS: u32 = 3;
pub const MYNEWT_VAL_BLE_L2CAP_RX_FRAG_TIMEOUT: u32 = 30000;
pub const MYNEWT_VAL_BLE_L2CAP_SIG_MAX_PROCS: u32 = 1;
pub const MYNEWT_VAL_BLE_MESH: u32 = 0;
pub const MYNEWT_VAL_BLE_MONITOR_CONSOLE_BUFFER_SIZE: u32 = 128;
pub const MYNEWT_VAL_BLE_MONITOR_RTT: u32 = 0;
pub const MYNEWT_VAL_BLE_MONITOR_RTT_BUFFERED: u32 = 1;
pub const MYNEWT_VAL_BLE_MONITOR_RTT_BUFFER_NAME: &'static [u8; 8usize] = b"monitor\0";
pub const MYNEWT_VAL_BLE_MONITOR_RTT_BUFFER_SIZE: u32 = 256;
pub const MYNEWT_VAL_BLE_MONITOR_UART: u32 = 0;
pub const MYNEWT_VAL_BLE_MONITOR_UART_BAUDRATE: u32 = 1000000;
pub const MYNEWT_VAL_BLE_MONITOR_UART_BUFFER_SIZE: u32 = 64;
pub const MYNEWT_VAL_BLE_MONITOR_UART_DEV: &'static [u8; 6usize] = b"uart0\0";
pub const MYNEWT_VAL_BLE_RPA_TIMEOUT: u32 = 300;
pub const MYNEWT_VAL_BLE_SM_BONDING: u32 = 0;
pub const MYNEWT_VAL_BLE_SM_KEYPRESS: u32 = 0;
pub const MYNEWT_VAL_BLE_SM_LEGACY: u32 = 1;
pub const MYNEWT_VAL_BLE_SM_MAX_PROCS: u32 = 1;
pub const MYNEWT_VAL_BLE_SM_MITM: u32 = 0;
pub const MYNEWT_VAL_BLE_SM_OOB_DATA_FLAG: u32 = 0;
pub const MYNEWT_VAL_BLE_SM_OUR_KEY_DIST: u32 = 0;
pub const MYNEWT_VAL_BLE_SM_SC: u32 = 0;
pub const MYNEWT_VAL_BLE_SM_THEIR_KEY_DIST: u32 = 0;
pub const MYNEWT_VAL_BLE_STORE_MAX_BONDS: u32 = 3;
pub const MYNEWT_VAL_BLE_STORE_MAX_CCCDS: u32 = 8;
pub const MYNEWT_VAL_BLE_SVC_ANS_NEW_ALERT_CAT: u32 = 0;
pub const MYNEWT_VAL_BLE_SVC_ANS_UNR_ALERT_CAT: u32 = 0;
pub const MYNEWT_VAL_BLE_SVC_BAS_BATTERY_LEVEL_NOTIFY_ENABLE: u32 = 1;
pub const MYNEWT_VAL_BLE_SVC_BAS_BATTERY_LEVEL_READ_PERM: u32 = 0;
pub const MYNEWT_VAL_BLE_SVC_GAP_APPEARANCE: u32 = 0;
pub const MYNEWT_VAL_BLE_SVC_GAP_APPEARANCE_WRITE_PERM: i32 = -1;
pub const MYNEWT_VAL_BLE_SVC_GAP_CENTRAL_ADDRESS_RESOLUTION: i32 = -1;
pub const MYNEWT_VAL_BLE_SVC_GAP_DEVICE_NAME: &'static [u8; 7usize] = b"nimble\0";
pub const MYNEWT_VAL_BLE_SVC_GAP_DEVICE_NAME_MAX_LENGTH: u32 = 31;
pub const MYNEWT_VAL_BLE_SVC_GAP_DEVICE_NAME_WRITE_PERM: i32 = -1;
pub const MYNEWT_VAL_BLE_SVC_GAP_PPCP_MAX_CONN_INTERVAL: u32 = 0;
pub const MYNEWT_VAL_BLE_SVC_GAP_PPCP_MIN_CONN_INTERVAL: u32 = 0;
pub const MYNEWT_VAL_BLE_SVC_GAP_PPCP_SLAVE_LATENCY: u32 = 0;
pub const MYNEWT_VAL_BLE_SVC_GAP_PPCP_SUPERVISION_TMO: u32 = 0;
pub const MYNEWT_VAL_BLE_HCI_TRANSPORT_EMSPI: u32 = 0;
pub const MYNEWT_VAL_BLE_HCI_TRANSPORT_NIMBLE_BUILTIN: u32 = 1;
pub const MYNEWT_VAL_BLE_HCI_TRANSPORT_RAM: u32 = 0;
pub const MYNEWT_VAL_BLE_HCI_TRANSPORT_SOCKET: u32 = 0;
pub const MYNEWT_VAL_BLE_HCI_TRANSPORT_UART: u32 = 0;
pub const MYNEWT_VAL_BLE_ACL_BUF_COUNT: u32 = 4;
pub const MYNEWT_VAL_BLE_ACL_BUF_SIZE: u32 = 255;
pub const MYNEWT_VAL_BLE_HCI_EVT_BUF_SIZE: u32 = 70;
pub const MYNEWT_VAL_BLE_HCI_EVT_HI_BUF_COUNT: u32 = 2;
pub const MYNEWT_VAL_BLE_HCI_EVT_LO_BUF_COUNT: u32 = 8;
pub const MYNEWT_VAL_CONSOLE_UART_BAUD: u32 = 115200;
pub const MYNEWT_VAL_CONSOLE_UART_DEV: &'static [u8; 6usize] = b"uart0\0";
pub const MYNEWT_VAL_FLASH_MAP_MAX_AREAS: u32 = 10;
pub const MYNEWT_VAL_LOG_CONSOLE: u32 = 1;
pub const MYNEWT_VAL_LOG_FCB: u32 = 0;
pub const MYNEWT_VAL_LOG_LEVEL: u32 = 255;
pub const MYNEWT_VAL_SYSINIT_CONSTRAIN_INIT: u32 = 1;
pub const MYNEWT_VAL_SYSINIT_PANIC_FILE_LINE: u32 = 0;
pub const MYNEWT_VAL_SYSINIT_PANIC_MESSAGE: u32 = 0;
pub const BLE_NPL_OS_ALIGNMENT: u32 = 4;
pub const OS_ALIGNMENT: u32 = 4;
pub const OS_MEMPOOL_F_EXT: u32 = 1;
pub const OS_MEMPOOL_INFO_NAME_LEN: u32 = 32;
pub const BLE_HCI_TRANS_CMD_SZ: u32 = 260;
pub const BLE_HCI_TRANS_BUF_EVT_LO: u32 = 1;
pub const BLE_HCI_TRANS_BUF_EVT_HI: u32 = 2;
pub const BLE_HCI_TRANS_BUF_CMD: u32 = 3;
pub const BLE_HCI_UART_H4_NONE: u32 = 0;
pub const BLE_HCI_UART_H4_CMD: u32 = 1;
pub const BLE_HCI_UART_H4_ACL: u32 = 2;
pub const BLE_HCI_UART_H4_SCO: u32 = 3;
pub const BLE_HCI_UART_H4_EVT: u32 = 4;
pub const NIMBLE_STACK_SIZE: u32 = 4096;
pub const NIMBLE_PORT_DEINIT_EV_ARG: i32 = -1;
pub const BLE_ENC_BLOCK_SIZE: u32 = 16;
pub const BLE_ACL_MAX_PKT_SIZE: u32 = 255;
pub const BLE_MBUF_HDR_F_INITA_RESOLVED: u32 = 8192;
pub const BLE_MBUF_HDR_F_EXT_ADV_SEC: u32 = 4096;
pub const BLE_MBUF_HDR_F_EXT_ADV: u32 = 2048;
pub const BLE_MBUF_HDR_F_RESOLVED: u32 = 1024;
pub const BLE_MBUF_HDR_F_AUX_PTR_WAIT: u32 = 512;
pub const BLE_MBUF_HDR_F_AUX_INVALID: u32 = 256;
pub const BLE_MBUF_HDR_F_CRC_OK: u32 = 128;
pub const BLE_MBUF_HDR_F_DEVMATCH: u32 = 64;
pub const BLE_MBUF_HDR_F_MIC_FAILURE: u32 = 32;
pub const BLE_MBUF_HDR_F_SCAN_RSP_TXD: u32 = 16;
pub const BLE_MBUF_HDR_F_SCAN_RSP_CHK: u32 = 8;
pub const BLE_MBUF_HDR_F_RXSTATE_MASK: u32 = 7;
pub const BLE_MBUF_HS_HDR_LEN: u32 = 2;
pub const BLE_DEV_ADDR_LEN: u32 = 6;
pub const BLE_HW_ERR_DO_NOT_USE: u32 = 0;
pub const BLE_HW_ERR_HCI_SYNC_LOSS: u32 = 1;
pub const BLE_OWN_ADDR_PUBLIC: u32 = 0;
pub const BLE_OWN_ADDR_RANDOM: u32 = 1;
pub const BLE_OWN_ADDR_RPA_PUBLIC_DEFAULT: u32 = 2;
pub const BLE_OWN_ADDR_RPA_RANDOM_DEFAULT: u32 = 3;
pub const BLE_ADDR_PUBLIC: u32 = 0;
pub const BLE_ADDR_RANDOM: u32 = 1;
pub const BLE_ADDR_PUBLIC_ID: u32 = 2;
pub const BLE_ADDR_RANDOM_ID: u32 = 3;
pub const BLE_HCI_CMD_HDR_LEN: u32 = 3;
pub const BLE_HCI_OPCODE_NOP: u32 = 0;
pub const BLE_HCI_OGF_LINK_CTRL: u32 = 1;
pub const BLE_HCI_OGF_LINK_POLICY: u32 = 2;
pub const BLE_HCI_OGF_CTLR_BASEBAND: u32 = 3;
pub const BLE_HCI_OGF_INFO_PARAMS: u32 = 4;
pub const BLE_HCI_OGF_STATUS_PARAMS: u32 = 5;
pub const BLE_HCI_OGF_TESTING: u32 = 6;
pub const BLE_HCI_OGF_LE: u32 = 8;
pub const BLE_HCI_OGF_VENDOR: u32 = 63;
pub const BLE_HCI_NUM_LE_CMDS: u32 = 79;
pub const BLE_HCI_OCF_DISCONNECT_CMD: u32 = 6;
pub const BLE_HCI_OCF_RD_REM_VER_INFO: u32 = 29;
pub const BLE_HCI_OCF_CB_SET_EVENT_MASK: u32 = 1;
pub const BLE_HCI_OCF_CB_RESET: u32 = 3;
pub const BLE_HCI_OCF_CB_READ_TX_PWR: u32 = 45;
pub const BLE_HCI_OCF_CB_SET_CTLR_TO_HOST_FC: u32 = 49;
pub const BLE_HCI_OCF_CB_HOST_BUF_SIZE: u32 = 51;
pub const BLE_HCI_OCF_CB_HOST_NUM_COMP_PKTS: u32 = 53;
pub const BLE_HCI_OCF_CB_SET_EVENT_MASK2: u32 = 99;
pub const BLE_HCI_OCF_CB_RD_AUTH_PYLD_TMO: u32 = 123;
pub const BLE_HCI_OCF_CB_WR_AUTH_PYLD_TMO: u32 = 124;
pub const BLE_HCI_OCF_IP_RD_LOCAL_VER: u32 = 1;
pub const BLE_HCI_OCF_IP_RD_LOC_SUPP_CMD: u32 = 2;
pub const BLE_HCI_OCF_IP_RD_LOC_SUPP_FEAT: u32 = 3;
pub const BLE_HCI_OCF_IP_RD_BUF_SIZE: u32 = 5;
pub const BLE_HCI_OCF_IP_RD_BD_ADDR: u32 = 9;
pub const BLE_HCI_OCF_RD_RSSI: u32 = 5;
pub const BLE_HCI_OCF_LE_SET_EVENT_MASK: u32 = 1;
pub const BLE_HCI_OCF_LE_RD_BUF_SIZE: u32 = 2;
pub const BLE_HCI_OCF_LE_RD_LOC_SUPP_FEAT: u32 = 3;
pub const BLE_HCI_OCF_LE_SET_RAND_ADDR: u32 = 5;
pub const BLE_HCI_OCF_LE_SET_ADV_PARAMS: u32 = 6;
pub const BLE_HCI_OCF_LE_RD_ADV_CHAN_TXPWR: u32 = 7;
pub const BLE_HCI_OCF_LE_SET_ADV_DATA: u32 = 8;
pub const BLE_HCI_OCF_LE_SET_SCAN_RSP_DATA: u32 = 9;
pub const BLE_HCI_OCF_LE_SET_ADV_ENABLE: u32 = 10;
pub const BLE_HCI_OCF_LE_SET_SCAN_PARAMS: u32 = 11;
pub const BLE_HCI_OCF_LE_SET_SCAN_ENABLE: u32 = 12;
pub const BLE_HCI_OCF_LE_CREATE_CONN: u32 = 13;
pub const BLE_HCI_OCF_LE_CREATE_CONN_CANCEL: u32 = 14;
pub const BLE_HCI_OCF_LE_RD_WHITE_LIST_SIZE: u32 = 15;
pub const BLE_HCI_OCF_LE_CLEAR_WHITE_LIST: u32 = 16;
pub const BLE_HCI_OCF_LE_ADD_WHITE_LIST: u32 = 17;
pub const BLE_HCI_OCF_LE_RMV_WHITE_LIST: u32 = 18;
pub const BLE_HCI_OCF_LE_CONN_UPDATE: u32 = 19;
pub const BLE_HCI_OCF_LE_SET_HOST_CHAN_CLASS: u32 = 20;
pub const BLE_HCI_OCF_LE_RD_CHAN_MAP: u32 = 21;
pub const BLE_HCI_OCF_LE_RD_REM_FEAT: u32 = 22;
pub const BLE_HCI_OCF_LE_ENCRYPT: u32 = 23;
pub const BLE_HCI_OCF_LE_RAND: u32 = 24;
pub const BLE_HCI_OCF_LE_START_ENCRYPT: u32 = 25;
pub const BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY: u32 = 26;
pub const BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY: u32 = 27;
pub const BLE_HCI_OCF_LE_RD_SUPP_STATES: u32 = 28;
pub const BLE_HCI_OCF_LE_RX_TEST: u32 = 29;
pub const BLE_HCI_OCF_LE_TX_TEST: u32 = 30;
pub const BLE_HCI_OCF_LE_TEST_END: u32 = 31;
pub const BLE_HCI_OCF_LE_REM_CONN_PARAM_RR: u32 = 32;
pub const BLE_HCI_OCF_LE_REM_CONN_PARAM_NRR: u32 = 33;
pub const BLE_HCI_OCF_LE_SET_DATA_LEN: u32 = 34;
pub const BLE_HCI_OCF_LE_RD_SUGG_DEF_DATA_LEN: u32 = 35;
pub const BLE_HCI_OCF_LE_WR_SUGG_DEF_DATA_LEN: u32 = 36;
pub const BLE_HCI_OCF_LE_RD_P256_PUBKEY: u32 = 37;
pub const BLE_HCI_OCF_LE_GEN_DHKEY: u32 = 38;
pub const BLE_HCI_OCF_LE_ADD_RESOLV_LIST: u32 = 39;
pub const BLE_HCI_OCF_LE_RMV_RESOLV_LIST: u32 = 40;
pub const BLE_HCI_OCF_LE_CLR_RESOLV_LIST: u32 = 41;
pub const BLE_HCI_OCF_LE_RD_RESOLV_LIST_SIZE: u32 = 42;
pub const BLE_HCI_OCF_LE_RD_PEER_RESOLV_ADDR: u32 = 43;
pub const BLE_HCI_OCF_LE_RD_LOCAL_RESOLV_ADDR: u32 = 44;
pub const BLE_HCI_OCF_LE_SET_ADDR_RES_EN: u32 = 45;
pub const BLE_HCI_OCF_LE_SET_RPA_TMO: u32 = 46;
pub const BLE_HCI_OCF_LE_RD_MAX_DATA_LEN: u32 = 47;
pub const BLE_HCI_OCF_LE_RD_PHY: u32 = 48;
pub const BLE_HCI_OCF_LE_SET_DEFAULT_PHY: u32 = 49;
pub const BLE_HCI_OCF_LE_SET_PHY: u32 = 50;
pub const BLE_HCI_OCF_LE_ENH_RX_TEST: u32 = 51;
pub const BLE_HCI_OCF_LE_ENH_TX_TEST: u32 = 52;
pub const BLE_HCI_OCF_LE_SET_ADV_SET_RND_ADDR: u32 = 53;
pub const BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM: u32 = 54;
pub const BLE_HCI_OCF_LE_SET_EXT_ADV_DATA: u32 = 55;
pub const BLE_HCI_OCF_LE_SET_EXT_SCAN_RSP_DATA: u32 = 56;
pub const BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE: u32 = 57;
pub const BLE_HCI_OCF_LE_RD_MAX_ADV_DATA_LEN: u32 = 58;
pub const BLE_HCI_OCF_LE_RD_NUM_OF_ADV_SETS: u32 = 59;
pub const BLE_HCI_OCF_LE_REMOVE_ADV_SET: u32 = 60;
pub const BLE_HCI_OCF_LE_CLEAR_ADV_SETS: u32 = 61;
pub const BLE_HCI_OCF_LE_SET_PER_ADV_PARAMS: u32 = 62;
pub const BLE_HCI_OCF_LE_SET_PER_ADV_DATA: u32 = 63;
pub const BLE_HCI_OCF_LE_SET_PER_ADV_ENABLE: u32 = 64;
pub const BLE_HCI_OCF_LE_SET_EXT_SCAN_PARAM: u32 = 65;
pub const BLE_HCI_OCF_LE_SET_EXT_SCAN_ENABLE: u32 = 66;
pub const BLE_HCI_OCF_LE_EXT_CREATE_CONN: u32 = 67;
pub const BLE_HCI_OCF_LE_PER_ADV_CREATE_SYNC: u32 = 68;
pub const BLE_HCI_OCF_LE_PER_ADV_CREATE_SYNC_CANCEL: u32 = 69;
pub const BLE_HCI_OCF_LE_PER_ADV_TERM_SYNC: u32 = 70;
pub const BLE_HCI_OCF_LE_ADD_DEV_TO_PER_ADV_LIST: u32 = 71;
pub const BLE_HCI_OCF_LE_REM_DEV_FROM_PER_ADV_LIST: u32 = 72;
pub const BLE_HCI_OCF_LE_CLEAR_PER_ADV_LIST: u32 = 73;
pub const BLE_HCI_OCF_LE_RD_PER_ADV_LIST_SIZE: u32 = 74;
pub const BLE_HCI_OCF_LE_RD_TRANSMIT_POWER: u32 = 75;
pub const BLE_HCI_OCF_LE_RD_RF_PATH_COMPENSATION: u32 = 76;
pub const BLE_HCI_OCF_LE_WR_RF_PATH_COMPENSATION: u32 = 77;
pub const BLE_HCI_OCF_LE_SET_PRIVACY_MODE: u32 = 78;
pub const BLE_HCI_VARIABLE_LEN: u32 = 255;
pub const BLE_HCI_DISCONNECT_CMD_LEN: u32 = 3;
pub const BLE_HCI_SET_EVENT_MASK_LEN: u32 = 8;
pub const BLE_HCI_CTLR_TO_HOST_FC_LEN: u32 = 1;
pub const BLE_HCI_CTLR_TO_HOST_FC_OFF: u32 = 0;
pub const BLE_HCI_CTLR_TO_HOST_FC_ACL: u32 = 1;
pub const BLE_HCI_CTLR_TO_HOST_FC_SYNC: u32 = 2;
pub const BLE_HCI_CTLR_TO_HOST_FC_BOTH: u32 = 3;
pub const BLE_HCI_HOST_BUF_SIZE_LEN: u32 = 7;
pub const BLE_HCI_HOST_NUM_COMP_PKTS_HDR_LEN: u32 = 1;
pub const BLE_HCI_HOST_NUM_COMP_PKTS_ENT_LEN: u32 = 4;
pub const BLE_HCI_IP_RD_BD_ADDR_ACK_PARAM_LEN: u32 = 6;
pub const BLE_HCI_IP_RD_BUF_SIZE_LEN: u32 = 0;
pub const BLE_HCI_IP_RD_BUF_SIZE_RSPLEN: u32 = 7;
pub const BLE_HCI_RD_AUTH_PYLD_TMO_LEN: u32 = 4;
pub const BLE_HCI_WR_AUTH_PYLD_TMO_LEN: u32 = 2;
pub const BLE_HCI_RD_LOC_VER_INFO_RSPLEN: u32 = 8;
pub const BLE_HCI_RD_LOC_SUPP_CMD_RSPLEN: u32 = 64;
pub const BLE_HCI_RD_LOC_SUPP_FEAT_RSPLEN: u32 = 8;
pub const BLE_HCI_READ_RSSI_LEN: u32 = 2;
pub const BLE_HCI_READ_RSSI_ACK_PARAM_LEN: u32 = 3;
pub const BLE_HCI_SET_LE_EVENT_MASK_LEN: u32 = 8;
pub const BLE_HCI_RD_BUF_SIZE_LEN: u32 = 0;
pub const BLE_HCI_RD_BUF_SIZE_RSPLEN: u32 = 3;
pub const BLE_HCI_RD_LE_LOC_SUPP_FEAT_RSPLEN: u32 = 8;
pub const BLE_HCI_SET_RAND_ADDR_LEN: u32 = 6;
pub const BLE_HCI_SET_ADV_PARAM_LEN: u32 = 15;
pub const BLE_HCI_ADV_TYPE_ADV_IND: u32 = 0;
pub const BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD: u32 = 1;
pub const BLE_HCI_ADV_TYPE_ADV_SCAN_IND: u32 = 2;
pub const BLE_HCI_ADV_TYPE_ADV_NONCONN_IND: u32 = 3;
pub const BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD: u32 = 4;
pub const BLE_HCI_ADV_TYPE_MAX: u32 = 4;
pub const BLE_HCI_ADV_CONN_MASK: u32 = 1;
pub const BLE_HCI_ADV_SCAN_MASK: u32 = 2;
pub const BLE_HCI_ADV_DIRECT_MASK: u32 = 4;
pub const BLE_HCI_ADV_SCAN_RSP_MASK: u32 = 8;
pub const BLE_HCI_ADV_LEGACY_MASK: u32 = 16;
pub const BLE_HCI_ADV_DATA_STATUS_COMPLETE: u32 = 0;
pub const BLE_HCI_ADV_DATA_STATUS_INCOMPLETE: u32 = 32;
pub const BLE_HCI_ADV_DATA_STATUS_TRUNCATED: u32 = 64;
pub const BLE_HCI_ADV_DATA_STATUS_MASK: u32 = 96;
pub const BLE_HCI_ADV_OWN_ADDR_PUBLIC: u32 = 0;
pub const BLE_HCI_ADV_OWN_ADDR_RANDOM: u32 = 1;
pub const BLE_HCI_ADV_OWN_ADDR_PRIV_PUB: u32 = 2;
pub const BLE_HCI_ADV_OWN_ADDR_PRIV_RAND: u32 = 3;
pub const BLE_HCI_ADV_OWN_ADDR_MAX: u32 = 3;
pub const BLE_HCI_ADV_PEER_ADDR_PUBLIC: u32 = 0;
pub const BLE_HCI_ADV_PEER_ADDR_RANDOM: u32 = 1;
pub const BLE_HCI_ADV_PEER_ADDR_MAX: u32 = 1;
pub const BLE_HCI_ADV_CHAN_TXPWR_ACK_PARAM_LEN: u32 = 2;
pub const BLE_HCI_ADV_CHAN_TXPWR_MIN: i32 = -20;
pub const BLE_HCI_ADV_CHAN_TXPWR_MAX: u32 = 10;
pub const BLE_HCI_MAX_ADV_DATA_LEN: u32 = 31;
pub const BLE_HCI_SET_ADV_DATA_LEN: u32 = 32;
pub const BLE_HCI_MAX_SCAN_RSP_DATA_LEN: u32 = 31;
pub const BLE_HCI_SET_SCAN_RSP_DATA_LEN: u32 = 32;
pub const BLE_HCI_SET_ADV_ENABLE_LEN: u32 = 1;
pub const BLE_HCI_SET_SCAN_ENABLE_LEN: u32 = 2;
pub const BLE_HCI_CONN_PEER_ADDR_PUBLIC: u32 = 0;
pub const BLE_HCI_CONN_PEER_ADDR_RANDOM: u32 = 1;
pub const BLE_HCI_CONN_PEER_ADDR_PUBLIC_IDENT: u32 = 2;
pub const BLE_HCI_CONN_PEER_ADDR_RANDOM_IDENT: u32 = 3;
pub const BLE_HCI_CONN_PEER_ADDR_MAX: u32 = 3;
pub const BLE_HCI_ADV_FILT_NONE: u32 = 0;
pub const BLE_HCI_ADV_FILT_SCAN: u32 = 1;
pub const BLE_HCI_ADV_FILT_CONN: u32 = 2;
pub const BLE_HCI_ADV_FILT_BOTH: u32 = 3;
pub const BLE_HCI_ADV_FILT_MAX: u32 = 3;
pub const BLE_HCI_ADV_FILT_DEF: u32 = 0;
pub const BLE_HCI_ADV_ITVL: u32 = 625;
pub const BLE_HCI_ADV_ITVL_MIN: u32 = 32;
pub const BLE_HCI_ADV_ITVL_MAX: u32 = 16384;
pub const BLE_HCI_ADV_ITVL_NONCONN_MIN: u32 = 160;
pub const BLE_HCI_ADV_ITVL_DEF: u32 = 2048;
pub const BLE_HCI_ADV_CHANMASK_DEF: u32 = 7;
pub const BLE_HCI_SET_SCAN_PARAM_LEN: u32 = 7;
pub const BLE_HCI_SCAN_TYPE_PASSIVE: u32 = 0;
pub const BLE_HCI_SCAN_TYPE_ACTIVE: u32 = 1;
pub const BLE_HCI_SCAN_ITVL: u32 = 625;
pub const BLE_HCI_SCAN_ITVL_MIN: u32 = 4;
pub const BLE_HCI_SCAN_ITVL_MAX: u32 = 16384;
pub const BLE_HCI_SCAN_ITVL_DEF: u32 = 16;
pub const BLE_HCI_SCAN_WINDOW_MIN: u32 = 4;
pub const BLE_HCI_SCAN_WINDOW_MAX: u32 = 16384;
pub const BLE_HCI_SCAN_WINDOW_DEF: u32 = 16;
pub const BLE_HCI_SCAN_FILT_NO_WL: u32 = 0;
pub const BLE_HCI_SCAN_FILT_USE_WL: u32 = 1;
pub const BLE_HCI_SCAN_FILT_NO_WL_INITA: u32 = 2;
pub const BLE_HCI_SCAN_FILT_USE_WL_INITA: u32 = 3;
pub const BLE_HCI_SCAN_FILT_MAX: u32 = 3;
pub const BLE_HCI_ADD_WHITE_LIST_LEN: u32 = 7;
pub const BLE_HCI_RMV_WHITE_LIST_LEN: u32 = 7;
pub const BLE_HCI_CREATE_CONN_LEN: u32 = 25;
pub const BLE_HCI_CONN_ITVL: u32 = 1250;
pub const BLE_HCI_CONN_FILT_NO_WL: u32 = 0;
pub const BLE_HCI_CONN_FILT_USE_WL: u32 = 1;
pub const BLE_HCI_CONN_FILT_MAX: u32 = 1;
pub const BLE_HCI_CONN_ITVL_MIN: u32 = 6;
pub const BLE_HCI_CONN_ITVL_MAX: u32 = 3200;
pub const BLE_HCI_CONN_LATENCY_MIN: u32 = 0;
pub const BLE_HCI_CONN_LATENCY_MAX: u32 = 499;
pub const BLE_HCI_CONN_SPVN_TIMEOUT_MIN: u32 = 10;
pub const BLE_HCI_CONN_SPVN_TIMEOUT_MAX: u32 = 3200;
pub const BLE_HCI_CONN_SPVN_TMO_UNITS: u32 = 10;
pub const BLE_HCI_INITIATOR_FILT_POLICY_MAX: u32 = 1;
pub const BLE_HCI_CONN_PEER_ADDR_PUB_ID: u32 = 2;
pub const BLE_HCI_CONN_PEER_ADDR_RAND_ID: u32 = 3;
pub const BLE_HCI_CONN_UPDATE_LEN: u32 = 14;
pub const BLE_HCI_SET_HOST_CHAN_CLASS_LEN: u32 = 5;
pub const BLE_HCI_RD_CHANMAP_LEN: u32 = 2;
pub const BLE_HCI_RD_CHANMAP_RSP_LEN: u32 = 7;
pub const BLE_HCI_CONN_RD_REM_FEAT_LEN: u32 = 2;
pub const BLE_HCI_LE_ENCRYPT_LEN: u32 = 32;
pub const BLE_HCI_LE_RAND_LEN: u32 = 8;
pub const BLE_HCI_LE_START_ENCRYPT_LEN: u32 = 28;
pub const BLE_HCI_LT_KEY_REQ_REPLY_LEN: u32 = 18;
pub const BLE_HCI_LT_KEY_REQ_REPLY_ACK_PARAM_LEN: u32 = 2;
pub const BLE_HCI_LT_KEY_REQ_NEG_REPLY_LEN: u32 = 2;
pub const BLE_HCI_LT_KEY_REQ_NEG_REPLY_ACK_PARAM_LEN: u32 = 2;
pub const BLE_HCI_RD_SUPP_STATES_RSPLEN: u32 = 8;
pub const BLE_HCI_RX_TEST_LEN: u32 = 1;
pub const BLE_HCI_TX_TEST_LEN: u32 = 3;
pub const BLE_HCI_CONN_PARAM_REPLY_LEN: u32 = 14;
pub const BLE_HCI_CONN_PARAM_NEG_REPLY_LEN: u32 = 3;
pub const BLE_HCI_SET_DATALEN_LEN: u32 = 6;
pub const BLE_HCI_SET_DATALEN_ACK_PARAM_LEN: u32 = 2;
pub const BLE_HCI_SET_DATALEN_TX_OCTETS_MIN: u32 = 27;
pub const BLE_HCI_SET_DATALEN_TX_OCTETS_MAX: u32 = 251;
pub const BLE_HCI_SET_DATALEN_TX_TIME_MIN: u32 = 328;
pub const BLE_HCI_SET_DATALEN_TX_TIME_MAX: u32 = 17040;
pub const BLE_HCI_RD_SUGG_DATALEN_RSPLEN: u32 = 4;
pub const BLE_HCI_WR_SUGG_DATALEN_LEN: u32 = 4;
pub const BLE_HCI_GEN_DHKEY_LEN: u32 = 64;
pub const BLE_HCI_ADD_TO_RESOLV_LIST_LEN: u32 = 39;
pub const BLE_HCI_RMV_FROM_RESOLV_LIST_LEN: u32 = 7;
pub const BLE_HCI_RD_PEER_RESOLV_ADDR_LEN: u32 = 7;
pub const BLE_HCI_RD_LOC_RESOLV_ADDR_LEN: u32 = 7;
pub const BLE_HCI_SET_ADDR_RESOL_ENA_LEN: u32 = 1;
pub const BLE_HCI_SET_RESOLV_PRIV_ADDR_TO_LEN: u32 = 2;
pub const BLE_HCI_RD_MAX_DATALEN_RSPLEN: u32 = 8;
pub const BLE_HCI_LE_RD_PHY_LEN: u32 = 2;
pub const BLE_HCI_LE_RD_PHY_RSPLEN: u32 = 4;
pub const BLE_HCI_LE_PHY_1M: u32 = 1;
pub const BLE_HCI_LE_PHY_2M: u32 = 2;
pub const BLE_HCI_LE_PHY_CODED: u32 = 3;
pub const BLE_HCI_LE_SET_DEFAULT_PHY_LEN: u32 = 3;
pub const BLE_HCI_LE_PHY_NO_TX_PREF_MASK: u32 = 1;
pub const BLE_HCI_LE_PHY_NO_RX_PREF_MASK: u32 = 2;
pub const BLE_HCI_LE_PHY_1M_PREF_MASK: u32 = 1;
pub const BLE_HCI_LE_PHY_2M_PREF_MASK: u32 = 2;
pub const BLE_HCI_LE_PHY_CODED_PREF_MASK: u32 = 4;
pub const BLE_HCI_LE_PHY_PREF_MASK_ALL: u32 = 7;
pub const BLE_HCI_LE_SET_PHY_LEN: u32 = 7;
pub const BLE_HCI_LE_PHY_CODED_ANY: u32 = 0;
pub const BLE_HCI_LE_PHY_CODED_S2_PREF: u32 = 1;
pub const BLE_HCI_LE_PHY_CODED_S8_PREF: u32 = 2;
pub const BLE_HCI_LE_ENH_RX_TEST_LEN: u32 = 3;
pub const BLE_HCI_LE_ENH_TX_TEST_LEN: u32 = 4;
pub const BLE_HCI_LE_PHY_CODED_S8: u32 = 3;
pub const BLE_HCI_LE_PHY_CODED_S2: u32 = 4;
pub const BLE_HCI_LE_SET_ADV_SET_RND_ADDR_LEN: u32 = 7;
pub const BLE_HCI_LE_SET_EXT_ADV_PARAM_LEN: u32 = 25;
pub const BLE_HCI_LE_SET_EXT_ADV_PROP_CONNECTABLE: u32 = 1;
pub const BLE_HCI_LE_SET_EXT_ADV_PROP_SCANNABLE: u32 = 2;
pub const BLE_HCI_LE_SET_EXT_ADV_PROP_DIRECTED: u32 = 4;
pub const BLE_HCI_LE_SET_EXT_ADV_PROP_HD_DIRECTED: u32 = 8;
pub const BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY: u32 = 16;
pub const BLE_HCI_LE_SET_EXT_ADV_PROP_ANON_ADV: u32 = 32;
pub const BLE_HCI_LE_SET_EXT_ADV_PROP_INC_TX_PWR: u32 = 64;
pub const BLE_HCI_LE_SET_EXT_ADV_PROP_MASK: u32 = 127;
pub const BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_IND: u32 = 19;
pub const BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_LD_DIR: u32 = 21;
pub const BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_HD_DIR: u32 = 29;
pub const BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_SCAN: u32 = 18;
pub const BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_NONCONN: u32 = 16;
pub const BLE_HCI_MAX_EXT_ADV_DATA_LEN: u32 = 251;
pub const BLE_HCI_SET_EXT_ADV_DATA_HDR_LEN: u32 = 4;
pub const BLE_HCI_LE_SET_EXT_ADV_DATA_LEN: u32 = 255;
pub const BLE_HCI_LE_SET_EXT_ADV_DATA_OPER_INT: u32 = 0;
pub const BLE_HCI_LE_SET_EXT_ADV_DATA_OPER_FIRST: u32 = 1;
pub const BLE_HCI_LE_SET_EXT_ADV_DATA_OPER_LAST: u32 = 2;
pub const BLE_HCI_LE_SET_EXT_ADV_DATA_OPER_COMPLETE: u32 = 3;
pub const BLE_HCI_LE_SET_EXT_ADV_DATA_OPER_UNCHANGED: u32 = 4;
pub const BLE_HCI_MAX_EXT_SCAN_RSP_DATA_LEN: u32 = 251;
pub const BLE_HCI_SET_EXT_SCAN_RSP_DATA_HDR_LEN: u32 = 4;
pub const BLE_HCI_LE_SET_EXT_SCAN_RSP_DATA_LEN: u32 = 255;
pub const BLE_HCI_LE_SET_EXT_SCAN_RSP_DATA_OPER_INT: u32 = 0;
pub const BLE_HCI_LE_SET_EXT_SCAN_RSP_DATA_OPER_FIRST: u32 = 1;
pub const BLE_HCI_LE_SET_EXT_SCAN_RSP_DATA_OPER_LAST: u32 = 2;
pub const BLE_HCI_LE_SET_EXT_SCAN_RSP_DATA_OPER_COMPLETE: u32 = 3;
pub const BLE_HCI_LE_SET_EXT_ADV_ENABLE_LEN: u32 = 255;
pub const BLE_HCI_LE_REMOVE_ADV_SET_LEN: u32 = 1;
pub const BLE_HCI_RD_MAX_ADV_DATA_LEN: u32 = 2;
pub const BLE_HCI_RD_NR_SUP_ADV_SETS: u32 = 1;
pub const BLE_HCI_LE_SET_PER_ADV_PARAMS_LEN: u32 = 7;
pub const BLE_HCI_LE_SET_PER_ADV_DATA_LEN: u32 = 255;
pub const BLE_HCI_LE_SET_PER_ADV_ENABLE_LEN: u32 = 2;
pub const BLE_HCI_LE_SET_EXT_SCAN_PARAM_LEN: u32 = 255;
pub const BLE_HCI_LE_EXT_SCAN_BASE_LEN: u32 = 3;
pub const BLE_HCI_LE_EXT_SCAN_SINGLE_PARAM_LEN: u32 = 5;
pub const BLE_HCI_LE_SET_EXT_SCAN_ENABLE_LEN: u32 = 6;
pub const BLE_HCI_LE_EXT_CREATE_CONN_LEN: u32 = 255;
pub const BLE_HCI_LE_EXT_CREATE_CONN_BASE_LEN: u32 = 10;
pub const BLE_HCI_LE_PER_ADV_CREATE_SYNC_LEN: u32 = 14;
pub const BLE_HCI_LE_PER_ADV_TERM_SYNC_LEN: u32 = 2;
pub const BLE_HCI_LE_ADD_DEV_TO_PER_ADV_LIST_LEN: u32 = 8;
pub const BLE_HCI_LE_REM_DEV_FROM_PER_ADV_LIST_LEN: u32 = 8;
pub const BLE_HCI_LE_WR_RF_PATH_COMPENSATION_LEN: u32 = 4;
pub const BLE_HCI_LE_SET_PRIVACY_MODE_LEN: u32 = 8;
pub const BLE_HCI_PRIVACY_NETWORK: u32 = 0;
pub const BLE_HCI_PRIVACY_DEVICE: u32 = 1;
pub const BLE_HCI_EVCODE_INQUIRY_CMP: u32 = 1;
pub const BLE_HCI_EVCODE_INQUIRY_RESULT: u32 = 2;
pub const BLE_HCI_EVCODE_CONN_DONE: u32 = 3;
pub const BLE_HCI_EVCODE_CONN_REQUEST: u32 = 4;
pub const BLE_HCI_EVCODE_DISCONN_CMP: u32 = 5;
pub const BLE_HCI_EVCODE_AUTH_CMP: u32 = 6;
pub const BLE_HCI_EVCODE_REM_NAME_REQ_CMP: u32 = 7;
pub const BLE_HCI_EVCODE_ENCRYPT_CHG: u32 = 8;
pub const BLE_HCI_EVCODE_CHG_LINK_KEY_CMP: u32 = 9;
pub const BLE_HCI_EVCODE_MASTER_LINK_KEY_CMP: u32 = 10;
pub const BLE_HCI_EVCODE_RD_REM_SUPP_FEAT_CMP: u32 = 11;
pub const BLE_HCI_EVCODE_RD_REM_VER_INFO_CMP: u32 = 12;
pub const BLE_HCI_EVCODE_QOS_SETUP_CMP: u32 = 13;
pub const BLE_HCI_EVCODE_COMMAND_COMPLETE: u32 = 14;
pub const BLE_HCI_EVCODE_COMMAND_STATUS: u32 = 15;
pub const BLE_HCI_EVCODE_HW_ERROR: u32 = 16;
pub const BLE_HCI_EVCODE_NUM_COMP_PKTS: u32 = 19;
pub const BLE_HCI_EVCODE_MODE_CHANGE: u32 = 20;
pub const BLE_HCI_EVCODE_RETURN_LINK_KEYS: u32 = 21;
pub const BLE_HCI_EVCODE_PIN_CODE_REQ: u32 = 22;
pub const BLE_HCI_EVCODE_LINK_KEY_REQ: u32 = 23;
pub const BLE_HCI_EVCODE_LINK_KEY_NOTIFY: u32 = 24;
pub const BLE_HCI_EVCODE_LOOPBACK_CMD: u32 = 25;
pub const BLE_HCI_EVCODE_DATA_BUF_OVERFLOW: u32 = 26;
pub const BLE_HCI_EVCODE_MAX_SLOTS_CHG: u32 = 27;
pub const BLE_HCI_EVCODE_READ_CLK_OFF_COMP: u32 = 28;
pub const BLE_HCI_EVCODE_CONN_PKT_TYPE_CHG: u32 = 29;
pub const BLE_HCI_EVCODE_QOS_VIOLATION: u32 = 30;
pub const BLE_HCI_EVCODE_PSR_MODE_CHG: u32 = 32;
pub const BLE_HCI_EVCODE_FLOW_SPEC_COMP: u32 = 33;
pub const BLE_HCI_EVCODE_INQ_RESULT_RSSI: u32 = 34;
pub const BLE_HCI_EVCODE_READ_REM_EXT_FEAT: u32 = 35;
pub const BLE_HCI_EVCODE_SYNCH_CONN_COMP: u32 = 44;
pub const BLE_HCI_EVCODE_SYNCH_CONN_CHG: u32 = 45;
pub const BLE_HCI_EVCODE_SNIFF_SUBRATING: u32 = 46;
pub const BLE_HCI_EVCODE_EXT_INQ_RESULT: u32 = 47;
pub const BLE_HCI_EVCODE_ENC_KEY_REFRESH: u32 = 48;
pub const BLE_HCI_EVOCDE_IO_CAP_REQ: u32 = 49;
pub const BLE_HCI_EVCODE_IO_CAP_RSP: u32 = 50;
pub const BLE_HCI_EVCODE_USER_CONFIRM_REQ: u32 = 51;
pub const BLE_HCI_EVCODE_PASSKEY_REQ: u32 = 52;
pub const BLE_HCI_EVCODE_REM_OOB_DATA_REQ: u32 = 53;
pub const BLE_HCI_EVCODE_SIMPLE_PAIR_COMP: u32 = 54;
pub const BLE_HCI_EVCODE_LNK_SPVN_TMO_CHG: u32 = 56;
pub const BLE_HCI_EVCODE_ENH_FLUSH_COMP: u32 = 57;
pub const BLE_HCI_EVCODE_USER_PASSKEY_NOTIFY: u32 = 59;
pub const BLE_HCI_EVCODE_KEYPRESS_NOTIFY: u32 = 60;
pub const BLE_HCI_EVCODE_REM_HOST_SUPP_FEAT: u32 = 61;
pub const BLE_HCI_EVCODE_LE_META: u32 = 62;
pub const BLE_HCI_EVCODE_PHYS_LINK_COMP: u32 = 64;
pub const BLE_HCI_EVCODE_CHAN_SELECTED: u32 = 65;
pub const BLE_HCI_EVCODE_DISCONN_PHYS_LINK: u32 = 66;
pub const BLE_HCI_EVCODE_PHYS_LINK_LOSS_EARLY: u32 = 67;
pub const BLE_HCI_EVCODE_PHYS_LINK_RECOVERY: u32 = 68;
pub const BLE_HCI_EVCODE_LOGICAL_LINK_COMP: u32 = 69;
pub const BLE_HCI_EVCODE_DISCONN_LOGICAL_LINK: u32 = 70;
pub const BLE_HCI_EVCODE_FLOW_SPEC_MODE_COMP: u32 = 71;
pub const BLE_HCI_EVCODE_NUM_COMP_DATA_BLKS: u32 = 72;
pub const BLE_HCI_EVCODE_AMP_START_TEST: u32 = 73;
pub const BLE_HCI_EVOCDE_AMP_TEST_END: u32 = 74;
pub const BLE_HCI_EVOCDE_AMP_RCVR_REPORT: u32 = 75;
pub const BLE_HCI_EVCODE_SHORT_RANGE_MODE_CHG: u32 = 76;
pub const BLE_HCI_EVCODE_AMP_STATUS_CHG: u32 = 77;
pub const BLE_HCI_EVCODE_TRIG_CLK_CAPTURE: u32 = 78;
pub const BLE_HCI_EVCODE_SYNCH_TRAIN_COMP: u32 = 79;
pub const BLE_HCI_EVCODE_SYNCH_TRAIN_RCVD: u32 = 80;
pub const BLE_HCI_EVCODE_SLAVE_BCAST_RX: u32 = 81;
pub const BLE_HCI_EVCODE_SLAVE_BCAST_TMO: u32 = 82;
pub const BLE_HCI_EVCODE_TRUNC_PAGE_COMP: u32 = 83;
pub const BLE_HCI_EVCODE_SLAVE_PAGE_RSP_TMO: u32 = 84;
pub const BLE_HCI_EVCODE_SLAVE_BCAST_CHAN_MAP: u32 = 85;
pub const BLE_HCI_EVCODE_INQ_RSP_NOTIFY: u32 = 86;
pub const BLE_HCI_EVCODE_AUTH_PYLD_TMO: u32 = 87;
pub const BLE_HCI_EVCODE_VENDOR_DEBUG: u32 = 255;
pub const BLE_HCI_LE_SUBEV_CONN_COMPLETE: u32 = 1;
pub const BLE_HCI_LE_SUBEV_ADV_RPT: u32 = 2;
pub const BLE_HCI_LE_SUBEV_CONN_UPD_COMPLETE: u32 = 3;
pub const BLE_HCI_LE_SUBEV_RD_REM_USED_FEAT: u32 = 4;
pub const BLE_HCI_LE_SUBEV_LT_KEY_REQ: u32 = 5;
pub const BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ: u32 = 6;
pub const BLE_HCI_LE_SUBEV_DATA_LEN_CHG: u32 = 7;
pub const BLE_HCI_LE_SUBEV_RD_LOC_P256_PUBKEY: u32 = 8;
pub const BLE_HCI_LE_SUBEV_GEN_DHKEY_COMPLETE: u32 = 9;
pub const BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE: u32 = 10;
pub const BLE_HCI_LE_SUBEV_DIRECT_ADV_RPT: u32 = 11;
pub const BLE_HCI_LE_SUBEV_PHY_UPDATE_COMPLETE: u32 = 12;
pub const BLE_HCI_LE_SUBEV_EXT_ADV_RPT: u32 = 13;
pub const BLE_HCI_LE_SUBEV_PER_ADV_SYNC_ESTAB: u32 = 14;
pub const BLE_HCI_LE_SUBEV_PER_ADV_RPT: u32 = 15;
pub const BLE_HCI_LE_SUBEV_PER_ADV_SYNC_LOST: u32 = 16;
pub const BLE_HCI_LE_SUBEV_SCAN_TIMEOUT: u32 = 17;
pub const BLE_HCI_LE_SUBEV_ADV_SET_TERMINATED: u32 = 18;
pub const BLE_HCI_LE_SUBEV_SCAN_REQ_RCVD: u32 = 19;
pub const BLE_HCI_LE_SUBEV_CHAN_SEL_ALG: u32 = 20;
pub const BLE_HCI_EVENT_HDR_LEN: u32 = 2;
pub const BLE_HCI_EVENT_DISCONN_COMPLETE_LEN: u32 = 4;
pub const BLE_HCI_EVENT_ENCRYPT_CHG_LEN: u32 = 4;
pub const BLE_HCI_EVENT_HW_ERROR_LEN: u32 = 1;
pub const BLE_HCI_EVENT_ENC_KEY_REFRESH_LEN: u32 = 3;
pub const BLE_HCI_EVENT_CMD_COMPLETE_HDR_LEN: u32 = 5;
pub const BLE_HCI_EVENT_CMD_COMPLETE_MIN_LEN: u32 = 6;
pub const BLE_HCI_EVENT_CMD_STATUS_LEN: u32 = 6;
pub const BLE_HCI_EVENT_NUM_COMP_PKTS_HDR_LEN: u32 = 1;
pub const BLE_HCI_EVENT_NUM_COMP_PKTS_ENT_LEN: u32 = 4;
pub const BLE_HCI_EVENT_RD_RM_VER_LEN: u32 = 8;
pub const BLE_HCI_EVENT_DATABUF_OVERFLOW_LEN: u32 = 1;
pub const BLE_HCI_EVENT_ACL_BUF_OVERFLOW: u32 = 1;
pub const BLE_HCI_ADV_RPT_EVTYPE_ADV_IND: u32 = 0;
pub const BLE_HCI_ADV_RPT_EVTYPE_DIR_IND: u32 = 1;
pub const BLE_HCI_ADV_RPT_EVTYPE_SCAN_IND: u32 = 2;
pub const BLE_HCI_ADV_RPT_EVTYPE_NONCONN_IND: u32 = 3;
pub const BLE_HCI_ADV_RPT_EVTYPE_SCAN_RSP: u32 = 4;
pub const BLE_HCI_LEGACY_ADV_EVTYPE_ADV_IND: u32 = 19;
pub const BLE_HCI_LEGACY_ADV_EVTYPE_ADV_DIRECT_IND: u32 = 21;
pub const BLE_HCI_LEGACY_ADV_EVTYPE_ADV_SCAN_IND: u32 = 18;
pub const BLE_HCI_LEGACY_ADV_EVTYPE_ADV_NONCON_IND: u32 = 16;
pub const BLE_HCI_LEGACY_ADV_EVTYPE_SCAN_RSP_ADV_IND: u32 = 27;
pub const BLE_HCI_LEGACY_ADV_EVTYPE_SCAN_RSP_ADV_SCAN_IND: u32 = 26;
pub const BLE_HCI_LE_MIN_LEN: u32 = 1;
pub const BLE_HCI_LE_CONN_COMPLETE_LEN: u32 = 19;
pub const BLE_HCI_LE_CONN_COMPLETE_ROLE_MASTER: u32 = 0;
pub const BLE_HCI_LE_CONN_COMPLETE_ROLE_SLAVE: u32 = 1;
pub const BLE_HCI_LE_CONN_HANDLE_MAX: u32 = 3839;
pub const BLE_HCI_LE_ADV_RPT_MIN_LEN: u32 = 12;
pub const BLE_HCI_LE_ADV_DIRECT_RPT_LEN: u32 = 18;
pub const BLE_HCI_LE_ADV_RPT_NUM_RPTS_MIN: u32 = 1;
pub const BLE_HCI_LE_ADV_RPT_NUM_RPTS_MAX: u32 = 25;
pub const BLE_HCI_LE_ADV_DIRECT_RPT_SUB_LEN: u32 = 16;
pub const BLE_HCI_LE_CONN_UPD_LEN: u32 = 10;
pub const BLE_HCI_LE_LT_KEY_REQ_LEN: u32 = 13;
pub const BLE_HCI_LE_RD_REM_USED_FEAT_LEN: u32 = 12;
pub const BLE_HCI_LE_REM_CONN_PARM_REQ_LEN: u32 = 11;
pub const BLE_HCI_LE_DATA_LEN_CHG_LEN: u32 = 11;
pub const BLE_HCI_LE_PHY_UPD_LEN: u32 = 6;
pub const BLE_HCI_LE_SUBEV_SCAN_TIMEOUT_LEN: u32 = 1;
pub const BLE_HCI_LE_SUBEV_ADV_SET_TERMINATED_LEN: u32 = 6;
pub const BLE_HCI_LE_SUBEV_SCAN_REQ_RCVD_LEN: u32 = 9;
pub const BLE_HCI_LE_SUBEV_CHAN_SEL_ALG_LEN: u32 = 4;
pub const BLE_HCI_VER_BCS_1_0b: u32 = 0;
pub const BLE_HCI_VER_BCS_1_1: u32 = 1;
pub const BLE_HCI_VER_BCS_1_2: u32 = 2;
pub const BLE_HCI_VER_BCS_2_0_EDR: u32 = 3;
pub const BLE_HCI_VER_BCS_2_1_EDR: u32 = 4;
pub const BLE_HCI_VER_BCS_3_0_HCS: u32 = 5;
pub const BLE_HCI_VER_BCS_4_0: u32 = 6;
pub const BLE_HCI_VER_BCS_4_1: u32 = 7;
pub const BLE_HCI_VER_BCS_4_2: u32 = 8;
pub const BLE_HCI_VER_BCS_5_0: u32 = 9;
pub const BLE_LMP_VER_BCS_1_0b: u32 = 0;
pub const BLE_LMP_VER_BCS_1_1: u32 = 1;
pub const BLE_LMP_VER_BCS_1_2: u32 = 2;
pub const BLE_LMP_VER_BCS_2_0_EDR: u32 = 3;
pub const BLE_LMP_VER_BCS_2_1_EDR: u32 = 4;
pub const BLE_LMP_VER_BCS_3_0_HCS: u32 = 5;
pub const BLE_LMP_VER_BCS_4_0: u32 = 6;
pub const BLE_LMP_VER_BCS_4_1: u32 = 7;
pub const BLE_LMP_VER_BCS_4_2: u32 = 8;
pub const BLE_LMP_VER_BCS_5_0: u32 = 9;
pub const BLE_HCI_LE_ENH_CONN_COMPLETE_LEN: u32 = 31;
pub const BLE_HCI_DATA_HDR_SZ: u32 = 4;
pub const BLE_HCI_PB_FIRST_NON_FLUSH: u32 = 0;
pub const BLE_HCI_PB_MIDDLE: u32 = 1;
pub const BLE_HCI_PB_FIRST_FLUSH: u32 = 2;
pub const BLE_HCI_PB_FULL: u32 = 3;
pub const BLE_ATT_UUID_PRIMARY_SERVICE: u32 = 10240;
pub const BLE_ATT_UUID_SECONDARY_SERVICE: u32 = 10241;
pub const BLE_ATT_UUID_INCLUDE: u32 = 10242;
pub const BLE_ATT_UUID_CHARACTERISTIC: u32 = 10243;
pub const BLE_ATT_ERR_INVALID_HANDLE: u32 = 1;
pub const BLE_ATT_ERR_READ_NOT_PERMITTED: u32 = 2;
pub const BLE_ATT_ERR_WRITE_NOT_PERMITTED: u32 = 3;
pub const BLE_ATT_ERR_INVALID_PDU: u32 = 4;
pub const BLE_ATT_ERR_INSUFFICIENT_AUTHEN: u32 = 5;
pub const BLE_ATT_ERR_REQ_NOT_SUPPORTED: u32 = 6;
pub const BLE_ATT_ERR_INVALID_OFFSET: u32 = 7;
pub const BLE_ATT_ERR_INSUFFICIENT_AUTHOR: u32 = 8;
pub const BLE_ATT_ERR_PREPARE_QUEUE_FULL: u32 = 9;
pub const BLE_ATT_ERR_ATTR_NOT_FOUND: u32 = 10;
pub const BLE_ATT_ERR_ATTR_NOT_LONG: u32 = 11;
pub const BLE_ATT_ERR_INSUFFICIENT_KEY_SZ: u32 = 12;
pub const BLE_ATT_ERR_INVALID_ATTR_VALUE_LEN: u32 = 13;
pub const BLE_ATT_ERR_UNLIKELY: u32 = 14;
pub const BLE_ATT_ERR_INSUFFICIENT_ENC: u32 = 15;
pub const BLE_ATT_ERR_UNSUPPORTED_GROUP: u32 = 16;
pub const BLE_ATT_ERR_INSUFFICIENT_RES: u32 = 17;
pub const BLE_ATT_OP_ERROR_RSP: u32 = 1;
pub const BLE_ATT_OP_MTU_REQ: u32 = 2;
pub const BLE_ATT_OP_MTU_RSP: u32 = 3;
pub const BLE_ATT_OP_FIND_INFO_REQ: u32 = 4;
pub const BLE_ATT_OP_FIND_INFO_RSP: u32 = 5;
pub const BLE_ATT_OP_FIND_TYPE_VALUE_REQ: u32 = 6;
pub const BLE_ATT_OP_FIND_TYPE_VALUE_RSP: u32 = 7;
pub const BLE_ATT_OP_READ_TYPE_REQ: u32 = 8;
pub const BLE_ATT_OP_READ_TYPE_RSP: u32 = 9;
pub const BLE_ATT_OP_READ_REQ: u32 = 10;
pub const BLE_ATT_OP_READ_RSP: u32 = 11;
pub const BLE_ATT_OP_READ_BLOB_REQ: u32 = 12;
pub const BLE_ATT_OP_READ_BLOB_RSP: u32 = 13;
pub const BLE_ATT_OP_READ_MULT_REQ: u32 = 14;
pub const BLE_ATT_OP_READ_MULT_RSP: u32 = 15;
pub const BLE_ATT_OP_READ_GROUP_TYPE_REQ: u32 = 16;
pub const BLE_ATT_OP_READ_GROUP_TYPE_RSP: u32 = 17;
pub const BLE_ATT_OP_WRITE_REQ: u32 = 18;
pub const BLE_ATT_OP_WRITE_RSP: u32 = 19;
pub const BLE_ATT_OP_PREP_WRITE_REQ: u32 = 22;
pub const BLE_ATT_OP_PREP_WRITE_RSP: u32 = 23;
pub const BLE_ATT_OP_EXEC_WRITE_REQ: u32 = 24;
pub const BLE_ATT_OP_EXEC_WRITE_RSP: u32 = 25;
pub const BLE_ATT_OP_NOTIFY_REQ: u32 = 27;
pub const BLE_ATT_OP_INDICATE_REQ: u32 = 29;
pub const BLE_ATT_OP_INDICATE_RSP: u32 = 30;
pub const BLE_ATT_OP_WRITE_CMD: u32 = 82;
pub const BLE_ATT_ATTR_MAX_LEN: u32 = 512;
pub const BLE_ATT_F_READ: u32 = 1;
pub const BLE_ATT_F_WRITE: u32 = 2;
pub const BLE_ATT_F_READ_ENC: u32 = 4;
pub const BLE_ATT_F_READ_AUTHEN: u32 = 8;
pub const BLE_ATT_F_READ_AUTHOR: u32 = 16;
pub const BLE_ATT_F_WRITE_ENC: u32 = 32;
pub const BLE_ATT_F_WRITE_AUTHEN: u32 = 64;
pub const BLE_ATT_F_WRITE_AUTHOR: u32 = 128;
pub const HA_FLAG_PERM_RW: u32 = 3;
pub const BLE_ATT_ACCESS_OP_READ: u32 = 1;
pub const BLE_ATT_ACCESS_OP_WRITE: u32 = 2;
pub const BLE_ATT_MTU_DFLT: u32 = 23;
pub const BLE_ATT_MTU_MAX: u32 = 527;
pub const BLE_EDDYSTONE_MAX_UUIDS16: u32 = 3;
pub const BLE_EDDYSTONE_URL_MAX_LEN: u32 = 17;
pub const BLE_EDDYSTONE_URL_SCHEME_HTTP_WWW: u32 = 0;
pub const BLE_EDDYSTONE_URL_SCHEME_HTTPS_WWW: u32 = 1;
pub const BLE_EDDYSTONE_URL_SCHEME_HTTP: u32 = 2;
pub const BLE_EDDYSTONE_URL_SCHEME_HTTPS: u32 = 3;
pub const BLE_EDDYSTONE_URL_SUFFIX_COM_SLASH: u32 = 0;
pub const BLE_EDDYSTONE_URL_SUFFIX_ORG_SLASH: u32 = 1;
pub const BLE_EDDYSTONE_URL_SUFFIX_EDU_SLASH: u32 = 2;
pub const BLE_EDDYSTONE_URL_SUFFIX_NET_SLASH: u32 = 3;
pub const BLE_EDDYSTONE_URL_SUFFIX_INFO_SLASH: u32 = 4;
pub const BLE_EDDYSTONE_URL_SUFFIX_BIZ_SLASH: u32 = 5;
pub const BLE_EDDYSTONE_URL_SUFFIX_GOV_SLASH: u32 = 6;
pub const BLE_EDDYSTONE_URL_SUFFIX_COM: u32 = 7;
pub const BLE_EDDYSTONE_URL_SUFFIX_ORG: u32 = 8;
pub const BLE_EDDYSTONE_URL_SUFFIX_EDU: u32 = 9;
pub const BLE_EDDYSTONE_URL_SUFFIX_NET: u32 = 10;
pub const BLE_EDDYSTONE_URL_SUFFIX_INFO: u32 = 11;
pub const BLE_EDDYSTONE_URL_SUFFIX_BIZ: u32 = 12;
pub const BLE_EDDYSTONE_URL_SUFFIX_GOV: u32 = 13;
pub const BLE_EDDYSTONE_URL_SUFFIX_NONE: u32 = 255;
pub const BLE_UUID_STR_LEN: u32 = 37;
pub const BLE_HS_ADV_MAX_SZ: u32 = 31;
pub const BLE_HS_ADV_MAX_FIELD_SZ: u32 = 29;
pub const BLE_HS_ADV_TYPE_FLAGS: u32 = 1;
pub const BLE_HS_ADV_TYPE_INCOMP_UUIDS16: u32 = 2;
pub const BLE_HS_ADV_TYPE_COMP_UUIDS16: u32 = 3;
pub const BLE_HS_ADV_TYPE_INCOMP_UUIDS32: u32 = 4;
pub const BLE_HS_ADV_TYPE_COMP_UUIDS32: u32 = 5;
pub const BLE_HS_ADV_TYPE_INCOMP_UUIDS128: u32 = 6;
pub const BLE_HS_ADV_TYPE_COMP_UUIDS128: u32 = 7;
pub const BLE_HS_ADV_TYPE_INCOMP_NAME: u32 = 8;
pub const BLE_HS_ADV_TYPE_COMP_NAME: u32 = 9;
pub const BLE_HS_ADV_TYPE_TX_PWR_LVL: u32 = 10;
pub const BLE_HS_ADV_TYPE_SLAVE_ITVL_RANGE: u32 = 18;
pub const BLE_HS_ADV_TYPE_SOL_UUIDS16: u32 = 20;
pub const BLE_HS_ADV_TYPE_SOL_UUIDS128: u32 = 21;
pub const BLE_HS_ADV_TYPE_SVC_DATA_UUID16: u32 = 22;
pub const BLE_HS_ADV_TYPE_PUBLIC_TGT_ADDR: u32 = 23;
pub const BLE_HS_ADV_TYPE_RANDOM_TGT_ADDR: u32 = 24;
pub const BLE_HS_ADV_TYPE_APPEARANCE: u32 = 25;
pub const BLE_HS_ADV_TYPE_ADV_ITVL: u32 = 26;
pub const BLE_HS_ADV_TYPE_SVC_DATA_UUID32: u32 = 32;
pub const BLE_HS_ADV_TYPE_SVC_DATA_UUID128: u32 = 33;
pub const BLE_HS_ADV_TYPE_URI: u32 = 36;
pub const BLE_HS_ADV_TYPE_MESH_PROV: u32 = 41;
pub const BLE_HS_ADV_TYPE_MESH_MESSAGE: u32 = 42;
pub const BLE_HS_ADV_TYPE_MESH_BEACON: u32 = 43;
pub const BLE_HS_ADV_TYPE_MFG_DATA: u32 = 255;
pub const BLE_HS_ADV_FLAGS_LEN: u32 = 1;
pub const BLE_HS_ADV_F_DISC_LTD: u32 = 1;
pub const BLE_HS_ADV_F_DISC_GEN: u32 = 2;
pub const BLE_HS_ADV_F_BREDR_UNSUP: u32 = 4;
pub const BLE_HS_ADV_TX_PWR_LVL_LEN: u32 = 1;
pub const BLE_HS_ADV_TX_PWR_LVL_AUTO: i32 = -128;
pub const BLE_HS_ADV_SLAVE_ITVL_RANGE_LEN: u32 = 4;
pub const BLE_HS_ADV_SVC_DATA_UUID16_MIN_LEN: u32 = 2;
pub const BLE_HS_ADV_PUBLIC_TGT_ADDR_ENTRY_LEN: u32 = 6;
pub const BLE_HS_ADV_APPEARANCE_LEN: u32 = 2;
pub const BLE_HS_ADV_ADV_ITVL_LEN: u32 = 2;
pub const BLE_HS_ADV_SVC_DATA_UUID32_MIN_LEN: u32 = 4;
pub const BLE_HS_ADV_SVC_DATA_UUID128_MIN_LEN: u32 = 16;
pub const BLE_GAP_ADV_FAST_INTERVAL1_MIN: u32 = 48;
pub const BLE_GAP_ADV_FAST_INTERVAL1_MAX: u32 = 96;
pub const BLE_GAP_ADV_FAST_INTERVAL2_MIN: u32 = 160;
pub const BLE_GAP_ADV_FAST_INTERVAL2_MAX: u32 = 240;
pub const BLE_GAP_SCAN_FAST_INTERVAL_MIN: u32 = 48;
pub const BLE_GAP_SCAN_FAST_INTERVAL_MAX: u32 = 96;
pub const BLE_GAP_LIM_DISC_SCAN_INT: f64 = 18.0;
pub const BLE_GAP_LIM_DISC_SCAN_WINDOW: f64 = 18.0;
pub const BLE_GAP_SCAN_FAST_WINDOW: u32 = 48;
pub const BLE_GAP_SCAN_FAST_PERIOD: f64 = 30720.0;
pub const BLE_GAP_SCAN_SLOW_INTERVAL1: u32 = 2048;
pub const BLE_GAP_SCAN_SLOW_WINDOW1: f64 = 18.0;
pub const BLE_GAP_DISC_DUR_DFLT: f64 = 10240.0;
pub const BLE_GAP_CONN_DUR_DFLT: u32 = 30000;
pub const BLE_GAP_CONN_PAUSE_CENTRAL: u32 = 1000;
pub const BLE_GAP_CONN_PAUSE_PERIPHERAL: u32 = 5000;
pub const BLE_GAP_INITIAL_CONN_ITVL_MIN: u32 = 24;
pub const BLE_GAP_INITIAL_CONN_ITVL_MAX: u32 = 40;
pub const BLE_GAP_ADV_DFLT_CHANNEL_MAP: u32 = 7;
pub const BLE_GAP_INITIAL_CONN_LATENCY: u32 = 0;
pub const BLE_GAP_INITIAL_SUPERVISION_TIMEOUT: u32 = 256;
pub const BLE_GAP_INITIAL_CONN_MIN_CE_LEN: u32 = 16;
pub const BLE_GAP_INITIAL_CONN_MAX_CE_LEN: u32 = 768;
pub const BLE_GAP_ROLE_MASTER: u32 = 0;
pub const BLE_GAP_ROLE_SLAVE: u32 = 1;
pub const BLE_GAP_EVENT_CONNECT: u32 = 0;
pub const BLE_GAP_EVENT_DISCONNECT: u32 = 1;
pub const BLE_GAP_EVENT_CONN_UPDATE: u32 = 3;
pub const BLE_GAP_EVENT_CONN_UPDATE_REQ: u32 = 4;
pub const BLE_GAP_EVENT_L2CAP_UPDATE_REQ: u32 = 5;
pub const BLE_GAP_EVENT_TERM_FAILURE: u32 = 6;
pub const BLE_GAP_EVENT_DISC: u32 = 7;
pub const BLE_GAP_EVENT_DISC_COMPLETE: u32 = 8;
pub const BLE_GAP_EVENT_ADV_COMPLETE: u32 = 9;
pub const BLE_GAP_EVENT_ENC_CHANGE: u32 = 10;
pub const BLE_GAP_EVENT_PASSKEY_ACTION: u32 = 11;
pub const BLE_GAP_EVENT_NOTIFY_RX: u32 = 12;
pub const BLE_GAP_EVENT_NOTIFY_TX: u32 = 13;
pub const BLE_GAP_EVENT_SUBSCRIBE: u32 = 14;
pub const BLE_GAP_EVENT_MTU: u32 = 15;
pub const BLE_GAP_EVENT_IDENTITY_RESOLVED: u32 = 16;
pub const BLE_GAP_EVENT_REPEAT_PAIRING: u32 = 17;
pub const BLE_GAP_EVENT_PHY_UPDATE_COMPLETE: u32 = 18;
pub const BLE_GAP_EVENT_EXT_DISC: u32 = 19;
pub const BLE_GAP_SUBSCRIBE_REASON_WRITE: u32 = 1;
pub const BLE_GAP_SUBSCRIBE_REASON_TERM: u32 = 2;
pub const BLE_GAP_SUBSCRIBE_REASON_RESTORE: u32 = 3;
pub const BLE_GAP_REPEAT_PAIRING_RETRY: u32 = 1;
pub const BLE_GAP_REPEAT_PAIRING_IGNORE: u32 = 2;
pub const BLE_GAP_CONN_MODE_NON: u32 = 0;
pub const BLE_GAP_CONN_MODE_DIR: u32 = 1;
pub const BLE_GAP_CONN_MODE_UND: u32 = 2;
pub const BLE_GAP_DISC_MODE_NON: u32 = 0;
pub const BLE_GAP_DISC_MODE_LTD: u32 = 1;
pub const BLE_GAP_DISC_MODE_GEN: u32 = 2;
pub const BLE_GAP_PRIVATE_MODE_NETWORK: u32 = 0;
pub const BLE_GAP_PRIVATE_MODE_DEVICE: u32 = 1;
pub const BLE_GAP_LE_PHY_1M: u32 = 1;
pub const BLE_GAP_LE_PHY_2M: u32 = 2;
pub const BLE_GAP_LE_PHY_CODED: u32 = 3;
pub const BLE_GAP_LE_PHY_1M_MASK: u32 = 1;
pub const BLE_GAP_LE_PHY_2M_MASK: u32 = 2;
pub const BLE_GAP_LE_PHY_CODED_MASK: u32 = 4;
pub const BLE_GAP_LE_PHY_ANY_MASK: u32 = 15;
pub const BLE_GAP_LE_PHY_CODED_ANY: u32 = 0;
pub const BLE_GAP_LE_PHY_CODED_S2: u32 = 1;
pub const BLE_GAP_LE_PHY_CODED_S8: u32 = 2;
pub const BLE_GATT_REGISTER_OP_SVC: u32 = 1;
pub const BLE_GATT_REGISTER_OP_CHR: u32 = 2;
pub const BLE_GATT_REGISTER_OP_DSC: u32 = 3;
pub const BLE_GATT_SVC_UUID16: u32 = 6145;
pub const BLE_GATT_DSC_CLT_CFG_UUID16: u32 = 10498;
pub const BLE_GATT_CHR_PROP_BROADCAST: u32 = 1;
pub const BLE_GATT_CHR_PROP_READ: u32 = 2;
pub const BLE_GATT_CHR_PROP_WRITE_NO_RSP: u32 = 4;
pub const BLE_GATT_CHR_PROP_WRITE: u32 = 8;
pub const BLE_GATT_CHR_PROP_NOTIFY: u32 = 16;
pub const BLE_GATT_CHR_PROP_INDICATE: u32 = 32;
pub const BLE_GATT_CHR_PROP_AUTH_SIGN_WRITE: u32 = 64;
pub const BLE_GATT_CHR_PROP_EXTENDED: u32 = 128;
pub const BLE_GATT_ACCESS_OP_READ_CHR: u32 = 0;
pub const BLE_GATT_ACCESS_OP_WRITE_CHR: u32 = 1;
pub const BLE_GATT_ACCESS_OP_READ_DSC: u32 = 2;
pub const BLE_GATT_ACCESS_OP_WRITE_DSC: u32 = 3;
pub const BLE_GATT_CHR_F_BROADCAST: u32 = 1;
pub const BLE_GATT_CHR_F_READ: u32 = 2;
pub const BLE_GATT_CHR_F_WRITE_NO_RSP: u32 = 4;
pub const BLE_GATT_CHR_F_WRITE: u32 = 8;
pub const BLE_GATT_CHR_F_NOTIFY: u32 = 16;
pub const BLE_GATT_CHR_F_INDICATE: u32 = 32;
pub const BLE_GATT_CHR_F_AUTH_SIGN_WRITE: u32 = 64;
pub const BLE_GATT_CHR_F_RELIABLE_WRITE: u32 = 128;
pub const BLE_GATT_CHR_F_AUX_WRITE: u32 = 256;
pub const BLE_GATT_CHR_F_READ_ENC: u32 = 512;
pub const BLE_GATT_CHR_F_READ_AUTHEN: u32 = 1024;
pub const BLE_GATT_CHR_F_READ_AUTHOR: u32 = 2048;
pub const BLE_GATT_CHR_F_WRITE_ENC: u32 = 4096;
pub const BLE_GATT_CHR_F_WRITE_AUTHEN: u32 = 8192;
pub const BLE_GATT_CHR_F_WRITE_AUTHOR: u32 = 16384;
pub const BLE_GATT_SVC_TYPE_END: u32 = 0;
pub const BLE_GATT_SVC_TYPE_PRIMARY: u32 = 1;
pub const BLE_GATT_SVC_TYPE_SECONDARY: u32 = 2;
pub const MODLOG_MODULE_DFLT: u32 = 255;
pub const BLE_L2CAP_CID_ATT: u32 = 4;
pub const BLE_L2CAP_CID_SIG: u32 = 5;
pub const BLE_L2CAP_CID_SM: u32 = 6;
pub const BLE_L2CAP_SIG_OP_REJECT: u32 = 1;
pub const BLE_L2CAP_SIG_OP_CONNECT_REQ: u32 = 2;
pub const BLE_L2CAP_SIG_OP_CONNECT_RSP: u32 = 3;
pub const BLE_L2CAP_SIG_OP_CONFIG_REQ: u32 = 4;
pub const BLE_L2CAP_SIG_OP_CONFIG_RSP: u32 = 5;
pub const BLE_L2CAP_SIG_OP_DISCONN_REQ: u32 = 6;
pub const BLE_L2CAP_SIG_OP_DISCONN_RSP: u32 = 7;
pub const BLE_L2CAP_SIG_OP_ECHO_REQ: u32 = 8;
pub const BLE_L2CAP_SIG_OP_ECHO_RSP: u32 = 9;
pub const BLE_L2CAP_SIG_OP_INFO_REQ: u32 = 10;
pub const BLE_L2CAP_SIG_OP_INFO_RSP: u32 = 11;
pub const BLE_L2CAP_SIG_OP_CREATE_CHAN_REQ: u32 = 12;
pub const BLE_L2CAP_SIG_OP_CREATE_CHAN_RSP: u32 = 13;
pub const BLE_L2CAP_SIG_OP_MOVE_CHAN_REQ: u32 = 14;
pub const BLE_L2CAP_SIG_OP_MOVE_CHAN_RSP: u32 = 15;
pub const BLE_L2CAP_SIG_OP_MOVE_CHAN_CONF_REQ: u32 = 16;
pub const BLE_L2CAP_SIG_OP_MOVE_CHAN_CONF_RSP: u32 = 17;
pub const BLE_L2CAP_SIG_OP_UPDATE_REQ: u32 = 18;
pub const BLE_L2CAP_SIG_OP_UPDATE_RSP: u32 = 19;
pub const BLE_L2CAP_SIG_OP_CREDIT_CONNECT_REQ: u32 = 20;
pub const BLE_L2CAP_SIG_OP_CREDIT_CONNECT_RSP: u32 = 21;
pub const BLE_L2CAP_SIG_OP_FLOW_CTRL_CREDIT: u32 = 22;
pub const BLE_L2CAP_SIG_OP_MAX: u32 = 23;
pub const BLE_L2CAP_SIG_ERR_CMD_NOT_UNDERSTOOD: u32 = 0;
pub const BLE_L2CAP_SIG_ERR_MTU_EXCEEDED: u32 = 1;
pub const BLE_L2CAP_SIG_ERR_INVALID_CID: u32 = 2;
pub const BLE_L2CAP_COC_ERR_CONNECTION_SUCCESS: u32 = 0;
pub const BLE_L2CAP_COC_ERR_UNKNOWN_LE_PSM: u32 = 2;
pub const BLE_L2CAP_COC_ERR_NO_RESOURCES: u32 = 4;
pub const BLE_L2CAP_COC_ERR_INSUFFICIENT_AUTHEN: u32 = 5;
pub const BLE_L2CAP_COC_ERR_INSUFFICIENT_AUTHOR: u32 = 6;
pub const BLE_L2CAP_COC_ERR_INSUFFICIENT_KEY_SZ: u32 = 7;
pub const BLE_L2CAP_COC_ERR_INSUFFICIENT_ENC: u32 = 8;
pub const BLE_L2CAP_COC_ERR_INVALID_SOURCE_CID: u32 = 9;
pub const BLE_L2CAP_COC_ERR_SOURCE_CID_ALREADY_USED: u32 = 10;
pub const BLE_L2CAP_COC_ERR_UNACCEPTABLE_PARAMETERS: u32 = 11;
pub const BLE_L2CAP_EVENT_COC_CONNECTED: u32 = 0;
pub const BLE_L2CAP_EVENT_COC_DISCONNECTED: u32 = 1;
pub const BLE_L2CAP_EVENT_COC_ACCEPT: u32 = 2;
pub const BLE_L2CAP_EVENT_COC_DATA_RECEIVED: u32 = 3;
pub const BLE_SM_ERR_PASSKEY: u32 = 1;
pub const BLE_SM_ERR_OOB: u32 = 2;
pub const BLE_SM_ERR_AUTHREQ: u32 = 3;
pub const BLE_SM_ERR_CONFIRM_MISMATCH: u32 = 4;
pub const BLE_SM_ERR_PAIR_NOT_SUPP: u32 = 5;
pub const BLE_SM_ERR_ENC_KEY_SZ: u32 = 6;
pub const BLE_SM_ERR_CMD_NOT_SUPP: u32 = 7;
pub const BLE_SM_ERR_UNSPECIFIED: u32 = 8;
pub const BLE_SM_ERR_REPEATED: u32 = 9;
pub const BLE_SM_ERR_INVAL: u32 = 10;
pub const BLE_SM_ERR_DHKEY: u32 = 11;
pub const BLE_SM_ERR_NUMCMP: u32 = 12;
pub const BLE_SM_ERR_ALREADY: u32 = 13;
pub const BLE_SM_ERR_CROSS_TRANS: u32 = 14;
pub const BLE_SM_ERR_MAX_PLUS_1: u32 = 15;
pub const BLE_SM_PAIR_ALG_JW: u32 = 0;
pub const BLE_SM_PAIR_ALG_PASSKEY: u32 = 1;
pub const BLE_SM_PAIR_ALG_OOB: u32 = 2;
pub const BLE_SM_PAIR_ALG_NUMCMP: u32 = 3;
pub const BLE_SM_PAIR_KEY_DIST_ENC: u32 = 1;
pub const BLE_SM_PAIR_KEY_DIST_ID: u32 = 2;
pub const BLE_SM_PAIR_KEY_DIST_SIGN: u32 = 4;
pub const BLE_SM_PAIR_KEY_DIST_LINK: u32 = 8;
pub const BLE_SM_PAIR_KEY_DIST_RESERVED: u32 = 240;
pub const BLE_SM_IO_CAP_DISP_ONLY: u32 = 0;
pub const BLE_SM_IO_CAP_DISP_YES_NO: u32 = 1;
pub const BLE_SM_IO_CAP_KEYBOARD_ONLY: u32 = 2;
pub const BLE_SM_IO_CAP_NO_IO: u32 = 3;
pub const BLE_SM_IO_CAP_KEYBOARD_DISP: u32 = 4;
pub const BLE_SM_IO_CAP_RESERVED: u32 = 5;
pub const BLE_SM_PAIR_OOB_NO: u32 = 0;
pub const BLE_SM_PAIR_OOB_YES: u32 = 1;
pub const BLE_SM_PAIR_OOB_RESERVED: u32 = 2;
pub const BLE_SM_PAIR_AUTHREQ_BOND: u32 = 1;
pub const BLE_SM_PAIR_AUTHREQ_MITM: u32 = 4;
pub const BLE_SM_PAIR_AUTHREQ_SC: u32 = 8;
pub const BLE_SM_PAIR_AUTHREQ_KEYPRESS: u32 = 16;
pub const BLE_SM_PAIR_AUTHREQ_RESERVED: u32 = 226;
pub const BLE_SM_PAIR_KEY_SZ_MIN: u32 = 7;
pub const BLE_SM_PAIR_KEY_SZ_MAX: u32 = 16;
pub const BLE_SM_IOACT_NONE: u32 = 0;
pub const BLE_SM_IOACT_OOB: u32 = 1;
pub const BLE_SM_IOACT_INPUT: u32 = 2;
pub const BLE_SM_IOACT_DISP: u32 = 3;
pub const BLE_SM_IOACT_NUMCMP: u32 = 4;
pub const BLE_SM_IOACT_MAX_PLUS_ONE: u32 = 5;
pub const BLE_STORE_OBJ_TYPE_OUR_SEC: u32 = 1;
pub const BLE_STORE_OBJ_TYPE_PEER_SEC: u32 = 2;
pub const BLE_STORE_OBJ_TYPE_CCCD: u32 = 3;
pub const BLE_STORE_EVENT_OVERFLOW: u32 = 1;
pub const BLE_STORE_EVENT_FULL: u32 = 2;
pub const BLE_HS_CONN_HANDLE_NONE: u32 = 65535;
pub const BLE_HS_EAGAIN: u32 = 1;
pub const BLE_HS_EALREADY: u32 = 2;
pub const BLE_HS_EINVAL: u32 = 3;
pub const BLE_HS_EMSGSIZE: u32 = 4;
pub const BLE_HS_ENOENT: u32 = 5;
pub const BLE_HS_ENOMEM: u32 = 6;
pub const BLE_HS_ENOTCONN: u32 = 7;
pub const BLE_HS_ENOTSUP: u32 = 8;
pub const BLE_HS_EAPP: u32 = 9;
pub const BLE_HS_EBADDATA: u32 = 10;
pub const BLE_HS_EOS: u32 = 11;
pub const BLE_HS_ECONTROLLER: u32 = 12;
pub const BLE_HS_ETIMEOUT: u32 = 13;
pub const BLE_HS_EDONE: u32 = 14;
pub const BLE_HS_EBUSY: u32 = 15;
pub const BLE_HS_EREJECT: u32 = 16;
pub const BLE_HS_EUNKNOWN: u32 = 17;
pub const BLE_HS_EROLE: u32 = 18;
pub const BLE_HS_ETIMEOUT_HCI: u32 = 19;
pub const BLE_HS_ENOMEM_EVT: u32 = 20;
pub const BLE_HS_ENOADDR: u32 = 21;
pub const BLE_HS_ENOTSYNCED: u32 = 22;
pub const BLE_HS_EAUTHEN: u32 = 23;
pub const BLE_HS_EAUTHOR: u32 = 24;
pub const BLE_HS_EENCRYPT: u32 = 25;
pub const BLE_HS_EENCRYPT_KEY_SZ: u32 = 26;
pub const BLE_HS_ESTORE_CAP: u32 = 27;
pub const BLE_HS_ESTORE_FAIL: u32 = 28;
pub const BLE_HS_EPREEMPTED: u32 = 29;
pub const BLE_HS_EDISABLED: u32 = 30;
pub const BLE_HS_ERR_ATT_BASE: u32 = 256;
pub const BLE_HS_ERR_HCI_BASE: u32 = 512;
pub const BLE_HS_ERR_L2C_BASE: u32 = 768;
pub const BLE_HS_ERR_SM_US_BASE: u32 = 1024;
pub const BLE_HS_ERR_SM_PEER_BASE: u32 = 1280;
pub const BLE_HS_ERR_HW_BASE: u32 = 1536;
pub const BLE_HS_IO_DISPLAY_ONLY: u32 = 0;
pub const BLE_HS_IO_DISPLAY_YESNO: u32 = 1;
pub const BLE_HS_IO_KEYBOARD_ONLY: u32 = 2;
pub const BLE_HS_IO_NO_INPUT_OUTPUT: u32 = 3;
pub const BLE_HS_IO_KEYBOARD_DISPLAY: u32 = 4;
pub const BLE_SVC_GAP_UUID16: u32 = 6144;
pub const BLE_SVC_GAP_CHR_UUID16_DEVICE_NAME: u32 = 10752;
pub const BLE_SVC_GAP_CHR_UUID16_APPEARANCE: u32 = 10753;
pub const BLE_SVC_GAP_CHR_UUID16_PERIPH_PREF_CONN_PARAMS: u32 = 10756;
pub const BLE_SVC_GAP_CHR_UUID16_CENTRAL_ADDRESS_RESOLUTION: u32 = 10918;
pub const BLE_SVC_GAP_APPEARANCE_GEN_UNKNOWN: u32 = 0;
pub const BLE_SVC_GAP_APPEARANCE_GEN_COMPUTER: u32 = 128;
pub const BLE_SVC_GAP_APPEARANCE_CYC_SPEED_AND_CADENCE_SENSOR: u32 = 1157;
pub const BLE_SVC_GATT_CHR_SERVICE_CHANGED_UUID16: u32 = 10757;
pub const portTICK_PERIOD_MS: u32 = 10;
pub type _off_t = ::std::os::raw::c_long;
pub type __dev_t = ::std::os::raw::c_short;
pub type __uid_t = ::std::os::raw::c_ushort;
pub type __gid_t = ::std::os::raw::c_ushort;
pub type _ssize_t = ::std::os::raw::c_int;
pub type _lock_t = ::std::os::raw::c_int;
pub type _LOCK_RECURSIVE_T = _lock_t;
pub type _LOCK_T = _lock_t;
pub type _data = *mut _reent;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __intptr_t = ::std::os::raw::c_int;
pub type __uintptr_t = ::std::os::raw::c_uint;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type int_fast16_t = ::std::os::raw::c_short;
pub type uint_fast16_t = ::std::os::raw::c_ushort;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
extern "C" {
    pub fn __assert(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert_func(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uart_dev_s {
    pub fifo: uart_dev_s__bindgen_ty_1,
    pub int_raw: uart_dev_s__bindgen_ty_2,
    pub int_st: uart_dev_s__bindgen_ty_3,
    pub int_ena: uart_dev_s__bindgen_ty_4,
    pub int_clr: uart_dev_s__bindgen_ty_5,
    pub clk_div: uart_dev_s__bindgen_ty_6,
    pub auto_baud: uart_dev_s__bindgen_ty_7,
    pub status: uart_dev_s__bindgen_ty_8,
    pub conf0: uart_dev_s__bindgen_ty_9,
    pub conf1: uart_dev_s__bindgen_ty_10,
    pub lowpulse: uart_dev_s__bindgen_ty_11,
    pub highpulse: uart_dev_s__bindgen_ty_12,
    pub rxd_cnt: uart_dev_s__bindgen_ty_13,
    pub flow_conf: uart_dev_s__bindgen_ty_14,
    pub sleep_conf: uart_dev_s__bindgen_ty_15,
    pub swfc_conf: uart_dev_s__bindgen_ty_16,
    pub idle_conf: uart_dev_s__bindgen_ty_17,
    pub rs485_conf: uart_dev_s__bindgen_ty_18,
    pub at_cmd_precnt: uart_dev_s__bindgen_ty_19,
    pub at_cmd_postcnt: uart_dev_s__bindgen_ty_20,
    pub at_cmd_gaptout: uart_dev_s__bindgen_ty_21,
    pub at_cmd_char: uart_dev_s__bindgen_ty_22,
    pub mem_conf: uart_dev_s__bindgen_ty_23,
    pub mem_tx_status: uart_dev_s__bindgen_ty_24,
    pub mem_rx_status: uart_dev_s__bindgen_ty_25,
    pub mem_cnt_status: uart_dev_s__bindgen_ty_26,
    pub pospulse: uart_dev_s__bindgen_ty_27,
    pub negpulse: uart_dev_s__bindgen_ty_28,
    pub reserved_70: u32,
    pub reserved_74: u32,
    pub date: u32,
    pub id: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub rw_byte: u8,
    pub reserved: [u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl uart_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn rxfifo_full(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_full(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txfifo_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn parity_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parity_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frm_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frm_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsr_chg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsr_chg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cts_chg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cts_chg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn brk_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brk_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_tout(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_tout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_xon(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_xon(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_xoff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_xoff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn glitch_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_glitch_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_idle_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_idle_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_parity_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_parity_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_frm_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_frm_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_clash(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_clash(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn at_cmd_char_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_at_cmd_char_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rxfifo_full: u32,
        txfifo_empty: u32,
        parity_err: u32,
        frm_err: u32,
        rxfifo_ovf: u32,
        dsr_chg: u32,
        cts_chg: u32,
        brk_det: u32,
        rxfifo_tout: u32,
        sw_xon: u32,
        sw_xoff: u32,
        glitch_det: u32,
        tx_brk_done: u32,
        tx_brk_idle_done: u32,
        tx_done: u32,
        rs485_parity_err: u32,
        rs485_frm_err: u32,
        rs485_clash: u32,
        at_cmd_char_det: u32,
        reserved19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rxfifo_full: u32 = unsafe { ::core::mem::transmute(rxfifo_full) };
            rxfifo_full as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let txfifo_empty: u32 = unsafe { ::core::mem::transmute(txfifo_empty) };
            txfifo_empty as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let parity_err: u32 = unsafe { ::core::mem::transmute(parity_err) };
            parity_err as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frm_err: u32 = unsafe { ::core::mem::transmute(frm_err) };
            frm_err as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rxfifo_ovf: u32 = unsafe { ::core::mem::transmute(rxfifo_ovf) };
            rxfifo_ovf as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsr_chg: u32 = unsafe { ::core::mem::transmute(dsr_chg) };
            dsr_chg as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cts_chg: u32 = unsafe { ::core::mem::transmute(cts_chg) };
            cts_chg as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let brk_det: u32 = unsafe { ::core::mem::transmute(brk_det) };
            brk_det as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rxfifo_tout: u32 = unsafe { ::core::mem::transmute(rxfifo_tout) };
            rxfifo_tout as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_xon: u32 = unsafe { ::core::mem::transmute(sw_xon) };
            sw_xon as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sw_xoff: u32 = unsafe { ::core::mem::transmute(sw_xoff) };
            sw_xoff as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let glitch_det: u32 = unsafe { ::core::mem::transmute(glitch_det) };
            glitch_det as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tx_brk_done: u32 = unsafe { ::core::mem::transmute(tx_brk_done) };
            tx_brk_done as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tx_brk_idle_done: u32 = unsafe { ::core::mem::transmute(tx_brk_idle_done) };
            tx_brk_idle_done as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done: u32 = unsafe { ::core::mem::transmute(tx_done) };
            tx_done as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rs485_parity_err: u32 = unsafe { ::core::mem::transmute(rs485_parity_err) };
            rs485_parity_err as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rs485_frm_err: u32 = unsafe { ::core::mem::transmute(rs485_frm_err) };
            rs485_frm_err as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rs485_clash: u32 = unsafe { ::core::mem::transmute(rs485_clash) };
            rs485_clash as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let at_cmd_char_det: u32 = unsafe { ::core::mem::transmute(at_cmd_char_det) };
            at_cmd_char_det as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved19: u32 = unsafe { ::core::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl uart_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn rxfifo_full(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_full(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txfifo_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn parity_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parity_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frm_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frm_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsr_chg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsr_chg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cts_chg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cts_chg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn brk_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brk_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_tout(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_tout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_xon(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_xon(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_xoff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_xoff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn glitch_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_glitch_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_idle_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_idle_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_parity_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_parity_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_frm_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_frm_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_clash(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_clash(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn at_cmd_char_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_at_cmd_char_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rxfifo_full: u32,
        txfifo_empty: u32,
        parity_err: u32,
        frm_err: u32,
        rxfifo_ovf: u32,
        dsr_chg: u32,
        cts_chg: u32,
        brk_det: u32,
        rxfifo_tout: u32,
        sw_xon: u32,
        sw_xoff: u32,
        glitch_det: u32,
        tx_brk_done: u32,
        tx_brk_idle_done: u32,
        tx_done: u32,
        rs485_parity_err: u32,
        rs485_frm_err: u32,
        rs485_clash: u32,
        at_cmd_char_det: u32,
        reserved19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rxfifo_full: u32 = unsafe { ::core::mem::transmute(rxfifo_full) };
            rxfifo_full as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let txfifo_empty: u32 = unsafe { ::core::mem::transmute(txfifo_empty) };
            txfifo_empty as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let parity_err: u32 = unsafe { ::core::mem::transmute(parity_err) };
            parity_err as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frm_err: u32 = unsafe { ::core::mem::transmute(frm_err) };
            frm_err as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rxfifo_ovf: u32 = unsafe { ::core::mem::transmute(rxfifo_ovf) };
            rxfifo_ovf as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsr_chg: u32 = unsafe { ::core::mem::transmute(dsr_chg) };
            dsr_chg as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cts_chg: u32 = unsafe { ::core::mem::transmute(cts_chg) };
            cts_chg as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let brk_det: u32 = unsafe { ::core::mem::transmute(brk_det) };
            brk_det as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rxfifo_tout: u32 = unsafe { ::core::mem::transmute(rxfifo_tout) };
            rxfifo_tout as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_xon: u32 = unsafe { ::core::mem::transmute(sw_xon) };
            sw_xon as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sw_xoff: u32 = unsafe { ::core::mem::transmute(sw_xoff) };
            sw_xoff as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let glitch_det: u32 = unsafe { ::core::mem::transmute(glitch_det) };
            glitch_det as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tx_brk_done: u32 = unsafe { ::core::mem::transmute(tx_brk_done) };
            tx_brk_done as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tx_brk_idle_done: u32 = unsafe { ::core::mem::transmute(tx_brk_idle_done) };
            tx_brk_idle_done as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done: u32 = unsafe { ::core::mem::transmute(tx_done) };
            tx_done as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rs485_parity_err: u32 = unsafe { ::core::mem::transmute(rs485_parity_err) };
            rs485_parity_err as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rs485_frm_err: u32 = unsafe { ::core::mem::transmute(rs485_frm_err) };
            rs485_frm_err as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rs485_clash: u32 = unsafe { ::core::mem::transmute(rs485_clash) };
            rs485_clash as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let at_cmd_char_det: u32 = unsafe { ::core::mem::transmute(at_cmd_char_det) };
            at_cmd_char_det as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved19: u32 = unsafe { ::core::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl uart_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn rxfifo_full(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_full(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txfifo_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn parity_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parity_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frm_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frm_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsr_chg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsr_chg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cts_chg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cts_chg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn brk_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brk_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_tout(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_tout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_xon(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_xon(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_xoff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_xoff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn glitch_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_glitch_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_idle_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_idle_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_parity_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_parity_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_frm_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_frm_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_clash(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_clash(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn at_cmd_char_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_at_cmd_char_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rxfifo_full: u32,
        txfifo_empty: u32,
        parity_err: u32,
        frm_err: u32,
        rxfifo_ovf: u32,
        dsr_chg: u32,
        cts_chg: u32,
        brk_det: u32,
        rxfifo_tout: u32,
        sw_xon: u32,
        sw_xoff: u32,
        glitch_det: u32,
        tx_brk_done: u32,
        tx_brk_idle_done: u32,
        tx_done: u32,
        rs485_parity_err: u32,
        rs485_frm_err: u32,
        rs485_clash: u32,
        at_cmd_char_det: u32,
        reserved19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rxfifo_full: u32 = unsafe { ::core::mem::transmute(rxfifo_full) };
            rxfifo_full as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let txfifo_empty: u32 = unsafe { ::core::mem::transmute(txfifo_empty) };
            txfifo_empty as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let parity_err: u32 = unsafe { ::core::mem::transmute(parity_err) };
            parity_err as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frm_err: u32 = unsafe { ::core::mem::transmute(frm_err) };
            frm_err as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rxfifo_ovf: u32 = unsafe { ::core::mem::transmute(rxfifo_ovf) };
            rxfifo_ovf as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsr_chg: u32 = unsafe { ::core::mem::transmute(dsr_chg) };
            dsr_chg as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cts_chg: u32 = unsafe { ::core::mem::transmute(cts_chg) };
            cts_chg as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let brk_det: u32 = unsafe { ::core::mem::transmute(brk_det) };
            brk_det as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rxfifo_tout: u32 = unsafe { ::core::mem::transmute(rxfifo_tout) };
            rxfifo_tout as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_xon: u32 = unsafe { ::core::mem::transmute(sw_xon) };
            sw_xon as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sw_xoff: u32 = unsafe { ::core::mem::transmute(sw_xoff) };
            sw_xoff as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let glitch_det: u32 = unsafe { ::core::mem::transmute(glitch_det) };
            glitch_det as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tx_brk_done: u32 = unsafe { ::core::mem::transmute(tx_brk_done) };
            tx_brk_done as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tx_brk_idle_done: u32 = unsafe { ::core::mem::transmute(tx_brk_idle_done) };
            tx_brk_idle_done as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done: u32 = unsafe { ::core::mem::transmute(tx_done) };
            tx_done as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rs485_parity_err: u32 = unsafe { ::core::mem::transmute(rs485_parity_err) };
            rs485_parity_err as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rs485_frm_err: u32 = unsafe { ::core::mem::transmute(rs485_frm_err) };
            rs485_frm_err as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rs485_clash: u32 = unsafe { ::core::mem::transmute(rs485_clash) };
            rs485_clash as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let at_cmd_char_det: u32 = unsafe { ::core::mem::transmute(at_cmd_char_det) };
            at_cmd_char_det as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved19: u32 = unsafe { ::core::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl uart_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn rxfifo_full(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_full(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txfifo_empty(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_empty(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn parity_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parity_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frm_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frm_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_ovf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_ovf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsr_chg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsr_chg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cts_chg(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cts_chg(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn brk_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brk_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_tout(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_tout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_xon(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_xon(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_xoff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_xoff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn glitch_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_glitch_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_idle_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_idle_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_done(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_parity_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_parity_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_frm_err(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_frm_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rs485_clash(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rs485_clash(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn at_cmd_char_det(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_at_cmd_char_det(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved19(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved19(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rxfifo_full: u32,
        txfifo_empty: u32,
        parity_err: u32,
        frm_err: u32,
        rxfifo_ovf: u32,
        dsr_chg: u32,
        cts_chg: u32,
        brk_det: u32,
        rxfifo_tout: u32,
        sw_xon: u32,
        sw_xoff: u32,
        glitch_det: u32,
        tx_brk_done: u32,
        tx_brk_idle_done: u32,
        tx_done: u32,
        rs485_parity_err: u32,
        rs485_frm_err: u32,
        rs485_clash: u32,
        at_cmd_char_det: u32,
        reserved19: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rxfifo_full: u32 = unsafe { ::core::mem::transmute(rxfifo_full) };
            rxfifo_full as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let txfifo_empty: u32 = unsafe { ::core::mem::transmute(txfifo_empty) };
            txfifo_empty as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let parity_err: u32 = unsafe { ::core::mem::transmute(parity_err) };
            parity_err as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let frm_err: u32 = unsafe { ::core::mem::transmute(frm_err) };
            frm_err as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rxfifo_ovf: u32 = unsafe { ::core::mem::transmute(rxfifo_ovf) };
            rxfifo_ovf as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsr_chg: u32 = unsafe { ::core::mem::transmute(dsr_chg) };
            dsr_chg as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cts_chg: u32 = unsafe { ::core::mem::transmute(cts_chg) };
            cts_chg as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let brk_det: u32 = unsafe { ::core::mem::transmute(brk_det) };
            brk_det as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let rxfifo_tout: u32 = unsafe { ::core::mem::transmute(rxfifo_tout) };
            rxfifo_tout as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_xon: u32 = unsafe { ::core::mem::transmute(sw_xon) };
            sw_xon as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let sw_xoff: u32 = unsafe { ::core::mem::transmute(sw_xoff) };
            sw_xoff as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let glitch_det: u32 = unsafe { ::core::mem::transmute(glitch_det) };
            glitch_det as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tx_brk_done: u32 = unsafe { ::core::mem::transmute(tx_brk_done) };
            tx_brk_done as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tx_brk_idle_done: u32 = unsafe { ::core::mem::transmute(tx_brk_idle_done) };
            tx_brk_idle_done as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tx_done: u32 = unsafe { ::core::mem::transmute(tx_done) };
            tx_done as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rs485_parity_err: u32 = unsafe { ::core::mem::transmute(rs485_parity_err) };
            rs485_parity_err as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let rs485_frm_err: u32 = unsafe { ::core::mem::transmute(rs485_frm_err) };
            rs485_frm_err as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rs485_clash: u32 = unsafe { ::core::mem::transmute(rs485_clash) };
            rs485_clash as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let at_cmd_char_det: u32 = unsafe { ::core::mem::transmute(at_cmd_char_det) };
            at_cmd_char_det as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved19: u32 = unsafe { ::core::mem::transmute(reserved19) };
            reserved19 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl uart_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn div_int(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_div_int(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn div_frag(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_div_frag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        div_int: u32,
        div_frag: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let div_int: u32 = unsafe { ::core::mem::transmute(div_int) };
            div_int as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let div_frag: u32 = unsafe { ::core::mem::transmute(div_frag) };
            div_frag as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl uart_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn glitch_filt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_glitch_filt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        en: u32,
        reserved1: u32,
        glitch_filt: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let en: u32 = unsafe { ::core::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let glitch_filt: u32 = unsafe { ::core::mem::transmute(glitch_filt) };
            glitch_filt as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl uart_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn rxfifo_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn st_urx_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_st_urx_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsrn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsrn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ctsn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ctsn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txfifo_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn st_utx_out(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_st_utx_out(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dtrn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dtrn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtsn(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rtsn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rxfifo_cnt: u32,
        st_urx_out: u32,
        reserved12: u32,
        dsrn: u32,
        ctsn: u32,
        rxd: u32,
        txfifo_cnt: u32,
        st_utx_out: u32,
        reserved28: u32,
        dtrn: u32,
        rtsn: u32,
        txd: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let rxfifo_cnt: u32 = unsafe { ::core::mem::transmute(rxfifo_cnt) };
            rxfifo_cnt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let st_urx_out: u32 = unsafe { ::core::mem::transmute(st_urx_out) };
            st_urx_out as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let dsrn: u32 = unsafe { ::core::mem::transmute(dsrn) };
            dsrn as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ctsn: u32 = unsafe { ::core::mem::transmute(ctsn) };
            ctsn as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rxd: u32 = unsafe { ::core::mem::transmute(rxd) };
            rxd as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let txfifo_cnt: u32 = unsafe { ::core::mem::transmute(txfifo_cnt) };
            txfifo_cnt as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let st_utx_out: u32 = unsafe { ::core::mem::transmute(st_utx_out) };
            st_utx_out as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let dtrn: u32 = unsafe { ::core::mem::transmute(dtrn) };
            dtrn as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rtsn: u32 = unsafe { ::core::mem::transmute(rtsn) };
            rtsn as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let txd: u32 = unsafe { ::core::mem::transmute(txd) };
            txd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl uart_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn parity(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parity(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn parity_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_parity_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bit_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_bit_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn stop_bit_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stop_bit_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_rts(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_rts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_dtr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_dtr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txd_brk(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txd_brk(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irda_dplx(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irda_dplx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irda_tx_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irda_tx_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irda_wctl(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irda_wctl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irda_tx_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irda_tx_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irda_rx_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irda_rx_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn loopback(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_loopback(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_flow_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_flow_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irda_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irda_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxfifo_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txfifo_rst(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_rst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxd_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxd_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cts_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cts_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsr_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsr_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txd_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txd_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rts_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rts_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dtr_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dtr_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clk_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clk_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn err_wr_mask(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_err_wr_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tick_ref_always_on(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tick_ref_always_on(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        parity: u32,
        parity_en: u32,
        bit_num: u32,
        stop_bit_num: u32,
        sw_rts: u32,
        sw_dtr: u32,
        txd_brk: u32,
        irda_dplx: u32,
        irda_tx_en: u32,
        irda_wctl: u32,
        irda_tx_inv: u32,
        irda_rx_inv: u32,
        loopback: u32,
        tx_flow_en: u32,
        irda_en: u32,
        rxfifo_rst: u32,
        txfifo_rst: u32,
        rxd_inv: u32,
        cts_inv: u32,
        dsr_inv: u32,
        txd_inv: u32,
        rts_inv: u32,
        dtr_inv: u32,
        clk_en: u32,
        err_wr_mask: u32,
        tick_ref_always_on: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let parity: u32 = unsafe { ::core::mem::transmute(parity) };
            parity as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let parity_en: u32 = unsafe { ::core::mem::transmute(parity_en) };
            parity_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let bit_num: u32 = unsafe { ::core::mem::transmute(bit_num) };
            bit_num as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let stop_bit_num: u32 = unsafe { ::core::mem::transmute(stop_bit_num) };
            stop_bit_num as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sw_rts: u32 = unsafe { ::core::mem::transmute(sw_rts) };
            sw_rts as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sw_dtr: u32 = unsafe { ::core::mem::transmute(sw_dtr) };
            sw_dtr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let txd_brk: u32 = unsafe { ::core::mem::transmute(txd_brk) };
            txd_brk as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let irda_dplx: u32 = unsafe { ::core::mem::transmute(irda_dplx) };
            irda_dplx as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let irda_tx_en: u32 = unsafe { ::core::mem::transmute(irda_tx_en) };
            irda_tx_en as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let irda_wctl: u32 = unsafe { ::core::mem::transmute(irda_wctl) };
            irda_wctl as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let irda_tx_inv: u32 = unsafe { ::core::mem::transmute(irda_tx_inv) };
            irda_tx_inv as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let irda_rx_inv: u32 = unsafe { ::core::mem::transmute(irda_rx_inv) };
            irda_rx_inv as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let loopback: u32 = unsafe { ::core::mem::transmute(loopback) };
            loopback as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let tx_flow_en: u32 = unsafe { ::core::mem::transmute(tx_flow_en) };
            tx_flow_en as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let irda_en: u32 = unsafe { ::core::mem::transmute(irda_en) };
            irda_en as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let rxfifo_rst: u32 = unsafe { ::core::mem::transmute(rxfifo_rst) };
            rxfifo_rst as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let txfifo_rst: u32 = unsafe { ::core::mem::transmute(txfifo_rst) };
            txfifo_rst as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let rxd_inv: u32 = unsafe { ::core::mem::transmute(rxd_inv) };
            rxd_inv as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let cts_inv: u32 = unsafe { ::core::mem::transmute(cts_inv) };
            cts_inv as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let dsr_inv: u32 = unsafe { ::core::mem::transmute(dsr_inv) };
            dsr_inv as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let txd_inv: u32 = unsafe { ::core::mem::transmute(txd_inv) };
            txd_inv as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let rts_inv: u32 = unsafe { ::core::mem::transmute(rts_inv) };
            rts_inv as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let dtr_inv: u32 = unsafe { ::core::mem::transmute(dtr_inv) };
            dtr_inv as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let clk_en: u32 = unsafe { ::core::mem::transmute(clk_en) };
            clk_en as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let err_wr_mask: u32 = unsafe { ::core::mem::transmute(err_wr_mask) };
            err_wr_mask as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let tick_ref_always_on: u32 = unsafe { ::core::mem::transmute(tick_ref_always_on) };
            tick_ref_always_on as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl uart_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn rxfifo_full_thrhd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_rxfifo_full_thrhd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txfifo_empty_thrhd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_txfifo_empty_thrhd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_flow_thrhd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_rx_flow_thrhd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_flow_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_flow_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_tout_thrhd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_rx_tout_thrhd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_tout_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_tout_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rxfifo_full_thrhd: u32,
        reserved7: u32,
        txfifo_empty_thrhd: u32,
        reserved15: u32,
        rx_flow_thrhd: u32,
        rx_flow_en: u32,
        rx_tout_thrhd: u32,
        rx_tout_en: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let rxfifo_full_thrhd: u32 = unsafe { ::core::mem::transmute(rxfifo_full_thrhd) };
            rxfifo_full_thrhd as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let reserved7: u32 = unsafe { ::core::mem::transmute(reserved7) };
            reserved7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 7u8, {
            let txfifo_empty_thrhd: u32 = unsafe { ::core::mem::transmute(txfifo_empty_thrhd) };
            txfifo_empty_thrhd as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let reserved15: u32 = unsafe { ::core::mem::transmute(reserved15) };
            reserved15 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 7u8, {
            let rx_flow_thrhd: u32 = unsafe { ::core::mem::transmute(rx_flow_thrhd) };
            rx_flow_thrhd as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let rx_flow_en: u32 = unsafe { ::core::mem::transmute(rx_flow_en) };
            rx_flow_en as u64
        });
        __bindgen_bitfield_unit.set(24usize, 7u8, {
            let rx_tout_thrhd: u32 = unsafe { ::core::mem::transmute(rx_tout_thrhd) };
            rx_tout_thrhd as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rx_tout_en: u32 = unsafe { ::core::mem::transmute(rx_tout_en) };
            rx_tout_en as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl uart_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn min_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_min_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        min_cnt: u32,
        reserved20: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let min_cnt: u32 = unsafe { ::core::mem::transmute(min_cnt) };
            min_cnt as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl uart_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn min_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_min_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        min_cnt: u32,
        reserved20: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let min_cnt: u32 = unsafe { ::core::mem::transmute(min_cnt) };
            min_cnt as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl uart_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn edge_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_edge_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        edge_cnt: u32,
        reserved10: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let edge_cnt: u32 = unsafe { ::core::mem::transmute(edge_cnt) };
            edge_cnt as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reserved10: u32 = unsafe { ::core::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl uart_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn sw_flow_con_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw_flow_con_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn xonoff_del(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_xonoff_del(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_xon(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_xon(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_xoff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_xoff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn send_xon(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_send_xon(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn send_xoff(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_send_xoff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sw_flow_con_en: u32,
        xonoff_del: u32,
        force_xon: u32,
        force_xoff: u32,
        send_xon: u32,
        send_xoff: u32,
        reserved6: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sw_flow_con_en: u32 = unsafe { ::core::mem::transmute(sw_flow_con_en) };
            sw_flow_con_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let xonoff_del: u32 = unsafe { ::core::mem::transmute(xonoff_del) };
            xonoff_del as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let force_xon: u32 = unsafe { ::core::mem::transmute(force_xon) };
            force_xon as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let force_xoff: u32 = unsafe { ::core::mem::transmute(force_xoff) };
            force_xoff as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let send_xon: u32 = unsafe { ::core::mem::transmute(send_xon) };
            send_xon as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let send_xoff: u32 = unsafe { ::core::mem::transmute(send_xoff) };
            send_xoff as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved6: u32 = unsafe { ::core::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl uart_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn active_threshold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_active_threshold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active_threshold: u32,
        reserved10: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let active_threshold: u32 = unsafe { ::core::mem::transmute(active_threshold) };
            active_threshold as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reserved10: u32 = unsafe { ::core::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl uart_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn xon_threshold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_xon_threshold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn xoff_threshold(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_xoff_threshold(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn xon_char(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_xon_char(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn xoff_char(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_xoff_char(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        xon_threshold: u32,
        xoff_threshold: u32,
        xon_char: u32,
        xoff_char: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let xon_threshold: u32 = unsafe { ::core::mem::transmute(xon_threshold) };
            xon_threshold as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let xoff_threshold: u32 = unsafe { ::core::mem::transmute(xoff_threshold) };
            xoff_threshold as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let xon_char: u32 = unsafe { ::core::mem::transmute(xon_char) };
            xon_char as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let xoff_char: u32 = unsafe { ::core::mem::transmute(xoff_char) };
            xoff_char as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl uart_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn rx_idle_thrhd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_rx_idle_thrhd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_idle_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_tx_idle_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_brk_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tx_brk_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved28(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved28(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_idle_thrhd: u32,
        tx_idle_num: u32,
        tx_brk_num: u32,
        reserved28: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let rx_idle_thrhd: u32 = unsafe { ::core::mem::transmute(rx_idle_thrhd) };
            rx_idle_thrhd as u64
        });
        __bindgen_bitfield_unit.set(10usize, 10u8, {
            let tx_idle_num: u32 = unsafe { ::core::mem::transmute(tx_idle_num) };
            tx_idle_num as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let tx_brk_num: u32 = unsafe { ::core::mem::transmute(tx_brk_num) };
            tx_brk_num as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved28: u32 = unsafe { ::core::mem::transmute(reserved28) };
            reserved28 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl uart_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl0_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl0_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl1_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl1_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_rx_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_rx_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_busy_tx_en(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_busy_tx_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_dly_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rx_dly_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_dly_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tx_dly_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        en: u32,
        dl0_en: u32,
        dl1_en: u32,
        tx_rx_en: u32,
        rx_busy_tx_en: u32,
        rx_dly_num: u32,
        tx_dly_num: u32,
        reserved10: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let en: u32 = unsafe { ::core::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dl0_en: u32 = unsafe { ::core::mem::transmute(dl0_en) };
            dl0_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dl1_en: u32 = unsafe { ::core::mem::transmute(dl1_en) };
            dl1_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tx_rx_en: u32 = unsafe { ::core::mem::transmute(tx_rx_en) };
            tx_rx_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rx_busy_tx_en: u32 = unsafe { ::core::mem::transmute(rx_busy_tx_en) };
            rx_busy_tx_en as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rx_dly_num: u32 = unsafe { ::core::mem::transmute(rx_dly_num) };
            rx_dly_num as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let tx_dly_num: u32 = unsafe { ::core::mem::transmute(tx_dly_num) };
            tx_dly_num as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reserved10: u32 = unsafe { ::core::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl uart_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn pre_idle_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_pre_idle_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pre_idle_num: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let pre_idle_num: u32 = unsafe { ::core::mem::transmute(pre_idle_num) };
            pre_idle_num as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl uart_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn post_idle_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_post_idle_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        post_idle_num: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let post_idle_num: u32 = unsafe { ::core::mem::transmute(post_idle_num) };
            post_idle_num as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl uart_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn rx_gap_tout(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_rx_gap_tout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_gap_tout: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let rx_gap_tout: u32 = unsafe { ::core::mem::transmute(rx_gap_tout) };
            rx_gap_tout as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl uart_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn char_num(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_char_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        data: u32,
        char_num: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let char_num: u32 = unsafe { ::core::mem::transmute(char_num) };
            char_num as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_23 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_23__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_23__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
}
impl uart_dev_s__bindgen_ty_23__bindgen_ty_1 {
    #[inline]
    pub fn mem_pd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mem_pd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_size(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rx_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_size(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tx_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_flow_thrhd_h3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rx_flow_thrhd_h3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_tout_thrhd_h3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rx_tout_thrhd_h3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn xon_threshold_h2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_xon_threshold_h2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn xoff_threshold_h2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_xoff_threshold_h2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rx_mem_full_thrhd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rx_mem_full_thrhd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_mem_empty_thrhd(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_tx_mem_empty_thrhd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved31(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved31(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mem_pd: u32,
        reserved1: u32,
        reserved2: u32,
        rx_size: u32,
        tx_size: u32,
        reserved11: u32,
        rx_flow_thrhd_h3: u32,
        rx_tout_thrhd_h3: u32,
        xon_threshold_h2: u32,
        xoff_threshold_h2: u32,
        rx_mem_full_thrhd: u32,
        tx_mem_empty_thrhd: u32,
        reserved31: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mem_pd: u32 = unsafe { ::core::mem::transmute(mem_pd) };
            mem_pd as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let reserved1: u32 = unsafe { ::core::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let rx_size: u32 = unsafe { ::core::mem::transmute(rx_size) };
            rx_size as u64
        });
        __bindgen_bitfield_unit.set(7usize, 4u8, {
            let tx_size: u32 = unsafe { ::core::mem::transmute(tx_size) };
            tx_size as u64
        });
        __bindgen_bitfield_unit.set(11usize, 4u8, {
            let reserved11: u32 = unsafe { ::core::mem::transmute(reserved11) };
            reserved11 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 3u8, {
            let rx_flow_thrhd_h3: u32 = unsafe { ::core::mem::transmute(rx_flow_thrhd_h3) };
            rx_flow_thrhd_h3 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 3u8, {
            let rx_tout_thrhd_h3: u32 = unsafe { ::core::mem::transmute(rx_tout_thrhd_h3) };
            rx_tout_thrhd_h3 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let xon_threshold_h2: u32 = unsafe { ::core::mem::transmute(xon_threshold_h2) };
            xon_threshold_h2 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 2u8, {
            let xoff_threshold_h2: u32 = unsafe { ::core::mem::transmute(xoff_threshold_h2) };
            xoff_threshold_h2 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 3u8, {
            let rx_mem_full_thrhd: u32 = unsafe { ::core::mem::transmute(rx_mem_full_thrhd) };
            rx_mem_full_thrhd as u64
        });
        __bindgen_bitfield_unit.set(28usize, 3u8, {
            let tx_mem_empty_thrhd: u32 = unsafe { ::core::mem::transmute(tx_mem_empty_thrhd) };
            tx_mem_empty_thrhd as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let reserved31: u32 = unsafe { ::core::mem::transmute(reserved31) };
            reserved31 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_24 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_24__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_24__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl uart_dev_s__bindgen_ty_24__bindgen_ty_1 {
    #[inline]
    pub fn status(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_status(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        status: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let status: u32 = unsafe { ::core::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_25 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_25__bindgen_ty_1,
    pub __bindgen_anon_2: uart_dev_s__bindgen_ty_25__bindgen_ty_2,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_25__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl uart_dev_s__bindgen_ty_25__bindgen_ty_1 {
    #[inline]
    pub fn status(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_status(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved24(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved24(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        status: u32,
        reserved24: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let status: u32 = unsafe { ::core::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved24: u32 = unsafe { ::core::mem::transmute(reserved24) };
            reserved24 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_25__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl uart_dev_s__bindgen_ty_25__bindgen_ty_2 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rd_addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_rd_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn wr_addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_wr_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        rd_addr: u32,
        wr_addr: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 11u8, {
            let rd_addr: u32 = unsafe { ::core::mem::transmute(rd_addr) };
            rd_addr as u64
        });
        __bindgen_bitfield_unit.set(13usize, 11u8, {
            let wr_addr: u32 = unsafe { ::core::mem::transmute(wr_addr) };
            wr_addr as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_26 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_26__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_26__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl uart_dev_s__bindgen_ty_26__bindgen_ty_1 {
    #[inline]
    pub fn rx_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rx_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_tx_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rx_cnt: u32,
        tx_cnt: u32,
        reserved6: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let rx_cnt: u32 = unsafe { ::core::mem::transmute(rx_cnt) };
            rx_cnt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let tx_cnt: u32 = unsafe { ::core::mem::transmute(tx_cnt) };
            tx_cnt as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved6: u32 = unsafe { ::core::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_27 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_27__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_27__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl uart_dev_s__bindgen_ty_27__bindgen_ty_1 {
    #[inline]
    pub fn min_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_min_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        min_cnt: u32,
        reserved20: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let min_cnt: u32 = unsafe { ::core::mem::transmute(min_cnt) };
            min_cnt as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uart_dev_s__bindgen_ty_28 {
    pub __bindgen_anon_1: uart_dev_s__bindgen_ty_28__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct uart_dev_s__bindgen_ty_28__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl uart_dev_s__bindgen_ty_28__bindgen_ty_1 {
    #[inline]
    pub fn min_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_min_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        min_cnt: u32,
        reserved20: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let min_cnt: u32 = unsafe { ::core::mem::transmute(min_cnt) };
            min_cnt as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type uart_dev_t = uart_dev_s;
extern "C" {
    pub static mut UART0: uart_dev_t;
}
extern "C" {
    pub static mut UART1: uart_dev_t;
}
extern "C" {
    pub static mut UART2: uart_dev_t;
}
pub type size_t = ::std::os::raw::c_uint;
pub type wchar_t = ::std::os::raw::c_uchar;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __off_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
pub type __loff_t = ::std::os::raw::c_longlong;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type ulong = ::std::os::raw::c_ulong;
pub type clock_t = ::std::os::raw::c_ulong;
pub type time_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type daddr_t = ::std::os::raw::c_long;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type ino_t = ::std::os::raw::c_ushort;
pub type off_t = _off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = ::std::os::raw::c_int;
pub type key_t = ::std::os::raw::c_long;
pub type ssize_t = _ssize_t;
pub type mode_t = ::std::os::raw::c_uint;
pub type nlink_t = ::std::os::raw::c_ushort;
pub type fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 2usize],
}
pub type clockid_t = ::std::os::raw::c_ulong;
pub type timer_t = ::std::os::raw::c_ulong;
pub type useconds_t = ::std::os::raw::c_ulong;
pub type suseconds_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: ::std::os::raw::c_int,
    pub stackaddr: *mut ::core::ffi::c_void,
    pub stacksize: ::std::os::raw::c_int,
    pub contentionscope: ::std::os::raw::c_int,
    pub inheritsched: ::std::os::raw::c_int,
    pub schedpolicy: ::std::os::raw::c_int,
    pub schedparam: sched_param,
    pub detachstate: ::std::os::raw::c_int,
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub recursive: ::std::os::raw::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: ::std::os::raw::c_int,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: ::std::os::raw::c_int,
    pub init_executed: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        _s: *mut ::std::os::raw::c_char,
        _maxsize: size_t,
        _fmt: *const ::std::os::raw::c_char,
        _t: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tzrule_struct {
    pub ch: ::std::os::raw::c_char,
    pub m: ::std::os::raw::c_int,
    pub n: ::std::os::raw::c_int,
    pub d: ::std::os::raw::c_int,
    pub s: ::std::os::raw::c_int,
    pub change: time_t,
    pub offset: ::std::os::raw::c_long,
}
pub type __tzrule_type = __tzrule_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tzinfo_struct {
    pub __tznorth: ::std::os::raw::c_int,
    pub __tzyear: ::std::os::raw::c_int,
    pub __tzrule: [__tzrule_type; 2usize],
}
pub type __tzinfo_type = __tzinfo_struct;
extern "C" {
    pub fn __gettzinfo() -> *mut __tzinfo_type;
}
extern "C" {
    pub static mut _timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut _daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn _lock_acquire(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_close(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_init(lock: *mut _lock_t);
}
extern "C" {
    pub fn _lock_release(lock: *mut _lock_t);
}
pub type _off64_t = ::std::os::raw::c_longlong;
pub type _fpos_t = ::std::os::raw::c_long;
pub type wint_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::std::os::raw::c_uchar; 4usize],
    _bindgen_union_align: u32,
}
pub type _flock_t = _LOCK_RECURSIVE_T;
pub type _iconv_t = *mut ::core::ffi::c_void;
pub type __ULong = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::std::os::raw::c_int,
    pub _maxwds: ::std::os::raw::c_int,
    pub _sign: ::std::os::raw::c_int,
    pub _wds: ::std::os::raw::c_int,
    pub _x: [__ULong; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::std::os::raw::c_int,
    pub __tm_min: ::std::os::raw::c_int,
    pub __tm_hour: ::std::os::raw::c_int,
    pub __tm_mday: ::std::os::raw::c_int,
    pub __tm_mon: ::std::os::raw::c_int,
    pub __tm_year: ::std::os::raw::c_int,
    pub __tm_wday: ::std::os::raw::c_int,
    pub __tm_yday: ::std::os::raw::c_int,
    pub __tm_isdst: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::core::ffi::c_void; 32usize],
    pub _dso_handle: [*mut ::core::ffi::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::std::os::raw::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args_ptr: *mut _on_exit_args,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE_fake {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _data: *mut _reent,
}
extern "C" {
    pub fn __sinit(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _data: *mut _reent,
    pub _cookie: *mut ::core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *mut ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *const ::std::os::raw::c_char,
            arg4: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: _fpos_t,
            arg4: ::std::os::raw::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::std::os::raw::c_uchar,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: _off_t,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::std::os::raw::c_int,
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::std::os::raw::c_int,
    pub _iobs: *mut __FILE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::std::os::raw::c_ushort; 3usize],
    pub _mult: [::std::os::raw::c_ushort; 3usize],
    pub _add: ::std::os::raw::c_ushort,
    pub _rand_next: ::std::os::raw::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mprec {
    pub _result: *mut _Bigint,
    pub _result_k: ::std::os::raw::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _misc_reent {
    pub _strtok_last: *mut ::std::os::raw::c_char,
    pub _mblen_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _l64a_buf: [::std::os::raw::c_char; 8usize],
    pub _getdate_err: ::std::os::raw::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent {
    pub _errno: ::std::os::raw::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::std::os::raw::c_int,
    pub _emergency: *mut ::std::os::raw::c_char,
    pub __sdidinit: ::std::os::raw::c_int,
    pub _current_category: ::std::os::raw::c_int,
    pub _current_locale: *const ::std::os::raw::c_char,
    pub _mp: *mut _mprec,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _gamma_signgam: ::std::os::raw::c_int,
    pub _cvtlen: ::std::os::raw::c_int,
    pub _cvtbuf: *mut ::std::os::raw::c_char,
    pub _r48: *mut _rand48,
    pub _localtime_buf: *mut __tm,
    pub _asctime_buf: *mut ::std::os::raw::c_char,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub __sglue: _glue,
    pub __sf: *mut __FILE,
    pub _misc: *mut _misc_reent,
    pub _signal_buf: *mut ::std::os::raw::c_char,
}
extern "C" {
    pub static __sf_fake_stdin: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stdout: __sFILE_fake;
}
extern "C" {
    pub static __sf_fake_stderr: __sFILE_fake;
}
extern "C" {
    pub static mut _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut ::core::ffi::c_void,
        _size: ::std::os::raw::c_uint,
        _n: ::std::os::raw::c_uint,
        arg2: *mut FILE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn fwrite(
        arg1: *const ::core::ffi::c_void,
        _size: ::std::os::raw::c_uint,
        _n: ::std::os::raw::c_uint,
        arg2: *mut FILE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fopen(
        _name: *const ::std::os::raw::c_char,
        _type: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko(
        arg1: *mut FILE,
        arg2: off_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut size_t,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut size_t,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn diprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fiprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fiscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_uint,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut size_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut size_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdiprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn viprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn viscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_uint,
        arg3: *const ::std::os::raw::c_char,
        arg4: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut ::core::ffi::c_void,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut size_t) -> *mut FILE;
}
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut size_t,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut size_t,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fgetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *mut fpos_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fsetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const fpos_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: ::std::os::raw::c_long,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_void,
        _size: size_t,
        _n: size_t,
        arg3: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _gets_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _iprintf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _printf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _remove_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const ::std::os::raw::c_char,
        _new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _scanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ungetc_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut size_t,
        arg4: *const ::std::os::raw::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *mut size_t,
        arg4: *const ::std::os::raw::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
        arg5: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
        arg5: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut size_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut size_t,
        arg3: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut ::core::ffi::c_void,
        _size: size_t,
        _n: size_t,
        arg2: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const ::core::ffi::c_void,
        _size: size_t,
        _n: size_t,
        arg2: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const ::core::ffi::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *mut ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *const ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __off: fpos_t,
                __whence: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const ::core::ffi::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *mut ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *const ::std::os::raw::c_char,
                __n: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __off: fpos_t,
                __whence: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
pub type cookie_read_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::core::ffi::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __n: size_t,
    ) -> ssize_t,
>;
pub type cookie_write_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::core::ffi::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ssize_t,
>;
pub type cookie_seek_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::core::ffi::c_void,
        __off: *mut off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::core::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
extern "C" {
    pub fn fopencookie(
        __cookie: *mut ::core::ffi::c_void,
        __mode: *const ::std::os::raw::c_char,
        __functions: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopencookie_r(
        arg1: *mut _reent,
        __cookie: *mut ::core::ffi::c_void,
        __mode: *const ::std::os::raw::c_char,
        __functions: cookie_io_functions_t,
    ) -> *mut FILE;
}
pub type esp_err_t = i32;
extern "C" {
    #[doc = " @brief Returns string for esp_err_t error codes"]
    #[doc = ""]
    #[doc = " This function finds the error code in a pre-generated lookup-table and"]
    #[doc = " returns its string representation."]
    #[doc = ""]
    #[doc = " The function is generated by the Python script"]
    #[doc = " tools/gen_esp_err_to_name.py which should be run each time an esp_err_t"]
    #[doc = " error is modified, created or removed from the IDF project."]
    #[doc = ""]
    #[doc = " @param code esp_err_t error code"]
    #[doc = " @return string error message"]
    pub fn esp_err_to_name(code: esp_err_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Returns string for esp_err_t and system error codes"]
    #[doc = ""]
    #[doc = " This function finds the error code in a pre-generated lookup-table of"]
    #[doc = " esp_err_t errors and returns its string representation. If the error code"]
    #[doc = " is not found then it is attempted to be found among system errors."]
    #[doc = ""]
    #[doc = " The function is generated by the Python script"]
    #[doc = " tools/gen_esp_err_to_name.py which should be run each time an esp_err_t"]
    #[doc = " error is modified, created or removed from the IDF project."]
    #[doc = ""]
    #[doc = " @param code esp_err_t error code"]
    #[doc = " @param[out] buf buffer where the error message should be written"]
    #[doc = " @param buflen Size of buffer buf. At most buflen bytes are written into the buf buffer (including the terminating null byte)."]
    #[doc = " @return buf containing the string error message"]
    pub fn esp_err_to_name_r(
        code: esp_err_t,
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed(
        rc: esp_err_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @cond"]
    pub fn _esp_error_check_failed_without_abort(
        rc: esp_err_t,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub static Xthal_rev_no: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_save_extra(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_extra(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_save_cpregs(base: *mut ::core::ffi::c_void, arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn xthal_restore_cpregs(base: *mut ::core::ffi::c_void, arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn xthal_save_cp0(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_save_cp1(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_save_cp2(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_save_cp3(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_save_cp4(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_save_cp5(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_save_cp6(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_save_cp7(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_cp0(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_cp1(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_cp2(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_cp3(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_cp4(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_cp5(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_cp6(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_restore_cp7(base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub static mut Xthal_cpregs_save_fn: [*mut ::core::ffi::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_restore_fn: [*mut ::core::ffi::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_save_nw_fn: [*mut ::core::ffi::c_void; 8usize];
}
extern "C" {
    pub static mut Xthal_cpregs_restore_nw_fn: [*mut ::core::ffi::c_void; 8usize];
}
extern "C" {
    pub static Xthal_extra_size: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_extra_align: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cpregs_size: [::std::os::raw::c_uint; 8usize];
}
extern "C" {
    pub static Xthal_cpregs_align: [::std::os::raw::c_uint; 8usize];
}
extern "C" {
    pub static Xthal_all_extra_size: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_all_extra_align: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_names: [*const ::std::os::raw::c_char; 8usize];
}
extern "C" {
    pub fn xthal_init_mem_extra(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_init_mem_cp(arg1: *mut ::core::ffi::c_void, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub static Xthal_num_coprocessors: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_num: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_max: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_num_aregs: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_num_aregs_log2: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_icache_linewidth: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_linewidth: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_icache_linesize: ::std::os::raw::c_ushort;
}
extern "C" {
    pub static Xthal_dcache_linesize: ::std::os::raw::c_ushort;
}
extern "C" {
    pub static Xthal_icache_size: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_dcache_size: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_dcache_is_writeback: ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn xthal_icache_region_invalidate(
        addr: *mut ::core::ffi::c_void,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn xthal_dcache_region_invalidate(
        addr: *mut ::core::ffi::c_void,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn xthal_icache_line_invalidate(addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_invalidate(addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_dcache_region_writeback(
        addr: *mut ::core::ffi::c_void,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn xthal_dcache_line_writeback(addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_dcache_region_writeback_inv(
        addr: *mut ::core::ffi::c_void,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn xthal_dcache_line_writeback_inv(addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_icache_sync();
}
extern "C" {
    pub fn xthal_dcache_sync();
}
extern "C" {
    pub fn xthal_icache_get_ways() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_icache_set_ways(ways: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_dcache_get_ways() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_dcache_set_ways(ways: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_cache_coherence_on();
}
extern "C" {
    pub fn xthal_cache_coherence_off();
}
extern "C" {
    pub fn xthal_cache_coherence_optin();
}
extern "C" {
    pub fn xthal_cache_coherence_optout();
}
extern "C" {
    pub fn xthal_get_cache_prefetch() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_cache_prefetch(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_cache_prefetch_long(
        arg1: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static Xthal_debug_configured: ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_soft_break(addr: *mut ::core::ffi::c_void) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_remove_soft_break(addr: *mut ::core::ffi::c_void, arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_disassemble(
        instr_buf: *mut ::std::os::raw::c_uchar,
        tgt_addr: *mut ::core::ffi::c_void,
        buffer: *mut ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_uint,
        options: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_disassemble_size(instr_buf: *mut ::std::os::raw::c_uchar)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_memcpy(
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        len: ::std::os::raw::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn xthal_bcopy(
        src: *const ::core::ffi::c_void,
        dst: *mut ::core::ffi::c_void,
        len: ::std::os::raw::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn xthal_compare_and_set(
        addr: *mut ::std::os::raw::c_int,
        test_val: ::std::os::raw::c_int,
        compare_val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static Xthal_release_major: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_release_minor: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_release_name: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static Xthal_release_internal: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static Xthal_memory_order: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_windowed: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_density: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_booleans: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_loops: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_nsa: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_minmax: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_sext: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_clamps: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_mac16: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_mul16: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_fp: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_speculation: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_threadptr: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_pif: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_writebuffer_entries: ::std::os::raw::c_ushort;
}
extern "C" {
    pub static Xthal_build_unique_id: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_hw_configid0: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_hw_configid1: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_major: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_minor: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_hw_release_name: *const ::std::os::raw::c_char;
}
extern "C" {
    pub static Xthal_hw_release_internal: *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn xthal_clear_regcached_code();
}
extern "C" {
    pub fn xthal_window_spill();
}
extern "C" {
    pub fn xthal_validate_cp(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn xthal_invalidate_cp(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn xthal_set_cpenable(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_get_cpenable() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_num_intlevels: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_interrupts: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_excm_level: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_intlevel_mask: [::std::os::raw::c_uint; 16usize];
}
extern "C" {
    pub static Xthal_intlevel_andbelow_mask: [::std::os::raw::c_uint; 16usize];
}
extern "C" {
    pub static Xthal_intlevel: [::std::os::raw::c_uchar; 32usize];
}
extern "C" {
    pub static Xthal_inttype: [::std::os::raw::c_uchar; 32usize];
}
extern "C" {
    pub static Xthal_inttype_mask: [::std::os::raw::c_uint; 8usize];
}
extern "C" {
    pub static Xthal_timer_interrupt: [::std::os::raw::c_int; 4usize];
}
extern "C" {
    pub fn xthal_get_intenable() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_intenable(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_get_interrupt() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_intset(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_set_intclear(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub static Xthal_num_ibreak: ::std::os::raw::c_int;
}
extern "C" {
    pub static Xthal_num_dbreak: ::std::os::raw::c_int;
}
extern "C" {
    pub static Xthal_have_ccount: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_ccompare: ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn xthal_get_ccount() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_ccompare(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_get_ccompare(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_have_prid: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_exceptions: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_xea_version: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_interrupts: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_highlevel_interrupts: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_nmi: ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn xthal_get_prid() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_vpri_to_intlevel(vpri: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_intlevel_to_vpri(intlevel: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_int_enable(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_int_disable(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_int_vpri(
        intnum: ::std::os::raw::c_int,
        vpri: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_get_int_vpri(intnum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_vpri_locklevel(intlevel: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_get_vpri_locklevel() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri(vpri: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_get_vpri() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri_intlevel(intlevel: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_vpri_lock() -> ::std::os::raw::c_uint;
}
pub type XtHalVoidFunc = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub static mut Xthal_tram_pending: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut Xthal_tram_enabled: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut Xthal_tram_sync: ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_tram_pending_to_service() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_tram_done(serviced_mask: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_tram_set_sync(
        intnum: ::std::os::raw::c_int,
        sync: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_tram_trigger_func(trigger_fn: XtHalVoidFunc) -> XtHalVoidFunc;
}
extern "C" {
    pub static Xthal_num_instrom: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_instram: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_datarom: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_dataram: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_num_xlmi: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static mut Xthal_instrom_vaddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instrom_paddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instrom_size: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_vaddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_paddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_instram_size: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_vaddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_paddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_datarom_size: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_vaddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_paddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_dataram_size: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_vaddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_paddr: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static mut Xthal_xlmi_size: [::std::os::raw::c_uint; 0usize];
}
extern "C" {
    pub static Xthal_icache_setwidth: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_setwidth: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_icache_ways: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_dcache_ways: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_icache_line_lockable: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dcache_line_lockable: ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn xthal_get_cacheattr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_get_icacheattr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_get_dcacheattr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn xthal_set_cacheattr(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_set_icacheattr(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_set_dcacheattr(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_set_region_attribute(
        addr: *mut ::core::ffi::c_void,
        size: ::std::os::raw::c_uint,
        cattr: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_icache_enable();
}
extern "C" {
    pub fn xthal_dcache_enable();
}
extern "C" {
    pub fn xthal_icache_disable();
}
extern "C" {
    pub fn xthal_dcache_disable();
}
extern "C" {
    pub fn xthal_icache_all_invalidate();
}
extern "C" {
    pub fn xthal_dcache_all_invalidate();
}
extern "C" {
    pub fn xthal_dcache_all_writeback();
}
extern "C" {
    pub fn xthal_dcache_all_writeback_inv();
}
extern "C" {
    pub fn xthal_icache_region_lock(addr: *mut ::core::ffi::c_void, size: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_lock(addr: *mut ::core::ffi::c_void, size: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_icache_line_lock(addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_lock(addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_icache_all_unlock();
}
extern "C" {
    pub fn xthal_dcache_all_unlock();
}
extern "C" {
    pub fn xthal_icache_region_unlock(addr: *mut ::core::ffi::c_void, size: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_dcache_region_unlock(addr: *mut ::core::ffi::c_void, size: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xthal_icache_line_unlock(addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_dcache_line_unlock(addr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xthal_memep_inject_error(
        addr: *mut ::core::ffi::c_void,
        size: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub static Xthal_have_spanning_way: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_identity_map: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_mimic_cacheattr: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_xlt_cacheattr: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_cacheattr: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_have_tlbs: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_asid_bits: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_asid_kernel: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_rings: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_ring_bits: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_sr_bits: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_ca_bits: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_mmu_max_pte_page_size: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_mmu_min_pte_page_size: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_itlb_way_bits: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_itlb_ways: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_itlb_arf_ways: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_way_bits: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_ways: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_dtlb_arf_ways: ::std::os::raw::c_uchar;
}
extern "C" {
    #[doc = " WARNING: these two functions may go away in a future release; don't depend on them!"]
    pub fn xthal_static_v2p(
        vaddr: ::std::os::raw::c_uint,
        paddrp: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_static_p2v(
        paddr: ::std::os::raw::c_uint,
        vaddrp: *mut ::std::os::raw::c_uint,
        cached: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_region_translation(
        vaddr: *mut ::core::ffi::c_void,
        paddr: *mut ::core::ffi::c_void,
        size: ::std::os::raw::c_uint,
        cache_atr: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_v2p(
        arg1: *mut ::core::ffi::c_void,
        arg2: *mut *mut ::core::ffi::c_void,
        arg3: *mut ::std::os::raw::c_uint,
        arg4: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_invalidate_region(addr: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xthal_set_region_translation_raw(
        vaddr: *mut ::core::ffi::c_void,
        paddr: *mut ::core::ffi::c_void,
        cattr: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static Xthal_cp_id_FPU: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_FPU: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP1_IDENT: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP1_IDENT: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP2_IDENT: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP2_IDENT: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP3_IDENT: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP3_IDENT: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP4_IDENT: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP4_IDENT: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP5_IDENT: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP5_IDENT: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP6_IDENT: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP6_IDENT: ::std::os::raw::c_uint;
}
extern "C" {
    pub static Xthal_cp_id_XCHAL_CP7_IDENT: ::std::os::raw::c_uchar;
}
extern "C" {
    pub static Xthal_cp_mask_XCHAL_CP7_IDENT: ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KernelFrame {
    pub pc: ::std::os::raw::c_long,
    pub ps: ::std::os::raw::c_long,
    pub areg: [::std::os::raw::c_long; 4usize],
    pub sar: ::std::os::raw::c_long,
    pub lcount: ::std::os::raw::c_long,
    pub lbeg: ::std::os::raw::c_long,
    pub lend: ::std::os::raw::c_long,
    pub acclo: ::std::os::raw::c_long,
    pub acchi: ::std::os::raw::c_long,
    pub mr: [::std::os::raw::c_long; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserFrame {
    pub pc: ::std::os::raw::c_long,
    pub ps: ::std::os::raw::c_long,
    pub sar: ::std::os::raw::c_long,
    pub vpri: ::std::os::raw::c_long,
    pub a2: ::std::os::raw::c_long,
    pub a3: ::std::os::raw::c_long,
    pub a4: ::std::os::raw::c_long,
    pub a5: ::std::os::raw::c_long,
    pub exccause: ::std::os::raw::c_long,
    pub lcount: ::std::os::raw::c_long,
    pub lbeg: ::std::os::raw::c_long,
    pub lend: ::std::os::raw::c_long,
    pub acclo: ::std::os::raw::c_long,
    pub acchi: ::std::os::raw::c_long,
    pub mr: [::std::os::raw::c_long; 4usize],
    pub pad: [::std::os::raw::c_long; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XtExcFrame {
    pub exit: ::std::os::raw::c_long,
    pub pc: ::std::os::raw::c_long,
    pub ps: ::std::os::raw::c_long,
    pub a0: ::std::os::raw::c_long,
    pub a1: ::std::os::raw::c_long,
    pub a2: ::std::os::raw::c_long,
    pub a3: ::std::os::raw::c_long,
    pub a4: ::std::os::raw::c_long,
    pub a5: ::std::os::raw::c_long,
    pub a6: ::std::os::raw::c_long,
    pub a7: ::std::os::raw::c_long,
    pub a8: ::std::os::raw::c_long,
    pub a9: ::std::os::raw::c_long,
    pub a10: ::std::os::raw::c_long,
    pub a11: ::std::os::raw::c_long,
    pub a12: ::std::os::raw::c_long,
    pub a13: ::std::os::raw::c_long,
    pub a14: ::std::os::raw::c_long,
    pub a15: ::std::os::raw::c_long,
    pub sar: ::std::os::raw::c_long,
    pub exccause: ::std::os::raw::c_long,
    pub excvaddr: ::std::os::raw::c_long,
    pub lbeg: ::std::os::raw::c_long,
    pub lend: ::std::os::raw::c_long,
    pub lcount: ::std::os::raw::c_long,
    pub tmp0: ::std::os::raw::c_long,
    pub tmp1: ::std::os::raw::c_long,
    pub tmp2: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XtSolFrame {
    pub exit: ::std::os::raw::c_long,
    pub pc: ::std::os::raw::c_long,
    pub ps: ::std::os::raw::c_long,
    pub next: ::std::os::raw::c_long,
    pub a0: ::std::os::raw::c_long,
    pub a1: ::std::os::raw::c_long,
    pub a2: ::std::os::raw::c_long,
    pub a3: ::std::os::raw::c_long,
}
pub type xt_handler = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub type xt_exc_handler = ::core::option::Option<unsafe extern "C" fn(arg1: *mut XtExcFrame)>;
extern "C" {
    pub fn xt_set_exception_handler(n: ::std::os::raw::c_int, f: xt_exc_handler) -> xt_exc_handler;
}
extern "C" {
    pub fn xt_set_interrupt_handler(
        n: ::std::os::raw::c_int,
        f: xt_handler,
        arg: *mut ::core::ffi::c_void,
    ) -> xt_handler;
}
extern "C" {
    pub fn xt_ints_on(mask: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xt_ints_off(mask: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn xt_get_interrupt_handler_arg(n: ::std::os::raw::c_int) -> *mut ::core::ffi::c_void;
}
pub type intr_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct intr_handle_data_t {
    _unused: [u8; 0],
}
pub type intr_handle_t = *mut intr_handle_data_t;
extern "C" {
    #[doc = " @brief Mark an interrupt as a shared interrupt"]
    #[doc = ""]
    #[doc = " This will mark a certain interrupt on the specified CPU as"]
    #[doc = " an interrupt that can be used to hook shared interrupt handlers"]
    #[doc = " to."]
    #[doc = ""]
    #[doc = " @param intno The number of the interrupt (0-31)"]
    #[doc = " @param cpu CPU on which the interrupt should be marked as shared (0 or 1)"]
    #[doc = " @param is_in_iram Shared interrupt is for handlers that reside in IRAM and"]
    #[doc = "                   the int can be left enabled while the flash cache is disabled."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if cpu or intno is invalid"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_mark_shared(
        intno: ::std::os::raw::c_int,
        cpu: ::std::os::raw::c_int,
        is_in_iram: bool,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reserve an interrupt to be used outside of this framework"]
    #[doc = ""]
    #[doc = " This will mark a certain interrupt on the specified CPU as"]
    #[doc = " reserved, not to be allocated for any reason."]
    #[doc = ""]
    #[doc = " @param intno The number of the interrupt (0-31)"]
    #[doc = " @param cpu CPU on which the interrupt should be marked as shared (0 or 1)"]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if cpu or intno is invalid"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_reserve(intno: ::std::os::raw::c_int, cpu: ::std::os::raw::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Allocate an interrupt with the given parameters."]
    #[doc = ""]
    #[doc = " This finds an interrupt that matches the restrictions as given in the flags"]
    #[doc = " parameter, maps the given interrupt source to it and hooks up the given"]
    #[doc = " interrupt handler (with optional argument) as well. If needed, it can return"]
    #[doc = " a handle for the interrupt as well."]
    #[doc = ""]
    #[doc = " The interrupt will always be allocated on the core that runs this function."]
    #[doc = ""]
    #[doc = " If ESP_INTR_FLAG_IRAM flag is used, and handler address is not in IRAM or"]
    #[doc = " RTC_FAST_MEM, then ESP_ERR_INVALID_ARG is returned."]
    #[doc = ""]
    #[doc = " @param source The interrupt source. One of the ETS_*_INTR_SOURCE interrupt mux"]
    #[doc = "               sources, as defined in soc/soc.h, or one of the internal"]
    #[doc = "               ETS_INTERNAL_*_INTR_SOURCE sources as defined in this header."]
    #[doc = " @param flags An ORred mask of the ESP_INTR_FLAG_* defines. These restrict the"]
    #[doc = "               choice of interrupts that this routine can choose from. If this value"]
    #[doc = "               is 0, it will default to allocating a non-shared interrupt of level"]
    #[doc = "               1, 2 or 3. If this is ESP_INTR_FLAG_SHARED, it will allocate a shared"]
    #[doc = "               interrupt of level 1. Setting ESP_INTR_FLAG_INTRDISABLED will return"]
    #[doc = "               from this function with the interrupt disabled."]
    #[doc = " @param handler The interrupt handler. Must be NULL when an interrupt of level >3"]
    #[doc = "               is requested, because these types of interrupts aren't C-callable."]
    #[doc = " @param arg    Optional argument for passed to the interrupt handler"]
    #[doc = " @param ret_handle Pointer to an intr_handle_t to store a handle that can later be"]
    #[doc = "               used to request details or free the interrupt. Can be NULL if no handle"]
    #[doc = "               is required."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_alloc(
        source: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        handler: intr_handler_t,
        arg: *mut ::core::ffi::c_void,
        ret_handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Allocate an interrupt with the given parameters."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " This essentially does the same as esp_intr_alloc, but allows specifying a register and mask"]
    #[doc = " combo. For shared interrupts, the handler is only called if a read from the specified"]
    #[doc = " register, ANDed with the mask, returns non-zero. By passing an interrupt status register"]
    #[doc = " address and a fitting mask, this can be used to accelerate interrupt handling in the case"]
    #[doc = " a shared interrupt is triggered; by checking the interrupt statuses first, the code can"]
    #[doc = " decide which ISRs can be skipped"]
    #[doc = ""]
    #[doc = " @param source The interrupt source. One of the ETS_*_INTR_SOURCE interrupt mux"]
    #[doc = "               sources, as defined in soc/soc.h, or one of the internal"]
    #[doc = "               ETS_INTERNAL_*_INTR_SOURCE sources as defined in this header."]
    #[doc = " @param flags An ORred mask of the ESP_INTR_FLAG_* defines. These restrict the"]
    #[doc = "               choice of interrupts that this routine can choose from. If this value"]
    #[doc = "               is 0, it will default to allocating a non-shared interrupt of level"]
    #[doc = "               1, 2 or 3. If this is ESP_INTR_FLAG_SHARED, it will allocate a shared"]
    #[doc = "               interrupt of level 1. Setting ESP_INTR_FLAG_INTRDISABLED will return"]
    #[doc = "               from this function with the interrupt disabled."]
    #[doc = " @param intrstatusreg The address of an interrupt status register"]
    #[doc = " @param intrstatusmask A mask. If a read of address intrstatusreg has any of the bits"]
    #[doc = "               that are 1 in the mask set, the ISR will be called. If not, it will be"]
    #[doc = "               skipped."]
    #[doc = " @param handler The interrupt handler. Must be NULL when an interrupt of level >3"]
    #[doc = "               is requested, because these types of interrupts aren't C-callable."]
    #[doc = " @param arg    Optional argument for passed to the interrupt handler"]
    #[doc = " @param ret_handle Pointer to an intr_handle_t to store a handle that can later be"]
    #[doc = "               used to request details or free the interrupt. Can be NULL if no handle"]
    #[doc = "               is required."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_alloc_intrstatus(
        source: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        intrstatusreg: u32,
        intrstatusmask: u32,
        handler: intr_handler_t,
        arg: *mut ::core::ffi::c_void,
        ret_handle: *mut intr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable and free an interrupt."]
    #[doc = ""]
    #[doc = " Use an interrupt handle to disable the interrupt and release the resources associated with it."]
    #[doc = " If the current core is not the core that registered this interrupt, this routine will be assigned to"]
    #[doc = " the core that allocated this interrupt, blocking and waiting until the resource is successfully released."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " When the handler shares its source with other handlers, the interrupt status"]
    #[doc = " bits it's responsible for should be managed properly before freeing it. see"]
    #[doc = " ``esp_intr_disable`` for more details. Please do not call this function in ``esp_ipc_call_blocking``."]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG the handle is NULL"]
    #[doc = "         ESP_FAIL failed to release this handle"]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_free(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get CPU number an interrupt is tied to"]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return The core number where the interrupt is allocated"]
    pub fn esp_intr_get_cpu(handle: intr_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the allocated interrupt for a certain handle"]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return The interrupt number"]
    pub fn esp_intr_get_intno(handle: intr_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Disable the interrupt associated with the handle"]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = " 1. For local interrupts (ESP_INTERNAL_* sources), this function has to be called on the"]
    #[doc = " CPU the interrupt is allocated on. Other interrupts have no such restriction."]
    #[doc = " 2. When several handlers sharing a same interrupt source, interrupt status bits, which are"]
    #[doc = " handled in the handler to be disabled, should be masked before the disabling, or handled"]
    #[doc = " in other enabled interrupts properly. Miss of interrupt status handling will cause infinite"]
    #[doc = " interrupt calls and finally system crash."]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_disable(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable the interrupt associated with the handle"]
    #[doc = ""]
    #[doc = " @note For local interrupts (ESP_INTERNAL_* sources), this function has to be called on the"]
    #[doc = "       CPU the interrupt is allocated on. Other interrupts have no such restriction."]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_enable(handle: intr_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the \"in IRAM\" status of the handler."]
    #[doc = ""]
    #[doc = " @note Does not work on shared interrupts."]
    #[doc = ""]
    #[doc = " @param handle The handle, as obtained by esp_intr_alloc or esp_intr_alloc_intrstatus"]
    #[doc = " @param is_in_iram Whether the handler associated with this handle resides in IRAM."]
    #[doc = "                   Handlers residing in IRAM can be called when cache is disabled."]
    #[doc = ""]
    #[doc = " @return ESP_ERR_INVALID_ARG if the combination of arguments is invalid."]
    #[doc = "         ESP_OK otherwise"]
    pub fn esp_intr_set_in_iram(handle: intr_handle_t, is_in_iram: bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable interrupts that aren't specifically marked as running from IRAM"]
    pub fn esp_intr_noniram_disable();
}
extern "C" {
    #[doc = " @brief Re-enable interrupts disabled by esp_intr_noniram_disable"]
    pub fn esp_intr_noniram_enable();
}
pub const periph_module_t_PERIPH_LEDC_MODULE: periph_module_t = 0;
pub const periph_module_t_PERIPH_UART0_MODULE: periph_module_t = 1;
pub const periph_module_t_PERIPH_UART1_MODULE: periph_module_t = 2;
pub const periph_module_t_PERIPH_UART2_MODULE: periph_module_t = 3;
pub const periph_module_t_PERIPH_I2C0_MODULE: periph_module_t = 4;
pub const periph_module_t_PERIPH_I2C1_MODULE: periph_module_t = 5;
pub const periph_module_t_PERIPH_I2S0_MODULE: periph_module_t = 6;
pub const periph_module_t_PERIPH_I2S1_MODULE: periph_module_t = 7;
pub const periph_module_t_PERIPH_TIMG0_MODULE: periph_module_t = 8;
pub const periph_module_t_PERIPH_TIMG1_MODULE: periph_module_t = 9;
pub const periph_module_t_PERIPH_PWM0_MODULE: periph_module_t = 10;
pub const periph_module_t_PERIPH_PWM1_MODULE: periph_module_t = 11;
pub const periph_module_t_PERIPH_PWM2_MODULE: periph_module_t = 12;
pub const periph_module_t_PERIPH_PWM3_MODULE: periph_module_t = 13;
pub const periph_module_t_PERIPH_UHCI0_MODULE: periph_module_t = 14;
pub const periph_module_t_PERIPH_UHCI1_MODULE: periph_module_t = 15;
pub const periph_module_t_PERIPH_RMT_MODULE: periph_module_t = 16;
pub const periph_module_t_PERIPH_PCNT_MODULE: periph_module_t = 17;
pub const periph_module_t_PERIPH_SPI_MODULE: periph_module_t = 18;
pub const periph_module_t_PERIPH_HSPI_MODULE: periph_module_t = 19;
pub const periph_module_t_PERIPH_VSPI_MODULE: periph_module_t = 20;
pub const periph_module_t_PERIPH_SPI_DMA_MODULE: periph_module_t = 21;
pub const periph_module_t_PERIPH_SDMMC_MODULE: periph_module_t = 22;
pub const periph_module_t_PERIPH_SDIO_SLAVE_MODULE: periph_module_t = 23;
pub const periph_module_t_PERIPH_CAN_MODULE: periph_module_t = 24;
pub const periph_module_t_PERIPH_EMAC_MODULE: periph_module_t = 25;
pub const periph_module_t_PERIPH_RNG_MODULE: periph_module_t = 26;
pub const periph_module_t_PERIPH_WIFI_MODULE: periph_module_t = 27;
pub const periph_module_t_PERIPH_BT_MODULE: periph_module_t = 28;
pub const periph_module_t_PERIPH_WIFI_BT_COMMON_MODULE: periph_module_t = 29;
pub const periph_module_t_PERIPH_BT_BASEBAND_MODULE: periph_module_t = 30;
pub const periph_module_t_PERIPH_BT_LC_MODULE: periph_module_t = 31;
pub const periph_module_t_PERIPH_AES_MODULE: periph_module_t = 32;
pub const periph_module_t_PERIPH_SHA_MODULE: periph_module_t = 33;
pub const periph_module_t_PERIPH_RSA_MODULE: periph_module_t = 34;
pub type periph_module_t = u32;
extern "C" {
    #[doc = " @brief      enable peripheral module"]
    #[doc = ""]
    #[doc = " @param[in]  periph    :  Peripheral module name"]
    #[doc = ""]
    #[doc = " Clock for the module will be ungated, and reset de-asserted."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn periph_module_enable(periph: periph_module_t);
}
extern "C" {
    #[doc = " @brief      disable peripheral module"]
    #[doc = ""]
    #[doc = " @param[in]  periph    :  Peripheral module name"]
    #[doc = ""]
    #[doc = " Clock for the module will be gated, reset asserted."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn periph_module_disable(periph: periph_module_t);
}
extern "C" {
    #[doc = " @brief      reset peripheral module"]
    #[doc = ""]
    #[doc = " @param[in]  periph    :  Peripheral module name"]
    #[doc = ""]
    #[doc = " Reset will asserted then de-assrted for the peripheral."]
    #[doc = ""]
    #[doc = " Calling this function does not enable or disable the clock for the module."]
    #[doc = ""]
    #[doc = " @return     NULL"]
    #[doc = ""]
    pub fn periph_module_reset(periph: periph_module_t);
}
extern "C" {
    #[doc = " This function is defined to provide a deprecation warning whenever"]
    #[doc = " XT_CLOCK_FREQ macro is used."]
    #[doc = " Update the code to use esp_clk_cpu_freq function instead."]
    #[doc = " @return current CPU clock frequency, in Hz"]
    pub fn xt_clock_freq() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoi_r(
        arg1: *mut _reent,
        __nptr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atol_r(
        arg1: *mut _reent,
        __nptr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::core::ffi::c_void,
        __base: *const ::core::ffi::c_void,
        __nmemb: size_t,
        __size: size_t,
        _compar: __compar_fn_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_uint,
        __size: ::std::os::raw::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn free(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn getenv(__string: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_uint) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const ::std::os::raw::c_char, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: *mut _mbstate_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const wchar_t,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: *const wchar_t,
        arg4: size_t,
        arg5: *mut _mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkostemp(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mkstemp_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mktemp_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::core::ffi::c_void,
        __nmemb: size_t,
        __size: size_t,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realloc(
        __r: *mut ::core::ffi::c_void,
        __size: ::std::os::raw::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn reallocf(__r: *mut ::core::ffi::c_void, __size: size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const ::std::os::raw::c_char,
        resolved_path: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn system(__string: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn a64l(__input: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(__input: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _l64a_r(
        arg1: *mut _reent,
        __input: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *mut ::core::ffi::c_void),
        >,
        __arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_r(
        arg1: *mut _reent,
        __string: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvtf(
        arg1: f32,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvtf(
        arg1: f32,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvtbuf(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvtbuf(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvtf(
        arg1: f32,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dtoa(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __itoa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _jrand48_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _nrand48_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut ::std::os::raw::c_ushort,
    ) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const ::std::os::raw::c_char,
        __end_PTR: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: *mut ::std::os::raw::c_int,
        arg6: *mut ::std::os::raw::c_int,
        arg7: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: size_t, arg3: size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _system_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
        arg4: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
#[doc = "< return successful in ets"]
pub const ETS_STATUS_ETS_OK: ETS_STATUS = 0;
#[doc = "< return failed in ets"]
pub const ETS_STATUS_ETS_FAILED: ETS_STATUS = 1;
#[doc = " @addtogroup ets_apis"]
#[doc = " @{"]
pub type ETS_STATUS = u32;
pub type ETSSignal = u32;
pub type ETSParam = u32;
pub type ETSEvent = ETSEventTag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ETSEventTag {
    #[doc = "< Event signal, in same task, different Event with different signal"]
    pub sig: ETSSignal,
    #[doc = "< Event parameter, sometimes without usage, then will be set as 0"]
    pub par: ETSParam,
}
pub type ETSTask = ::core::option::Option<unsafe extern "C" fn(e: *mut ETSEvent)>;
pub type ets_idle_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
extern "C" {
    #[doc = " @brief  Start the Espressif Task Scheduler, which is an infinit loop. Please do not add code after it."]
    #[doc = ""]
    #[doc = " @param  none"]
    #[doc = ""]
    #[doc = " @return none"]
    pub fn ets_run();
}
extern "C" {
    #[doc = " @brief  Set the Idle callback, when Tasks are processed, will call the callback before CPU goto sleep."]
    #[doc = ""]
    #[doc = " @param  ets_idle_cb_t func : The callback function."]
    #[doc = ""]
    #[doc = " @param  void *arg : Argument of the callback."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_set_idle_cb(func: ets_idle_cb_t, arg: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief  Init a task with processer, priority, queue to receive Event, queue length."]
    #[doc = ""]
    #[doc = " @param  ETSTask task : The task processer."]
    #[doc = ""]
    #[doc = " @param  uint8_t prio : Task priority, 0-31, bigger num with high priority, one priority with one task."]
    #[doc = ""]
    #[doc = " @param  ETSEvent *queue : Queue belongs to the task, task always receives Events, Queue is circular used."]
    #[doc = ""]
    #[doc = " @param  uint8_t qlen : Queue length."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_task(task: ETSTask, prio: u8, queue: *mut ETSEvent, qlen: u8);
}
extern "C" {
    #[doc = " @brief  Post an event to an Task."]
    #[doc = ""]
    #[doc = " @param  uint8_t prio : Priority of the Task."]
    #[doc = ""]
    #[doc = " @param  ETSSignal sig : Event signal."]
    #[doc = ""]
    #[doc = " @param  ETSParam  par : Event parameter"]
    #[doc = ""]
    #[doc = " @return ETS_OK     : post successful"]
    #[doc = " @return ETS_FAILED : post failed"]
    pub fn ets_post(prio: u8, sig: ETSSignal, par: ETSParam) -> ETS_STATUS;
}
extern "C" {
    pub static exc_cause_table: [*const ::std::os::raw::c_char; 40usize];
}
extern "C" {
    #[doc = " @brief  Set Pro cpu Entry code, code can be called in PRO CPU when booting is not completed."]
    #[doc = "         When Pro CPU booting is completed, Pro CPU will call the Entry code if not NULL."]
    #[doc = ""]
    #[doc = " @param  uint32_t start : the PRO Entry code address value in uint32_t"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_set_user_start(start: u32);
}
extern "C" {
    #[doc = " @brief  Set Pro cpu Startup code, code can be called when booting is not completed, or in Entry code."]
    #[doc = "         When Entry code completed, CPU will call the Startup code if not NULL, else call ets_run."]
    #[doc = ""]
    #[doc = " @param  uint32_t callback : the Startup code address value in uint32_t"]
    #[doc = ""]
    #[doc = " @return None     : post successful"]
    pub fn ets_set_startup_callback(callback: u32);
}
extern "C" {
    #[doc = " @brief  Set App cpu Entry code, code can be called in PRO CPU."]
    #[doc = "         When APP booting is completed, APP CPU will call the Entry code if not NULL."]
    #[doc = ""]
    #[doc = " @param  uint32_t start : the APP Entry code address value in uint32_t, stored in register APPCPU_CTRL_REG_D."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_set_appcpu_boot_addr(start: u32);
}
extern "C" {
    #[doc = " @brief  unpack the image in flash to iram and dram, no using cache."]
    #[doc = ""]
    #[doc = " @param  uint32_t pos : Flash physical address."]
    #[doc = ""]
    #[doc = " @param  uint32_t *entry_addr: the pointer of an variable that can store Entry code address."]
    #[doc = ""]
    #[doc = " @param  bool jump : Jump into the code in the function or not."]
    #[doc = ""]
    #[doc = " @param  bool config : Config the flash when unpacking the image, config should be done only once."]
    #[doc = ""]
    #[doc = " @return ETS_OK     : unpack successful"]
    #[doc = " @return ETS_FAILED : unpack failed"]
    pub fn ets_unpack_flash_code_legacy(
        pos: u32,
        entry_addr: *mut u32,
        jump: bool,
        config: bool,
    ) -> ETS_STATUS;
}
extern "C" {
    #[doc = " @brief  unpack the image in flash to iram and dram, using cache, maybe decrypting."]
    #[doc = ""]
    #[doc = " @param  uint32_t pos : Flash physical address."]
    #[doc = ""]
    #[doc = " @param  uint32_t *entry_addr: the pointer of an variable that can store Entry code address."]
    #[doc = ""]
    #[doc = " @param  bool jump : Jump into the code in the function or not."]
    #[doc = ""]
    #[doc = " @param  bool sb_need_check : Do security boot check or not."]
    #[doc = ""]
    #[doc = " @param  bool config : Config the flash when unpacking the image, config should be done only once."]
    #[doc = ""]
    #[doc = " @return ETS_OK     : unpack successful"]
    #[doc = " @return ETS_FAILED : unpack failed"]
    pub fn ets_unpack_flash_code(
        pos: u32,
        entry_addr: *mut u32,
        jump: bool,
        sb_need_check: bool,
        config: bool,
    ) -> ETS_STATUS;
}
extern "C" {
    #[doc = " @brief  Printf the strings to uart or other devices, similar with printf, simple than printf."]
    #[doc = "         Can not print float point data format, or longlong data format."]
    #[doc = "         So we maybe only use this in ROM."]
    #[doc = ""]
    #[doc = " @param  const char *fmt : See printf."]
    #[doc = ""]
    #[doc = " @param  ... : See printf."]
    #[doc = ""]
    #[doc = " @return int : the length printed to the output device."]
    pub fn ets_printf(fmt: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief  Output a char to uart, which uart to output(which is in uart module in ROM) is not in scope of the function."]
    #[doc = "         Can not print float point data format, or longlong data format"]
    #[doc = ""]
    #[doc = " @param  char c : char to output."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_write_char_uart(c: ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @brief  Ets_printf have two output functions\u{ff1a} putc1 and putc2, both of which will be called if need ouput."]
    #[doc = "         To install putc1, which is defaulted installed as ets_write_char_uart in none silent boot mode, as NULL in silent mode."]
    #[doc = ""]
    #[doc = " @param  void (*)(char) p: Output function to install."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_install_putc1(
        p: ::core::option::Option<unsafe extern "C" fn(c: ::std::os::raw::c_char)>,
    );
}
extern "C" {
    #[doc = " @brief  Ets_printf have two output functions\u{ff1a} putc1 and putc2, both of which will be called if need ouput."]
    #[doc = "         To install putc2, which is defaulted installed as NULL."]
    #[doc = ""]
    #[doc = " @param  void (*)(char) p: Output function to install."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_install_putc2(
        p: ::core::option::Option<unsafe extern "C" fn(c: ::std::os::raw::c_char)>,
    );
}
extern "C" {
    #[doc = " @brief  Install putc1 as ets_write_char_uart."]
    #[doc = "         In silent boot mode(to void interfere the UART attached MCU), we can call this function, after booting ok."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_install_uart_printf();
}
#[doc = " @addtogroup ets_timer_apis"]
#[doc = " @{"]
pub type ETSTimerFunc =
    ::core::option::Option<unsafe extern "C" fn(timer_arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ETSTIMER_ {
    #[doc = "< timer linker"]
    pub timer_next: *mut _ETSTIMER_,
    #[doc = "< abstruct time when timer expire"]
    pub timer_expire: u32,
    #[doc = "< timer period, 0 means timer is not periodic repeated"]
    pub timer_period: u32,
    #[doc = "< timer handler"]
    pub timer_func: ETSTimerFunc,
    #[doc = "< timer handler argument"]
    pub timer_arg: *mut ::core::ffi::c_void,
}
pub type ETSTimer = _ETSTIMER_;
extern "C" {
    #[doc = " @brief  Init ets timer, this timer range is 640 us to 429496 ms"]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_timer_init();
}
extern "C" {
    #[doc = " @brief  In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_timer_deinit();
}
extern "C" {
    #[doc = " @brief  Arm an ets timer, this timer range is 640 us to 429496 ms."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  ETSTimer *timer : Timer struct pointer."]
    #[doc = ""]
    #[doc = " @param  uint32_t tmout : Timer value in ms, range is 1 to 429496."]
    #[doc = ""]
    #[doc = " @param  bool repeat : Timer is periodic repeated."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_timer_arm(timer: *mut ETSTimer, tmout: u32, repeat: bool);
}
extern "C" {
    #[doc = " @brief  Arm an ets timer, this timer range is 640 us to 429496 ms."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  ETSTimer *timer : Timer struct pointer."]
    #[doc = ""]
    #[doc = " @param  uint32_t tmout : Timer value in us, range is 1 to 429496729."]
    #[doc = ""]
    #[doc = " @param  bool repeat : Timer is periodic repeated."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_timer_arm_us(ptimer: *mut ETSTimer, us: u32, repeat: bool);
}
extern "C" {
    #[doc = " @brief  Disarm an ets timer."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  ETSTimer *timer : Timer struct pointer."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_timer_disarm(timer: *mut ETSTimer);
}
extern "C" {
    #[doc = " @brief  Set timer callback and argument."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  ETSTimer *timer : Timer struct pointer."]
    #[doc = ""]
    #[doc = " @param  ETSTimerFunc *pfunction : Timer callback."]
    #[doc = ""]
    #[doc = " @param  void *parg : Timer callback argument."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_timer_setfn(
        ptimer: *mut ETSTimer,
        pfunction: ETSTimerFunc,
        parg: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief  Unset timer callback and argument to NULL."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  ETSTimer *timer : Timer struct pointer."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_timer_done(ptimer: *mut ETSTimer);
}
extern "C" {
    #[doc = " @brief  CPU do while loop for some time."]
    #[doc = "         In FreeRTOS task, please call FreeRTOS apis."]
    #[doc = ""]
    #[doc = " @param  uint32_t us : Delay time in us."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_delay_us(us: u32);
}
extern "C" {
    #[doc = " @brief  Set the real CPU ticks per us to the ets, so that ets_delay_us will be accurate."]
    #[doc = "         Call this function when CPU frequency is changed."]
    #[doc = ""]
    #[doc = " @param  uint32_t ticks_per_us : CPU ticks per us."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_update_cpu_frequency(ticks_per_us: u32);
}
extern "C" {
    #[doc = " @brief  Set the real CPU ticks per us to the ets, so that ets_delay_us will be accurate."]
    #[doc = ""]
    #[doc = " @note This function only sets the tick rate for the current CPU. It is located in ROM,"]
    #[doc = "       so the deep sleep stub can use it even if IRAM is not initialized yet."]
    #[doc = ""]
    #[doc = " @param  uint32_t ticks_per_us : CPU ticks per us."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_update_cpu_frequency_rom(ticks_per_us: u32);
}
extern "C" {
    #[doc = " @brief  Get the real CPU ticks per us to the ets."]
    #[doc = "         This function do not return real CPU ticks per us, just the record in ets. It can be used to check with the real CPU frequency."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return uint32_t : CPU ticks per us record in ets."]
    pub fn ets_get_cpu_frequency() -> u32;
}
extern "C" {
    #[doc = " @brief  Get xtal_freq/analog_8M*256 value calibrated in rtc module."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return uint32_t : xtal_freq/analog_8M*256."]
    pub fn ets_get_xtal_scale() -> u32;
}
extern "C" {
    #[doc = " @brief  Get xtal_freq value, If value not stored in RTC_STORE5, than store."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return uint32_t : if rtc store the value (RTC_STORE5 high 16 bits and low 16 bits with same value), read from rtc register."]
    #[doc = "                         clock = (REG_READ(RTC_STORE5) & 0xffff) << 12;"]
    #[doc = "            else if analog_8M in efuse"]
    #[doc = "                         clock = ets_get_xtal_scale() * 15625 * ets_efuse_get_8M_clock() / 40;"]
    #[doc = "                    else clock = 26M."]
    pub fn ets_get_detected_xtal_freq() -> u32;
}
#[doc = " @addtogroup ets_intr_apis"]
#[doc = " @{"]
pub type ets_isr_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
extern "C" {
    #[doc = " @brief  Attach a interrupt handler to a CPU interrupt number."]
    #[doc = "         This function equals to _xtos_set_interrupt_handler_arg(i, func, arg)."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  int i : CPU interrupt number."]
    #[doc = ""]
    #[doc = " @param  ets_isr_t func : Interrupt handler."]
    #[doc = ""]
    #[doc = " @param  void *arg : argument of the handler."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_isr_attach(i: ::std::os::raw::c_int, func: ets_isr_t, arg: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief  Mask the interrupts which show in mask bits."]
    #[doc = "         This function equals to _xtos_ints_off(mask)."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  uint32_t mask : BIT(i) means mask CPU interrupt number i."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_isr_mask(mask: u32);
}
extern "C" {
    #[doc = " @brief  Unmask the interrupts which show in mask bits."]
    #[doc = "         This function equals to _xtos_ints_on(mask)."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  uint32_t mask : BIT(i) means mask CPU interrupt number i."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_isr_unmask(unmask: u32);
}
extern "C" {
    #[doc = " @brief  Lock the interrupt to level 2."]
    #[doc = "         This function direct set the CPU registers."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_intr_lock();
}
extern "C" {
    #[doc = " @brief  Unlock the interrupt to level 0."]
    #[doc = "         This function direct set the CPU registers."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_intr_unlock();
}
extern "C" {
    #[doc = " @brief  Unlock the interrupt to level 0, and CPU will go into power save mode(wait interrupt)."]
    #[doc = "         This function direct set the CPU registers."]
    #[doc = "         In FreeRTOS, please call FreeRTOS apis, never call this api."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn ets_waiti0();
}
extern "C" {
    #[doc = " @brief  Attach an CPU interrupt to a hardware source."]
    #[doc = "         We have 4 steps to use an interrupt:"]
    #[doc = "         1.Attach hardware interrupt source to CPU.  intr_matrix_set(0, ETS_WIFI_MAC_INTR_SOURCE, ETS_WMAC_INUM);"]
    #[doc = "         2.Set interrupt handler.                    xt_set_interrupt_handler(ETS_WMAC_INUM, func, NULL);"]
    #[doc = "         3.Enable interrupt for CPU.                 xt_ints_on(1 << ETS_WMAC_INUM);"]
    #[doc = "         4.Enable interrupt in the module."]
    #[doc = ""]
    #[doc = " @param  int cpu_no : The CPU which the interrupt number belongs."]
    #[doc = ""]
    #[doc = " @param  uint32_t model_num : The interrupt hardware source number, please see the interrupt hardware source table."]
    #[doc = ""]
    #[doc = " @param  uint32_t intr_num : The interrupt number CPU, please see the interrupt cpu using table."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn intr_matrix_set(cpu_no: ::std::os::raw::c_int, model_num: u32, intr_num: u32);
}
pub const STATUS_OK: STATUS = 0;
pub const STATUS_FAIL: STATUS = 1;
pub const STATUS_PENDING: STATUS = 2;
pub const STATUS_BUSY: STATUS = 3;
pub const STATUS_CANCEL: STATUS = 4;
pub type STATUS = u32;
pub type TaskFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
#[repr(C)]
pub struct XtosCoreState {
    pub signature: ::std::os::raw::c_long,
    pub restore_label: ::std::os::raw::c_long,
    pub aftersave_label: ::std::os::raw::c_long,
    pub areg: [::std::os::raw::c_long; 64usize],
    pub caller_regs: [::std::os::raw::c_long; 16usize],
    pub caller_regs_saved: ::std::os::raw::c_long,
    pub windowbase: ::std::os::raw::c_long,
    pub windowstart: ::std::os::raw::c_long,
    pub sar: ::std::os::raw::c_long,
    pub epc1: ::std::os::raw::c_long,
    pub ps: ::std::os::raw::c_long,
    pub excsave1: ::std::os::raw::c_long,
    pub depc: ::std::os::raw::c_long,
    pub epc: [::std::os::raw::c_long; 6usize],
    pub eps: [::std::os::raw::c_long; 6usize],
    pub excsave: [::std::os::raw::c_long; 6usize],
    pub lcount: ::std::os::raw::c_long,
    pub lbeg: ::std::os::raw::c_long,
    pub lend: ::std::os::raw::c_long,
    pub vecbase: ::std::os::raw::c_long,
    pub atomctl: ::std::os::raw::c_long,
    pub memctl: ::std::os::raw::c_long,
    pub ccount: ::std::os::raw::c_long,
    pub ccompare: [::std::os::raw::c_long; 3usize],
    pub intenable: ::std::os::raw::c_long,
    pub interrupt: ::std::os::raw::c_long,
    pub icount: ::std::os::raw::c_long,
    pub icountlevel: ::std::os::raw::c_long,
    pub debugcause: ::std::os::raw::c_long,
    pub dbreakc: [::std::os::raw::c_long; 2usize],
    pub dbreaka: [::std::os::raw::c_long; 2usize],
    pub ibreaka: [::std::os::raw::c_long; 2usize],
    pub ibreakenable: ::std::os::raw::c_long,
    pub misc: [::std::os::raw::c_long; 4usize],
    pub cpenable: ::std::os::raw::c_long,
    pub tlbs: [::std::os::raw::c_long; 16usize],
    pub ncp: [::std::os::raw::c_char; 48usize],
    pub cp0: [::std::os::raw::c_char; 72usize],
    pub cp1: __IncompleteArrayField<::std::os::raw::c_char>,
    pub cp2: __IncompleteArrayField<::std::os::raw::c_char>,
    pub cp3: __IncompleteArrayField<::std::os::raw::c_char>,
    pub cp4: __IncompleteArrayField<::std::os::raw::c_char>,
    pub cp5: __IncompleteArrayField<::std::os::raw::c_char>,
    pub cp6: __IncompleteArrayField<::std::os::raw::c_char>,
    pub cp7: __IncompleteArrayField<::std::os::raw::c_char>,
}
pub type _xtos_handler_func = ::core::option::Option<unsafe extern "C" fn()>;
pub type _xtos_handler = _xtos_handler_func;
extern "C" {
    pub fn _xtos_ints_off(mask: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_ints_on(mask: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_set_intlevel(intlevel: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_set_min_intlevel(intlevel: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_restore_intlevel(restoreval: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_restore_just_intlevel(
        restoreval: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_set_interrupt_handler(n: ::std::os::raw::c_int, f: _xtos_handler)
        -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_set_interrupt_handler_arg(
        n: ::std::os::raw::c_int,
        f: _xtos_handler,
        arg: *mut ::core::ffi::c_void,
    ) -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_set_exception_handler(n: ::std::os::raw::c_int, f: _xtos_handler)
        -> _xtos_handler;
}
extern "C" {
    pub fn _xtos_memep_initrams();
}
extern "C" {
    pub fn _xtos_memep_enable(flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _xtos_dispatch_level1_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level2_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level3_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level4_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level5_interrupts();
}
extern "C" {
    pub fn _xtos_dispatch_level6_interrupts();
}
extern "C" {
    pub fn _xtos_read_ints() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _xtos_clear_ints(mask: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _xtos_core_shutoff(flags: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _xtos_core_save(
        flags: ::std::os::raw::c_uint,
        savearea: *mut XtosCoreState,
        code: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _xtos_core_restore(retvalue: ::std::os::raw::c_uint, savearea: *mut XtosCoreState);
}
extern "C" {
    pub fn _xtos_timer_0_delta(cycles: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _xtos_timer_1_delta(cycles: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _xtos_timer_2_delta(cycles: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Initialize the crosscore interrupt system for this CPU."]
    #[doc = " This needs to be called once on every CPU that is used"]
    #[doc = " by FreeRTOS."]
    #[doc = ""]
    #[doc = " If multicore FreeRTOS support is enabled, this will be"]
    #[doc = " called automatically by the startup code and should not"]
    #[doc = " be called manually."]
    pub fn esp_crosscore_int_init();
}
extern "C" {
    #[doc = " Send an interrupt to a CPU indicating it should yield its"]
    #[doc = " currently running task in favour of a higher-priority task"]
    #[doc = " that presumably just woke up."]
    #[doc = ""]
    #[doc = " This is used internally by FreeRTOS in multicore mode"]
    #[doc = " and should not be called by the user."]
    #[doc = ""]
    #[doc = " @param core_id Core that should do the yielding"]
    pub fn esp_crosscore_int_send_yield(core_id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Send an interrupt to a CPU indicating it should update its"]
    #[doc = " CCOMPARE1 value due to a frequency switch."]
    #[doc = ""]
    #[doc = " This is used internally when dynamic frequency switching is"]
    #[doc = " enabled, and should not be called from application code."]
    #[doc = ""]
    #[doc = " @param core_id Core that should update its CCOMPARE1 value"]
    pub fn esp_crosscore_int_send_freq_switch(core_id: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_timer {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque type representing a single esp_timer"]
pub type esp_timer_handle_t = *mut esp_timer;
#[doc = " @brief Timer callback function type"]
#[doc = " @param arg pointer to opaque user-specific data"]
pub type esp_timer_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
#[doc = "!< Callback is called from timer task"]
pub const esp_timer_dispatch_t_ESP_TIMER_TASK: esp_timer_dispatch_t = 0;
#[doc = " @brief Method for dispatching timer callback"]
pub type esp_timer_dispatch_t = u32;
#[doc = " @brief Timer configuration passed to esp_timer_create"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct esp_timer_create_args_t {
    #[doc = "!< Function to call when timer expires"]
    pub callback: esp_timer_cb_t,
    #[doc = "!< Argument to pass to the callback"]
    pub arg: *mut ::core::ffi::c_void,
    #[doc = "!< Call the callback from task or from ISR"]
    pub dispatch_method: esp_timer_dispatch_t,
    #[doc = "!< Timer name, used in esp_timer_dump function"]
    pub name: *const ::std::os::raw::c_char,
}
extern "C" {
    #[doc = " @brief Initialize esp_timer library"]
    #[doc = ""]
    #[doc = " @note This function is called from startup code. Applications do not need"]
    #[doc = " to call this function before using other esp_timer APIs."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NO_MEM if allocation has failed"]
    #[doc = "      - ESP_ERR_INVALID_STATE if already initialized"]
    #[doc = "      - other errors from interrupt allocator"]
    pub fn esp_timer_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief De-initialize esp_timer library"]
    #[doc = ""]
    #[doc = " @note Normally this function should not be called from applications"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if not yet initialized"]
    pub fn esp_timer_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Create an esp_timer instance"]
    #[doc = ""]
    #[doc = " @note When done using the timer, delete it with esp_timer_delete function."]
    #[doc = ""]
    #[doc = " @param create_args   Pointer to a structure with timer creation arguments."]
    #[doc = "                      Not saved by the library, can be allocated on the stack."]
    #[doc = " @param[out] out_handle  Output, pointer to esp_timer_handle_t variable which"]
    #[doc = "                         will hold the created timer handle."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if some of the create_args are not valid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if esp_timer library is not initialized yet"]
    #[doc = "      - ESP_ERR_NO_MEM if memory allocation fails"]
    pub fn esp_timer_create(
        create_args: *const esp_timer_create_args_t,
        out_handle: *mut esp_timer_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start one-shot timer"]
    #[doc = ""]
    #[doc = " Timer should not be running when this function is called."]
    #[doc = ""]
    #[doc = " @param timer timer handle created using esp_timer_create"]
    #[doc = " @param timeout_us timer timeout, in microseconds relative to the current moment"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the handle is invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is already running"]
    pub fn esp_timer_start_once(timer: esp_timer_handle_t, timeout_us: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Start a periodic timer"]
    #[doc = ""]
    #[doc = " Timer should not be running when this function is called. This function will"]
    #[doc = " start the timer which will trigger every 'period' microseconds."]
    #[doc = ""]
    #[doc = " @param timer timer handle created using esp_timer_create"]
    #[doc = " @param period timer period, in microseconds"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if the handle is invalid"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is already running"]
    pub fn esp_timer_start_periodic(timer: esp_timer_handle_t, period: u64) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Stop the timer"]
    #[doc = ""]
    #[doc = " This function stops the timer previously started using esp_timer_start_once"]
    #[doc = " or esp_timer_start_periodic."]
    #[doc = ""]
    #[doc = " @param timer timer handle created using esp_timer_create"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is not running"]
    pub fn esp_timer_stop(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Delete an esp_timer instance"]
    #[doc = ""]
    #[doc = " The timer must be stopped before deleting. A one-shot timer which has expired"]
    #[doc = " does not need to be stopped."]
    #[doc = ""]
    #[doc = " @param timer timer handle allocated using esp_timer_create"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_STATE if the timer is not running"]
    pub fn esp_timer_delete(timer: esp_timer_handle_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get time in microseconds since boot"]
    #[doc = " @return number of microseconds since esp_timer_init was called (this normally"]
    #[doc = "          happens early during application startup)."]
    pub fn esp_timer_get_time() -> i64;
}
extern "C" {
    #[doc = " @brief Get the timestamp when the next timeout is expected to occur"]
    #[doc = " @return Timestamp of the nearest timer event, in microseconds."]
    #[doc = "         The timebase is the same as for the values returned by esp_timer_get_time."]
    pub fn esp_timer_get_next_alarm() -> i64;
}
extern "C" {
    #[doc = " @brief Dump the list of timers to a stream"]
    #[doc = ""]
    #[doc = " If CONFIG_ESP_TIMER_PROFILING option is enabled, this prints the list of all"]
    #[doc = " the existing timers. Otherwise, only the list active timers is printed."]
    #[doc = ""]
    #[doc = " The format is:"]
    #[doc = ""]
    #[doc = "   name  period  alarm  times_armed  times_triggered  total_callback_run_time"]
    #[doc = ""]
    #[doc = " where:"]
    #[doc = ""]
    #[doc = " name \u{2014} timer name (if CONFIG_ESP_TIMER_PROFILING is defined), or timer pointer"]
    #[doc = " period \u{2014} period of timer, in microseconds, or 0 for one-shot timer"]
    #[doc = " alarm - time of the next alarm, in microseconds since boot, or 0 if the timer"]
    #[doc = "         is not started"]
    #[doc = ""]
    #[doc = " The following fields are printed if CONFIG_ESP_TIMER_PROFILING is defined:"]
    #[doc = ""]
    #[doc = " times_armed \u{2014} number of times the timer was armed via esp_timer_start_X"]
    #[doc = " times_triggered - number of times the callback was called"]
    #[doc = " total_callback_run_time - total time taken by callback to execute, across all calls"]
    #[doc = ""]
    #[doc = " @param stream stream (such as stdout) to dump the information to"]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_NO_MEM if can not allocate temporary buffer for the output"]
    pub fn esp_timer_dump(stream: *mut FILE) -> esp_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multi_heap_info {
    _unused: [u8; 0],
}
#[doc = " @brief Opaque handle to a registered heap"]
pub type multi_heap_handle_t = *mut multi_heap_info;
extern "C" {
    #[doc = " @brief malloc() a buffer in a given heap"]
    #[doc = ""]
    #[doc = " Semantics are the same as standard malloc(), only the returned buffer will be allocated in the specified heap."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param size Size of desired buffer."]
    #[doc = ""]
    #[doc = " @return Pointer to new memory, or NULL if allocation fails."]
    pub fn multi_heap_malloc(heap: multi_heap_handle_t, size: size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief free() a buffer in a given heap."]
    #[doc = ""]
    #[doc = " Semantics are the same as standard free(), only the argument 'p' must be NULL or have been allocated in the specified heap."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param p NULL, or a pointer previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap."]
    pub fn multi_heap_free(heap: multi_heap_handle_t, p: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief realloc() a buffer in a given heap."]
    #[doc = ""]
    #[doc = " Semantics are the same as standard realloc(), only the argument 'p' must be NULL or have been allocated in the specified heap."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param p NULL, or a pointer previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap."]
    #[doc = " @param size Desired new size for buffer."]
    #[doc = ""]
    #[doc = " @return New buffer of 'size' containing contents of 'p', or NULL if reallocation failed."]
    pub fn multi_heap_realloc(
        heap: multi_heap_handle_t,
        p: *mut ::core::ffi::c_void,
        size: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Return the size that a particular pointer was allocated with."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param p Pointer, must have been previously returned from multi_heap_malloc() or multi_heap_realloc() for the same heap."]
    #[doc = ""]
    #[doc = " @return Size of the memory allocated at this block. May be more than the original size argument, due"]
    #[doc = " to padding and minimum block sizes."]
    pub fn multi_heap_get_allocated_size(
        heap: multi_heap_handle_t,
        p: *mut ::core::ffi::c_void,
    ) -> size_t;
}
extern "C" {
    #[doc = " @brief Register a new heap for use"]
    #[doc = ""]
    #[doc = " This function initialises a heap at the specified address, and returns a handle for future heap operations."]
    #[doc = ""]
    #[doc = " There is no equivalent function for deregistering a heap - if all blocks in the heap are free, you can immediately start using the memory for other purposes."]
    #[doc = ""]
    #[doc = " @param start Start address of the memory to use for a new heap."]
    #[doc = " @param size Size (in bytes) of the new heap."]
    #[doc = ""]
    #[doc = " @return Handle of a new heap ready for use, or NULL if the heap region was too small to be initialised."]
    pub fn multi_heap_register(
        start: *mut ::core::ffi::c_void,
        size: size_t,
    ) -> multi_heap_handle_t;
}
extern "C" {
    #[doc = " @brief Associate a private lock pointer with a heap"]
    #[doc = ""]
    #[doc = " The lock argument is supplied to the MULTI_HEAP_LOCK() and MULTI_HEAP_UNLOCK() macros, defined in multi_heap_platform.h."]
    #[doc = ""]
    #[doc = " The lock in question must be recursive."]
    #[doc = ""]
    #[doc = " When the heap is first registered, the associated lock is NULL."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param lock Optional pointer to a locking structure to associate with this heap."]
    pub fn multi_heap_set_lock(heap: multi_heap_handle_t, lock: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief Dump heap information to stdout"]
    #[doc = ""]
    #[doc = " For debugging purposes, this function dumps information about every block in the heap to stdout."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    pub fn multi_heap_dump(heap: multi_heap_handle_t);
}
extern "C" {
    #[doc = " @brief Check heap integrity"]
    #[doc = ""]
    #[doc = " Walks the heap and checks all heap data structures are valid. If any errors are detected, an error-specific message"]
    #[doc = " can be optionally printed to stderr. Print behaviour can be overriden at compile time by defining"]
    #[doc = " MULTI_CHECK_FAIL_PRINTF in multi_heap_platform.h."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param print_errors If true, errors will be printed to stderr."]
    #[doc = " @return true if heap is valid, false otherwise."]
    pub fn multi_heap_check(heap: multi_heap_handle_t, print_errors: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Return free heap size"]
    #[doc = ""]
    #[doc = " Returns the number of bytes available in the heap."]
    #[doc = ""]
    #[doc = " Equivalent to the total_free_bytes member returned by multi_heap_get_heap_info()."]
    #[doc = ""]
    #[doc = " Note that the heap may be fragmented, so the actual maximum size for a single malloc() may be lower. To know this"]
    #[doc = " size, see the largest_free_block member returned by multi_heap_get_heap_info()."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @return Number of free bytes."]
    pub fn multi_heap_free_size(heap: multi_heap_handle_t) -> size_t;
}
extern "C" {
    #[doc = " @brief Return the lifetime minimum free heap size"]
    #[doc = ""]
    #[doc = " Equivalent to the minimum_free_bytes member returned by multi_heap_get_info()."]
    #[doc = ""]
    #[doc = " Returns the lifetime \"low water mark\" of possible values returned from multi_free_heap_size(), for the specified"]
    #[doc = " heap."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @return Number of free bytes."]
    pub fn multi_heap_minimum_free_size(heap: multi_heap_handle_t) -> size_t;
}
#[doc = " @brief Structure to access heap metadata via multi_heap_get_info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multi_heap_info_t {
    #[doc = "<  Total free bytes in the heap. Equivalent to multi_free_heap_size()."]
    pub total_free_bytes: size_t,
    #[doc = "<  Total bytes allocated to data in the heap."]
    pub total_allocated_bytes: size_t,
    #[doc = "<  Size of largest free block in the heap. This is the largest malloc-able size."]
    pub largest_free_block: size_t,
    #[doc = "<  Lifetime minimum free heap size. Equivalent to multi_minimum_free_heap_size()."]
    pub minimum_free_bytes: size_t,
    #[doc = "<  Number of (variable size) blocks allocated in the heap."]
    pub allocated_blocks: size_t,
    #[doc = "<  Number of (variable size) free blocks in the heap."]
    pub free_blocks: size_t,
    #[doc = "<  Total number of (variable size) blocks in the heap."]
    pub total_blocks: size_t,
}
extern "C" {
    #[doc = " @brief Return metadata about a given heap"]
    #[doc = ""]
    #[doc = " Fills a multi_heap_info_t structure with information about the specified heap."]
    #[doc = ""]
    #[doc = " @param heap Handle to a registered heap."]
    #[doc = " @param info Pointer to a structure to fill with heap metadata."]
    pub fn multi_heap_get_info(heap: multi_heap_handle_t, info: *mut multi_heap_info_t);
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory which has the given capabilities"]
    #[doc = ""]
    #[doc = " Equivalent semantics to libc malloc(), for capability-aware memory."]
    #[doc = ""]
    #[doc = " In IDF, ``malloc(p)`` is equivalent to ``heap_caps_malloc(p, MALLOC_CAP_8BIT)``."]
    #[doc = ""]
    #[doc = " @param size Size, in bytes, of the amount of memory to allocate"]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory to be returned"]
    #[doc = ""]
    #[doc = " @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_malloc(size: size_t, caps: u32) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Free memory previously allocated via heap_caps_malloc() or heap_caps_realloc()."]
    #[doc = ""]
    #[doc = " Equivalent semantics to libc free(), for capability-aware memory."]
    #[doc = ""]
    #[doc = "  In IDF, ``free(p)`` is equivalent to ``heap_caps_free(p)``."]
    #[doc = ""]
    #[doc = " @param ptr Pointer to memory previously returned from heap_caps_malloc() or heap_caps_realloc(). Can be NULL."]
    pub fn heap_caps_free(ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief Reallocate memory previously allocated via heap_caps_malloc() or heap_caps_realloc()."]
    #[doc = ""]
    #[doc = " Equivalent semantics to libc realloc(), for capability-aware memory."]
    #[doc = ""]
    #[doc = " In IDF, ``realloc(p, s)`` is equivalent to ``heap_caps_realloc(p, s, MALLOC_CAP_8BIT)``."]
    #[doc = ""]
    #[doc = " 'caps' parameter can be different to the capabilities that any original 'ptr' was allocated with. In this way,"]
    #[doc = " realloc can be used to \"move\" a buffer if necessary to ensure it meets a new set of capabilities."]
    #[doc = ""]
    #[doc = " @param ptr Pointer to previously allocated memory, or NULL for a new allocation."]
    #[doc = " @param size Size of the new buffer requested, or 0 to free the buffer."]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory desired for the new allocation."]
    #[doc = ""]
    #[doc = " @return Pointer to a new buffer of size 'size' with capabilities 'caps', or NULL if allocation failed."]
    pub fn heap_caps_realloc(
        ptr: *mut ::core::ffi::c_void,
        size: size_t,
        caps: ::std::os::raw::c_int,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory which has the given capabilities. The initialized value in the memory is set to zero."]
    #[doc = ""]
    #[doc = " Equivalent semantics to libc calloc(), for capability-aware memory."]
    #[doc = ""]
    #[doc = " In IDF, ``calloc(p)`` is equivalent to ``heap_caps_calloc(p, MALLOC_CAP_8BIT)``."]
    #[doc = ""]
    #[doc = " @param n    Number of continuing chunks of memory to allocate"]
    #[doc = " @param size Size, in bytes, of a chunk of memory to allocate"]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory to be returned"]
    #[doc = ""]
    #[doc = " @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_calloc(n: size_t, size: size_t, caps: u32) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Get the total free size of all the regions that have the given capabilities"]
    #[doc = ""]
    #[doc = " This function takes all regions capable of having the given capabilities allocated in them"]
    #[doc = " and adds up the free space they have."]
    #[doc = ""]
    #[doc = " Note that because of heap fragmentation it is probably not possible to allocate a single block of memory"]
    #[doc = " of this size. Use heap_caps_get_largest_free_block() for this purpose."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = ""]
    #[doc = " @return Amount of free bytes in the regions"]
    pub fn heap_caps_get_free_size(caps: u32) -> size_t;
}
extern "C" {
    #[doc = " @brief Get the total minimum free memory of all regions with the given capabilities"]
    #[doc = ""]
    #[doc = " This adds all the low water marks of the regions capable of delivering the memory"]
    #[doc = " with the given capabilities."]
    #[doc = ""]
    #[doc = " Note the result may be less than the global all-time minimum available heap of this kind, as \"low water marks\" are"]
    #[doc = " tracked per-region. Individual regions' heaps may have reached their \"low water marks\" at different points in time. However"]
    #[doc = " this result still gives a \"worst case\" indication for all-time minimum free heap."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = ""]
    #[doc = " @return Amount of free bytes in the regions"]
    pub fn heap_caps_get_minimum_free_size(caps: u32) -> size_t;
}
extern "C" {
    #[doc = " @brief Get the largest free block of memory able to be allocated with the given capabilities."]
    #[doc = ""]
    #[doc = " Returns the largest value of ``s`` for which ``heap_caps_malloc(s, caps)`` will succeed."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = ""]
    #[doc = " @return Size of largest free block in bytes."]
    pub fn heap_caps_get_largest_free_block(caps: u32) -> size_t;
}
extern "C" {
    #[doc = " @brief Get heap info for all regions with the given capabilities."]
    #[doc = ""]
    #[doc = " Calls multi_heap_info() on all heaps which share the given capabilities.  The information returned is an aggregate"]
    #[doc = " across all matching heaps.  The meanings of fields are the same as defined for multi_heap_info_t, except that"]
    #[doc = " ``minimum_free_bytes`` has the same caveats described in heap_caps_get_minimum_free_size()."]
    #[doc = ""]
    #[doc = " @param info        Pointer to a structure which will be filled with relevant"]
    #[doc = "                    heap metadata."]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = ""]
    pub fn heap_caps_get_info(info: *mut multi_heap_info_t, caps: u32);
}
extern "C" {
    #[doc = " @brief Print a summary of all memory with the given capabilities."]
    #[doc = ""]
    #[doc = " Calls multi_heap_info on all heaps which share the given capabilities, and"]
    #[doc = " prints a two-line summary for each, then a total summary."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = ""]
    pub fn heap_caps_print_heap_info(caps: u32);
}
extern "C" {
    #[doc = " @brief Check integrity of all heap memory in the system."]
    #[doc = ""]
    #[doc = " Calls multi_heap_check on all heaps. Optionally print errors if heaps are corrupt."]
    #[doc = ""]
    #[doc = " Calling this function is equivalent to calling heap_caps_check_integrity"]
    #[doc = " with the caps argument set to MALLOC_CAP_INVALID."]
    #[doc = ""]
    #[doc = " @param print_errors Print specific errors if heap corruption is found."]
    #[doc = ""]
    #[doc = " @return True if all heaps are valid, False if at least one heap is corrupt."]
    pub fn heap_caps_check_integrity_all(print_errors: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Check integrity of all heaps with the given capabilities."]
    #[doc = ""]
    #[doc = " Calls multi_heap_check on all heaps which share the given capabilities. Optionally"]
    #[doc = " print errors if the heaps are corrupt."]
    #[doc = ""]
    #[doc = " See also heap_caps_check_integrity_all to check all heap memory"]
    #[doc = " in the system and heap_caps_check_integrity_addr to check memory"]
    #[doc = " around a single address."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    #[doc = " @param print_errors Print specific errors if heap corruption is found."]
    #[doc = ""]
    #[doc = " @return True if all heaps are valid, False if at least one heap is corrupt."]
    pub fn heap_caps_check_integrity(caps: u32, print_errors: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Check integrity of heap memory around a given address."]
    #[doc = ""]
    #[doc = " This function can be used to check the integrity of a single region of heap memory,"]
    #[doc = " which contains the given address."]
    #[doc = ""]
    #[doc = " This can be useful if debugging heap integrity for corruption at a known address,"]
    #[doc = " as it has a lower overhead than checking all heap regions. Note that if the corrupt"]
    #[doc = " address moves around between runs (due to timing or other factors) then this approach"]
    #[doc = " won't work and you should call heap_caps_check_integrity or"]
    #[doc = " heap_caps_check_integrity_all instead."]
    #[doc = ""]
    #[doc = " @note The entire heap region around the address is checked, not only the adjacent"]
    #[doc = " heap blocks."]
    #[doc = ""]
    #[doc = " @param addr Address in memory. Check for corruption in region containing this address."]
    #[doc = " @param print_errors Print specific errors if heap corruption is found."]
    #[doc = ""]
    #[doc = " @return True if the heap containing the specified address is valid,"]
    #[doc = " False if at least one heap is corrupt or the address doesn't belong to a heap region."]
    pub fn heap_caps_check_integrity_addr(addr: isize, print_errors: bool) -> bool;
}
extern "C" {
    #[doc = " @brief Enable malloc() in external memory and set limit below which"]
    #[doc = "        malloc() attempts are placed in internal memory."]
    #[doc = ""]
    #[doc = " When external memory is in use, the allocation strategy is to initially try to"]
    #[doc = " satisfy smaller allocation requests with internal memory and larger requests"]
    #[doc = " with external memory. This sets the limit between the two, as well as generally"]
    #[doc = " enabling allocation in external memory."]
    #[doc = ""]
    #[doc = " @param limit       Limit, in bytes."]
    pub fn heap_caps_malloc_extmem_enable(limit: size_t);
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory as preference in decreasing order."]
    #[doc = ""]
    #[doc = " @attention The variable parameters are bitwise OR of MALLOC_CAP_* flags indicating the type of memory."]
    #[doc = "            This API prefers to allocate memory with the first parameter. If failed, allocate memory with"]
    #[doc = "            the next parameter. It will try in this order until allocating a chunk of memory successfully"]
    #[doc = "            or fail to allocate memories with any of the parameters."]
    #[doc = ""]
    #[doc = " @param size Size, in bytes, of the amount of memory to allocate"]
    #[doc = " @param num Number of variable paramters"]
    #[doc = ""]
    #[doc = " @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_malloc_prefer(size: size_t, num: size_t, ...) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory as preference in decreasing order."]
    #[doc = ""]
    #[doc = " @param ptr Pointer to previously allocated memory, or NULL for a new allocation."]
    #[doc = " @param size Size of the new buffer requested, or 0 to free the buffer."]
    #[doc = " @param num Number of variable paramters"]
    #[doc = ""]
    #[doc = " @return Pointer to a new buffer of size 'size', or NULL if allocation failed."]
    pub fn heap_caps_realloc_prefer(
        ptr: *mut ::core::ffi::c_void,
        size: size_t,
        num: size_t,
        ...
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Allocate a chunk of memory as preference in decreasing order."]
    #[doc = ""]
    #[doc = " @param n    Number of continuing chunks of memory to allocate"]
    #[doc = " @param size Size, in bytes, of a chunk of memory to allocate"]
    #[doc = " @param num  Number of variable paramters"]
    #[doc = ""]
    #[doc = " @return A pointer to the memory allocated on success, NULL on failure"]
    pub fn heap_caps_calloc_prefer(
        n: size_t,
        size: size_t,
        num: size_t,
        ...
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief Dump the full structure of all heaps with matching capabilities."]
    #[doc = ""]
    #[doc = " Prints a large amount of output to serial (because of locking limitations,"]
    #[doc = " the output bypasses stdout/stderr). For each (variable sized) block"]
    #[doc = " in each matching heap, the following output is printed on a single line:"]
    #[doc = ""]
    #[doc = " - Block address (the data buffer returned by malloc is 4 bytes after this"]
    #[doc = "   if heap debugging is set to Basic, or 8 bytes otherwise)."]
    #[doc = " - Data size (the data size may be larger than the size requested by malloc,"]
    #[doc = "   either due to heap fragmentation or because of heap debugging level)."]
    #[doc = " - Address of next block in the heap."]
    #[doc = " - If the block is free, the address of the next free block is also printed."]
    #[doc = ""]
    #[doc = " @param caps        Bitwise OR of MALLOC_CAP_* flags indicating the type"]
    #[doc = "                    of memory"]
    pub fn heap_caps_dump(caps: u32);
}
extern "C" {
    #[doc = " @brief Dump the full structure of all heaps."]
    #[doc = ""]
    #[doc = " Covers all registered heaps. Prints a large amount of output to serial."]
    #[doc = ""]
    #[doc = " Output is the same as for heap_caps_dump."]
    #[doc = ""]
    pub fn heap_caps_dump_all();
}
pub type StackType_t = u8;
pub type BaseType_t = ::std::os::raw::c_int;
pub type UBaseType_t = ::std::os::raw::c_uint;
pub type TickType_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct portMUX_TYPE {
    pub owner: u32,
    pub count: u32,
}
extern "C" {
    pub fn vPortAssertIfInISR();
}
extern "C" {
    pub fn vPortCPUInitializeMutex(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vTaskExitCritical(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vTaskEnterCritical(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vPortCPUAcquireMutex(mux: *mut portMUX_TYPE);
}
extern "C" {
    #[doc = " @brief Acquire a portmux spinlock with a timeout"]
    #[doc = ""]
    #[doc = " @param mux Pointer to portmux to acquire."]
    #[doc = " @param timeout_cycles Timeout to spin, in CPU cycles. Pass portMUX_NO_TIMEOUT to wait forever,"]
    #[doc = " portMUX_TRY_LOCK to try a single time to acquire the lock."]
    #[doc = ""]
    #[doc = " @return true if mutex is successfully acquired, false on timeout."]
    pub fn vPortCPUAcquireMutexTimeout(
        mux: *mut portMUX_TYPE,
        timeout_cycles: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn vPortCPUReleaseMutex(mux: *mut portMUX_TYPE);
}
extern "C" {
    pub fn vPortYield();
}
extern "C" {
    pub fn _frxt_setup_switch();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMPU_SETTINGS {
    pub coproc_area: *mut StackType_t,
}
extern "C" {
    pub fn esp_vApplicationIdleHook();
}
extern "C" {
    pub fn esp_vApplicationTickHook();
}
extern "C" {
    pub fn _xt_coproc_release(coproc_sa_base: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn vApplicationSleep(xExpectedIdleTime: TickType_t);
}
extern "C" {
    pub fn esp_random() -> u32;
}
extern "C" {
    pub fn pxPortInitialiseStack(
        pxTopOfStack: *mut StackType_t,
        pxCode: TaskFunction_t,
        pvParameters: *mut ::core::ffi::c_void,
        xRunPrivileged: BaseType_t,
    ) -> *mut StackType_t;
}
extern "C" {
    pub fn xPortStartScheduler() -> BaseType_t;
}
extern "C" {
    pub fn vPortEndScheduler();
}
extern "C" {
    pub fn vPortYieldOtherCore(coreid: BaseType_t);
}
extern "C" {
    pub fn vPortSetStackWatchpoint(pxStackStart: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn xPortInIsrContext() -> BaseType_t;
}
extern "C" {
    pub fn xPortInterruptedFromISRContext() -> BaseType_t;
}
extern "C" {
    pub fn vPortStoreTaskMPUSettings(
        xMPUSettings: *mut xMPU_SETTINGS,
        xRegions: *const xMEMORY_REGION,
        pxBottomOfStack: *mut StackType_t,
        usStackDepth: u32,
    );
}
extern "C" {
    pub fn vPortReleaseTaskMPUSettings(xMPUSettings: *mut xMPU_SETTINGS);
}
extern "C" {
    pub fn xPortGetTickRateHz() -> u32;
}
extern "C" {
    pub fn uxPortCompareSetExtram(addr: *mut u32, compare: u32, set: *mut u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST_ITEM {
    pub xDummy1: TickType_t,
    pub pvDummy2: [*mut ::core::ffi::c_void; 4usize],
}
pub type StaticListItem_t = xSTATIC_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_MINI_LIST_ITEM {
    pub xDummy1: TickType_t,
    pub pvDummy2: [*mut ::core::ffi::c_void; 2usize],
}
pub type StaticMiniListItem_t = xSTATIC_MINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST {
    pub uxDummy1: UBaseType_t,
    pub pvDummy2: *mut ::core::ffi::c_void,
    pub xDummy3: StaticMiniListItem_t,
}
pub type StaticList_t = xSTATIC_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TCB {
    pub pxDummy1: *mut ::core::ffi::c_void,
    pub xDummy2: xMPU_SETTINGS,
    pub xDummy3: [StaticListItem_t; 2usize],
    pub uxDummy5: UBaseType_t,
    pub pxDummy6: *mut ::core::ffi::c_void,
    pub ucDummy7: [u8; 16usize],
    pub uxDummyCoreId: UBaseType_t,
    pub pxDummy8: *mut ::core::ffi::c_void,
    pub uxDummy9: UBaseType_t,
    pub OldInterruptState: u32,
    pub uxDummy12: [UBaseType_t; 2usize],
    pub pvDummy15: [*mut ::core::ffi::c_void; 1usize],
    pub pvDummyLocalStorageCallBack: [*mut ::core::ffi::c_void; 1usize],
    pub xDummy17: _reent,
    pub ulDummy18: u32,
    pub ucDummy19: u32,
    pub uxDummy20: u8,
}
pub type StaticTask_t = xSTATIC_TCB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xSTATIC_QUEUE {
    pub pvDummy1: [*mut ::core::ffi::c_void; 3usize],
    pub u: xSTATIC_QUEUE__bindgen_ty_1,
    pub xDummy3: [StaticList_t; 2usize],
    pub uxDummy4: [UBaseType_t; 3usize],
    pub pvDummy7: *mut ::core::ffi::c_void,
    pub muxDummy: portMUX_TYPE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xSTATIC_QUEUE__bindgen_ty_1 {
    pub pvDummy2: *mut ::core::ffi::c_void,
    pub uxDummy2: UBaseType_t,
    _bindgen_union_align: u32,
}
pub type StaticQueue_t = xSTATIC_QUEUE;
pub type StaticSemaphore_t = StaticQueue_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_EVENT_GROUP {
    pub xDummy1: TickType_t,
    pub xDummy2: StaticList_t,
    pub muxDummy: portMUX_TYPE,
}
pub type StaticEventGroup_t = xSTATIC_EVENT_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TIMER {
    pub pvDummy1: *mut ::core::ffi::c_void,
    pub xDummy2: StaticListItem_t,
    pub xDummy3: TickType_t,
    pub uxDummy4: UBaseType_t,
    pub pvDummy5: [*mut ::core::ffi::c_void; 2usize],
}
pub type StaticTimer_t = xSTATIC_TIMER;
#[doc = " Type by which queues are referenced.  For example, a call to xQueueCreate()"]
#[doc = " returns an QueueHandle_t variable that can then be used as a parameter to"]
#[doc = " xQueueSend(), xQueueReceive(), etc."]
pub type QueueHandle_t = *mut ::core::ffi::c_void;
#[doc = " Type by which queue sets are referenced.  For example, a call to"]
#[doc = " xQueueCreateSet() returns an xQueueSet variable that can then be used as a"]
#[doc = " parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc."]
pub type QueueSetHandle_t = *mut ::core::ffi::c_void;
#[doc = " Queue sets can contain both queues and semaphores, so the"]
#[doc = " QueueSetMemberHandle_t is defined as a type to be used where a parameter or"]
#[doc = " return value can be either an QueueHandle_t or an SemaphoreHandle_t."]
pub type QueueSetMemberHandle_t = *mut ::core::ffi::c_void;
extern "C" {
    #[doc = " It is preferred that the macros xQueueSend(), xQueueSendToFront() and"]
    #[doc = " xQueueSendToBack() are used in place of calling this function directly."]
    #[doc = ""]
    #[doc = " Post an item on a queue.  The item is queued by copy, not by reference."]
    #[doc = " This function must not be called from an interrupt service routine."]
    #[doc = " See xQueueSendFromISR () for an alternative which may be used in an ISR."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue on which the item is to be posted."]
    #[doc = ""]
    #[doc = " @param pvItemToQueue A pointer to the item that is to be placed on the"]
    #[doc = " queue.  The size of the items the queue will hold was defined when the"]
    #[doc = " queue was created, so this many bytes will be copied from pvItemToQueue"]
    #[doc = " into the queue storage area."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time the task should block"]
    #[doc = " waiting for space to become available on the queue, should it already"]
    #[doc = " be full.  The call will return immediately if this is set to 0 and the"]
    #[doc = " queue is full.  The time is defined in tick periods so the constant"]
    #[doc = " portTICK_PERIOD_MS should be used to convert to real time if this is required."]
    #[doc = ""]
    #[doc = " @param xCopyPosition Can take the value queueSEND_TO_BACK to place the"]
    #[doc = " item at the back of the queue, or queueSEND_TO_FRONT to place the item"]
    #[doc = " at the front of the queue (for high priority messages)."]
    #[doc = ""]
    #[doc = " @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  struct AMessage"]
    #[doc = "  {"]
    #[doc = "  char ucMessageID;"]
    #[doc = "  char ucData[ 20 ];"]
    #[doc = "  } xMessage;"]
    #[doc = ""]
    #[doc = "  uint32_t ulVar = 10UL;"]
    #[doc = ""]
    #[doc = "  void vATask( void *pvParameters )"]
    #[doc = "  {"]
    #[doc = "  QueueHandle_t xQueue1, xQueue2;"]
    #[doc = "  struct AMessage *pxMessage;"]
    #[doc = ""]
    #[doc = "  // Create a queue capable of containing 10 uint32_t values."]
    #[doc = "  xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );"]
    #[doc = ""]
    #[doc = "  // Create a queue capable of containing 10 pointers to AMessage structures."]
    #[doc = "  // These should be passed by pointer as they contain a lot of data."]
    #[doc = "  xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );"]
    #[doc = ""]
    #[doc = "  // ..."]
    #[doc = ""]
    #[doc = "  if( xQueue1 != 0 )"]
    #[doc = "  {"]
    #[doc = "      // Send an uint32_t.  Wait for 10 ticks for space to become"]
    #[doc = "      // available if necessary."]
    #[doc = "      if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )"]
    #[doc = "      {"]
    #[doc = "          // Failed to post the message, even after 10 ticks."]
    #[doc = "      }"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  if( xQueue2 != 0 )"]
    #[doc = "  {"]
    #[doc = "      // Send a pointer to a struct AMessage object.  Don't block if the"]
    #[doc = "      // queue is already full."]
    #[doc = "      pxMessage = & xMessage;"]
    #[doc = "      xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  // ... Rest of task code."]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " A version of xQueuePeek() that can be called from an interrupt service"]
    #[doc = " routine (ISR)."]
    #[doc = ""]
    #[doc = " Receive an item from a queue without removing the item from the queue."]
    #[doc = " The item is received by copy so a buffer of adequate size must be"]
    #[doc = " provided.  The number of bytes copied into the buffer was defined when"]
    #[doc = " the queue was created."]
    #[doc = ""]
    #[doc = " Successfully received items remain on the queue so will be returned again"]
    #[doc = " by the next call, or a call to xQueueReceive()."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue from which the item is to be"]
    #[doc = " received."]
    #[doc = ""]
    #[doc = " @param pvBuffer Pointer to the buffer into which the received item will"]
    #[doc = " be copied."]
    #[doc = ""]
    #[doc = " @return pdTRUE if an item was successfully received from the queue,"]
    #[doc = " otherwise pdFALSE."]
    #[doc = ""]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueuePeekFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " It is preferred that the macro xQueueReceive() be used rather than calling"]
    #[doc = " this function directly."]
    #[doc = ""]
    #[doc = " Receive an item from a queue.  The item is received by copy so a buffer of"]
    #[doc = " adequate size must be provided.  The number of bytes copied into the buffer"]
    #[doc = " was defined when the queue was created."]
    #[doc = ""]
    #[doc = " This function must not be used in an interrupt service routine.  See"]
    #[doc = " xQueueReceiveFromISR for an alternative that can."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue from which the item is to be"]
    #[doc = " received."]
    #[doc = ""]
    #[doc = " @param pvBuffer Pointer to the buffer into which the received item will"]
    #[doc = " be copied."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time the task should block"]
    #[doc = " waiting for an item to receive should the queue be empty at the time"]
    #[doc = " of the call.\t The time is defined in tick periods so the constant"]
    #[doc = " portTICK_PERIOD_MS should be used to convert to real time if this is required."]
    #[doc = " xQueueGenericReceive() will return immediately if the queue is empty and"]
    #[doc = " xTicksToWait is 0."]
    #[doc = ""]
    #[doc = " @param xJustPeek When set to true, the item received from the queue is not"]
    #[doc = " actually removed from the queue - meaning a subsequent call to"]
    #[doc = " xQueueReceive() will return the same item.  When set to false, the item"]
    #[doc = " being received from the queue is also removed from the queue."]
    #[doc = ""]
    #[doc = " @return pdTRUE if an item was successfully received from the queue,"]
    #[doc = " otherwise pdFALSE."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  struct AMessage"]
    #[doc = "  {"]
    #[doc = " \tchar ucMessageID;"]
    #[doc = " \tchar ucData[ 20 ];"]
    #[doc = "  } xMessage;"]
    #[doc = ""]
    #[doc = "  QueueHandle_t xQueue;"]
    #[doc = ""]
    #[doc = "  // Task to create a queue and post a value."]
    #[doc = "  void vATask( void *pvParameters )"]
    #[doc = "  {"]
    #[doc = "  struct AMessage *pxMessage;"]
    #[doc = ""]
    #[doc = " \t// Create a queue capable of containing 10 pointers to AMessage structures."]
    #[doc = " \t// These should be passed by pointer as they contain a lot of data."]
    #[doc = " \txQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );"]
    #[doc = " \tif( xQueue == 0 )"]
    #[doc = " \t{"]
    #[doc = " \t\t// Failed to create the queue."]
    #[doc = " \t}"]
    #[doc = ""]
    #[doc = " \t// ..."]
    #[doc = ""]
    #[doc = " \t// Send a pointer to a struct AMessage object.  Don't block if the"]
    #[doc = " \t// queue is already full."]
    #[doc = " \tpxMessage = & xMessage;"]
    #[doc = " \txQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );"]
    #[doc = ""]
    #[doc = " \t// ... Rest of task code."]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  // Task to receive from the queue."]
    #[doc = "  void vADifferentTask( void *pvParameters )"]
    #[doc = "  {"]
    #[doc = "  struct AMessage *pxRxedMessage;"]
    #[doc = ""]
    #[doc = " \tif( xQueue != 0 )"]
    #[doc = " \t{"]
    #[doc = " \t\t// Receive a message on the created queue.  Block for 10 ticks if a"]
    #[doc = " \t\t// message is not immediately available."]
    #[doc = " \t\tif( xQueueGenericReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )"]
    #[doc = " \t\t{"]
    #[doc = " \t\t\t// pcRxedMessage now points to the struct AMessage variable posted"]
    #[doc = " \t\t\t// by vATask."]
    #[doc = " \t\t}"]
    #[doc = " \t}"]
    #[doc = ""]
    #[doc = " \t// ... Rest of task code."]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueGenericReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        xTicksToWait: TickType_t,
        xJustPeek: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Return the number of messages stored in a queue."]
    #[doc = ""]
    #[doc = " @param xQueue A handle to the queue being queried."]
    #[doc = ""]
    #[doc = " @return The number of messages available in the queue."]
    #[doc = ""]
    #[doc = " \\ingroup QueueManagement"]
    pub fn uxQueueMessagesWaiting(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " Return the number of free spaces available in a queue.  This is equal to the"]
    #[doc = " number of items that can be sent to the queue before the queue becomes full"]
    #[doc = " if no items are removed."]
    #[doc = ""]
    #[doc = " @param xQueue A handle to the queue being queried."]
    #[doc = ""]
    #[doc = " @return The number of spaces available in the queue."]
    #[doc = ""]
    #[doc = " \\ingroup QueueManagement"]
    pub fn uxQueueSpacesAvailable(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " Delete a queue - freeing all the memory allocated for storing of items"]
    #[doc = " placed on the queue."]
    #[doc = ""]
    #[doc = " @param xQueue A handle to the queue to be deleted."]
    #[doc = ""]
    #[doc = " \\ingroup QueueManagement"]
    pub fn vQueueDelete(xQueue: QueueHandle_t);
}
extern "C" {
    #[doc = "@{*/"]
    #[doc = " It is preferred that the macros xQueueSendFromISR(),"]
    #[doc = " xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place"]
    #[doc = " of calling this function directly.  xQueueGiveFromISR() is an"]
    #[doc = " equivalent for use by semaphores that don't actually copy any data."]
    #[doc = ""]
    #[doc = " Post an item on a queue.  It is safe to use this function from within an"]
    #[doc = " interrupt service routine."]
    #[doc = ""]
    #[doc = " Items are queued by copy not reference so it is preferable to only"]
    #[doc = " queue small items, especially when called from an ISR.  In most cases"]
    #[doc = " it would be preferable to store a pointer to the item being queued."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue on which the item is to be posted."]
    #[doc = ""]
    #[doc = " @param pvItemToQueue A pointer to the item that is to be placed on the"]
    #[doc = " queue.  The size of the items the queue will hold was defined when the"]
    #[doc = " queue was created, so this many bytes will be copied from pvItemToQueue"]
    #[doc = " into the queue storage area."]
    #[doc = ""]
    #[doc = " @param[out] pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set"]
    #[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task"]
    #[doc = " to unblock, and the unblocked task has a priority higher than the currently"]
    #[doc = " running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then"]
    #[doc = " a context switch should be requested before the interrupt is exited."]
    #[doc = ""]
    #[doc = " @param xCopyPosition Can take the value queueSEND_TO_BACK to place the"]
    #[doc = " item at the back of the queue, or queueSEND_TO_FRONT to place the item"]
    #[doc = " at the front of the queue (for high priority messages)."]
    #[doc = ""]
    #[doc = " @return pdTRUE if the data was successfully sent to the queue, otherwise"]
    #[doc = " errQUEUE_FULL."]
    #[doc = ""]
    #[doc = " Example usage for buffered IO (where the ISR can obtain more than one value"]
    #[doc = " per call):"]
    #[doc = " @code{c}"]
    #[doc = "  void vBufferISR( void )"]
    #[doc = "  {"]
    #[doc = "  char cIn;"]
    #[doc = "  BaseType_t xHigherPriorityTaskWokenByPost;"]
    #[doc = ""]
    #[doc = " \t// We have not woken a task at the start of the ISR."]
    #[doc = " \txHigherPriorityTaskWokenByPost = pdFALSE;"]
    #[doc = ""]
    #[doc = " \t// Loop until the buffer is empty."]
    #[doc = " \tdo"]
    #[doc = " \t{"]
    #[doc = " \t\t// Obtain a byte from the buffer."]
    #[doc = " \t\tcIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );"]
    #[doc = ""]
    #[doc = " \t\t// Post each byte."]
    #[doc = " \t\txQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );"]
    #[doc = ""]
    #[doc = " \t} while( portINPUT_BYTE( BUFFER_COUNT ) );"]
    #[doc = ""]
    #[doc = " \t// Now the buffer is empty we can switch context if necessary.  Note that the"]
    #[doc = " \t// name of the yield function required is port specific."]
    #[doc = " \tif( xHigherPriorityTaskWokenByPost )"]
    #[doc = " \t{"]
    #[doc = " \t\ttaskYIELD_YIELD_FROM_ISR();"]
    #[doc = " \t}"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueGenericSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGiveFromISR(
        xQueue: QueueHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Receive an item from a queue.  It is safe to use this function from within an"]
    #[doc = " interrupt service routine."]
    #[doc = ""]
    #[doc = " @param xQueue The handle to the queue from which the item is to be"]
    #[doc = " received."]
    #[doc = ""]
    #[doc = " @param pvBuffer Pointer to the buffer into which the received item will"]
    #[doc = " be copied."]
    #[doc = ""]
    #[doc = " @param[out] pxHigherPriorityTaskWoken A task may be blocked waiting for space to become"]
    #[doc = " available on the queue.  If xQueueReceiveFromISR causes such a task to"]
    #[doc = " unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will"]
    #[doc = " remain unchanged."]
    #[doc = ""]
    #[doc = " @return pdTRUE if an item was successfully received from the queue,"]
    #[doc = " otherwise pdFALSE."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  QueueHandle_t xQueue;"]
    #[doc = ""]
    #[doc = "  // Function to create a queue and post some values."]
    #[doc = "  void vAFunction( void *pvParameters )"]
    #[doc = "  {"]
    #[doc = "  char cValueToPost;"]
    #[doc = "  const TickType_t xTicksToWait = ( TickType_t )0xff;"]
    #[doc = ""]
    #[doc = " \t// Create a queue capable of containing 10 characters."]
    #[doc = " \txQueue = xQueueCreate( 10, sizeof( char ) );"]
    #[doc = " \tif( xQueue == 0 )"]
    #[doc = " \t{"]
    #[doc = " \t\t// Failed to create the queue."]
    #[doc = " \t}"]
    #[doc = ""]
    #[doc = " \t// ..."]
    #[doc = ""]
    #[doc = " \t// Post some characters that will be used within an ISR.  If the queue"]
    #[doc = " \t// is full then this task will block for xTicksToWait ticks."]
    #[doc = " \tcValueToPost = 'a';"]
    #[doc = " \txQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );"]
    #[doc = " \tcValueToPost = 'b';"]
    #[doc = " \txQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );"]
    #[doc = ""]
    #[doc = " \t// ... keep posting characters ... this task may block when the queue"]
    #[doc = " \t// becomes full."]
    #[doc = ""]
    #[doc = " \tcValueToPost = 'c';"]
    #[doc = " \txQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  // ISR that outputs all the characters received on the queue."]
    #[doc = "  void vISR_Routine( void )"]
    #[doc = "  {"]
    #[doc = "  BaseType_t xTaskWokenByReceive = pdFALSE;"]
    #[doc = "  char cRxedChar;"]
    #[doc = ""]
    #[doc = " \twhile( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )"]
    #[doc = " \t{"]
    #[doc = " \t\t// A character was received.  Output the character now."]
    #[doc = " \t\tvOutputCharacter( cRxedChar );"]
    #[doc = ""]
    #[doc = " \t\t// If removing the character from the queue woke the task that was"]
    #[doc = " \t\t// posting onto the queue cTaskWokenByReceive will have been set to"]
    #[doc = " \t\t// pdTRUE.  No matter how many times this loop iterates only one"]
    #[doc = " \t\t// task will be woken."]
    #[doc = " \t}"]
    #[doc = ""]
    #[doc = " \tif( cTaskWokenByPost != ( char ) pdFALSE;"]
    #[doc = " \t{"]
    #[doc = " \t\ttaskYIELD ();"]
    #[doc = " \t}"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup QueueManagement"]
    pub fn xQueueReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = "@{*/"]
    #[doc = " Utilities to query queues that are safe to use from an ISR.  These utilities"]
    #[doc = " should be used only from witin an ISR, or within a critical section."]
    pub fn xQueueIsQueueEmptyFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueIsQueueFullFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn uxQueueMessagesWaitingFromISR(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " @cond */"]
    #[doc = " xQueueAltGenericSend() is an alternative version of xQueueGenericSend()."]
    #[doc = " Likewise xQueueAltGenericReceive() is an alternative version of"]
    #[doc = " xQueueGenericReceive()."]
    #[doc = ""]
    #[doc = " The source code that implements the alternative (Alt) API is much"]
    #[doc = " simpler\tbecause it executes everything from within a critical section."]
    #[doc = " This is\tthe approach taken by many other RTOSes, but FreeRTOS.org has the"]
    #[doc = " preferred fully featured API too.  The fully featured API has more"]
    #[doc = " complex\tcode that takes longer to execute, but makes much less use of"]
    #[doc = " critical sections.  Therefore the alternative API sacrifices interrupt"]
    #[doc = " responsiveness to gain execution speed, whereas the fully featured API"]
    #[doc = " sacrifices execution speed to ensure better interrupt responsiveness."]
    pub fn xQueueAltGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueAltGenericReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        xTicksToWait: TickType_t,
        xJustPeeking: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        xCoRoutinePreviouslyWoken: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        pxTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const ::core::ffi::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut ::core::ffi::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCreateMutex(ucQueueType: u8) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateMutexStatic(
        ucQueueType: u8,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphore(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphoreStatic(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueGetMutexHolder(xSemaphore: QueueHandle_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn xQueueTakeMutexRecursive(xMutex: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGiveMutexRecursive(pxMutex: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGenericCreate(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
extern "C" {
    #[doc = " Queue sets provide a mechanism to allow a task to block (pend) on a read"]
    #[doc = " operation from multiple queues or semaphores simultaneously."]
    #[doc = ""]
    #[doc = " See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " A queue set must be explicitly created using a call to xQueueCreateSet()"]
    #[doc = " before it can be used.  Once created, standard FreeRTOS queues and semaphores"]
    #[doc = " can be added to the set using calls to xQueueAddToSet()."]
    #[doc = " xQueueSelectFromSet() is then used to determine which, if any, of the queues"]
    #[doc = " or semaphores contained in the set is in a state where a queue read or"]
    #[doc = " semaphore take operation would be successful."]
    #[doc = ""]
    #[doc = " Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html"]
    #[doc = " for reasons why queue sets are very rarely needed in practice as there are"]
    #[doc = " simpler methods of blocking on multiple objects."]
    #[doc = ""]
    #[doc = " Note 2:  Blocking on a queue set that contains a mutex will not cause the"]
    #[doc = " mutex holder to inherit the priority of the blocked task."]
    #[doc = ""]
    #[doc = " Note 3:  An additional 4 bytes of RAM is required for each space in a every"]
    #[doc = " queue added to a queue set.  Therefore counting semaphores that have a high"]
    #[doc = " maximum count value should not be added to a queue set."]
    #[doc = ""]
    #[doc = " Note 4:  A receive (in the case of a queue) or take (in the case of a"]
    #[doc = " semaphore) operation must not be performed on a member of a queue set unless"]
    #[doc = " a call to xQueueSelectFromSet() has first returned a handle to that set member."]
    #[doc = ""]
    #[doc = " @param uxEventQueueLength Queue sets store events that occur on"]
    #[doc = " the queues and semaphores contained in the set.  uxEventQueueLength specifies"]
    #[doc = " the maximum number of events that can be queued at once.  To be absolutely"]
    #[doc = " certain that events are not lost uxEventQueueLength should be set to the"]
    #[doc = " total sum of the length of the queues added to the set, where binary"]
    #[doc = " semaphores and mutexes have a length of 1, and counting semaphores have a"]
    #[doc = " length set by their maximum count value.  Examples:"]
    #[doc = "  + If a queue set is to hold a queue of length 5, another queue of length 12,"]
    #[doc = "    and a binary semaphore, then uxEventQueueLength should be set to"]
    #[doc = "    (5 + 12 + 1), or 18."]
    #[doc = "  + If a queue set is to hold three binary semaphores then uxEventQueueLength"]
    #[doc = "    should be set to (1 + 1 + 1 ), or 3."]
    #[doc = "  + If a queue set is to hold a counting semaphore that has a maximum count of"]
    #[doc = "    5, and a counting semaphore that has a maximum count of 3, then"]
    #[doc = "    uxEventQueueLength should be set to (5 + 3), or 8."]
    #[doc = ""]
    #[doc = " @return If the queue set is created successfully then a handle to the created"]
    #[doc = " queue set is returned.  Otherwise NULL is returned."]
    pub fn xQueueCreateSet(uxEventQueueLength: UBaseType_t) -> QueueSetHandle_t;
}
extern "C" {
    #[doc = " Adds a queue or semaphore to a queue set that was previously created by a"]
    #[doc = " call to xQueueCreateSet()."]
    #[doc = ""]
    #[doc = " See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " Note 1:  A receive (in the case of a queue) or take (in the case of a"]
    #[doc = " semaphore) operation must not be performed on a member of a queue set unless"]
    #[doc = " a call to xQueueSelectFromSet() has first returned a handle to that set member."]
    #[doc = ""]
    #[doc = " @param xQueueOrSemaphore The handle of the queue or semaphore being added to"]
    #[doc = " the queue set (cast to an QueueSetMemberHandle_t type)."]
    #[doc = ""]
    #[doc = " @param xQueueSet The handle of the queue set to which the queue or semaphore"]
    #[doc = " is being added."]
    #[doc = ""]
    #[doc = " @return If the queue or semaphore was successfully added to the queue set"]
    #[doc = " then pdPASS is returned.  If the queue could not be successfully added to the"]
    #[doc = " queue set because it is already a member of a different queue set then pdFAIL"]
    #[doc = " is returned."]
    pub fn xQueueAddToSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Removes a queue or semaphore from a queue set.  A queue or semaphore can only"]
    #[doc = " be removed from a set if the queue or semaphore is empty."]
    #[doc = ""]
    #[doc = " See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " @param xQueueOrSemaphore The handle of the queue or semaphore being removed"]
    #[doc = " from the queue set (cast to an QueueSetMemberHandle_t type)."]
    #[doc = ""]
    #[doc = " @param xQueueSet The handle of the queue set in which the queue or semaphore"]
    #[doc = " is included."]
    #[doc = ""]
    #[doc = " @return If the queue or semaphore was successfully removed from the queue set"]
    #[doc = " then pdPASS is returned.  If the queue was not in the queue set, or the"]
    #[doc = " queue (or semaphore) was not empty, then pdFAIL is returned."]
    pub fn xQueueRemoveFromSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " xQueueSelectFromSet() selects from the members of a queue set a queue or"]
    #[doc = " semaphore that either contains data (in the case of a queue) or is available"]
    #[doc = " to take (in the case of a semaphore).  xQueueSelectFromSet() effectively"]
    #[doc = " allows a task to block (pend) on a read operation on all the queues and"]
    #[doc = " semaphores in a queue set simultaneously."]
    #[doc = ""]
    #[doc = " See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html"]
    #[doc = " for reasons why queue sets are very rarely needed in practice as there are"]
    #[doc = " simpler methods of blocking on multiple objects."]
    #[doc = ""]
    #[doc = " Note 2:  Blocking on a queue set that contains a mutex will not cause the"]
    #[doc = " mutex holder to inherit the priority of the blocked task."]
    #[doc = ""]
    #[doc = " Note 3:  A receive (in the case of a queue) or take (in the case of a"]
    #[doc = " semaphore) operation must not be performed on a member of a queue set unless"]
    #[doc = " a call to xQueueSelectFromSet() has first returned a handle to that set member."]
    #[doc = ""]
    #[doc = " @param xQueueSet The queue set on which the task will (potentially) block."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum time, in ticks, that the calling task will"]
    #[doc = " remain in the Blocked state (with other tasks executing) to wait for a member"]
    #[doc = " of the queue set to be ready for a successful queue read or semaphore take"]
    #[doc = " operation."]
    #[doc = ""]
    #[doc = " @return xQueueSelectFromSet() will return the handle of a queue (cast to"]
    #[doc = " a QueueSetMemberHandle_t type) contained in the queue set that contains data,"]
    #[doc = " or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained"]
    #[doc = " in the queue set that is available, or NULL if no such queue or semaphore"]
    #[doc = " exists before before the specified block time expires."]
    pub fn xQueueSelectFromSet(
        xQueueSet: QueueSetHandle_t,
        xTicksToWait: TickType_t,
    ) -> QueueSetMemberHandle_t;
}
extern "C" {
    #[doc = " A version of xQueueSelectFromSet() that can be used from an ISR."]
    pub fn xQueueSelectFromSetFromISR(xQueueSet: QueueSetHandle_t) -> QueueSetMemberHandle_t;
}
extern "C" {
    #[doc = " @cond"]
    pub fn vQueueWaitForMessageRestricted(xQueue: QueueHandle_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn xQueueGenericReset(xQueue: QueueHandle_t, xNewQueue: BaseType_t) -> BaseType_t;
}
extern "C" {
    pub fn vQueueSetQueueNumber(xQueue: QueueHandle_t, uxQueueNumber: UBaseType_t);
}
extern "C" {
    pub fn uxQueueGetQueueNumber(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn ucQueueGetQueueType(xQueue: QueueHandle_t) -> u8;
}
pub type SemaphoreHandle_t = QueueHandle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
    pub pvOwner: *mut ::core::ffi::c_void,
    pub pvContainer: *mut ::core::ffi::c_void,
}
pub type ListItem_t = xLIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMINI_LIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
}
pub type MiniListItem_t = xMINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST {
    pub uxNumberOfItems: UBaseType_t,
    pub pxIndex: *mut ListItem_t,
    pub xListEnd: MiniListItem_t,
}
pub type List_t = xLIST;
extern "C" {
    pub fn vListInitialise(pxList: *mut List_t);
}
extern "C" {
    pub fn vListInitialiseItem(pxItem: *mut ListItem_t);
}
extern "C" {
    pub fn vListInsert(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
    pub fn vListInsertEnd(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
    pub fn uxListRemove(pxItemToRemove: *mut ListItem_t) -> UBaseType_t;
}
#[doc = " task. h"]
#[doc = ""]
#[doc = " Type by which tasks are referenced.  For example, a call to xTaskCreate"]
#[doc = " returns (via a pointer parameter) an TaskHandle_t variable that can then"]
#[doc = " be used as a parameter to vTaskDelete to delete the task."]
#[doc = ""]
#[doc = " \\ingroup Tasks"]
pub type TaskHandle_t = *mut ::core::ffi::c_void;
#[doc = " Defines the prototype to which the application task hook function must"]
#[doc = " conform."]
pub type TaskHookFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> BaseType_t>;
#[doc = "< A task is querying the state of itself, so must be running."]
pub const eTaskState_eRunning: eTaskState = 0;
#[doc = "< The task being queried is in a read or pending ready list."]
pub const eTaskState_eReady: eTaskState = 1;
#[doc = "< The task being queried is in the Blocked state."]
pub const eTaskState_eBlocked: eTaskState = 2;
#[doc = "< The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out."]
pub const eTaskState_eSuspended: eTaskState = 3;
#[doc = "< The task being queried has been deleted, but its TCB has not yet been freed."]
pub const eTaskState_eDeleted: eTaskState = 4;
#[doc = " Task states returned by eTaskGetState."]
pub type eTaskState = u32;
#[doc = "< Notify the task without updating its notify value."]
pub const eNotifyAction_eNoAction: eNotifyAction = 0;
#[doc = "< Set bits in the task's notification value."]
pub const eNotifyAction_eSetBits: eNotifyAction = 1;
#[doc = "< Increment the task's notification value."]
pub const eNotifyAction_eIncrement: eNotifyAction = 2;
#[doc = "< Set the task's notification value to a specific value even if the previous value has not yet been read by the task."]
pub const eNotifyAction_eSetValueWithOverwrite: eNotifyAction = 3;
#[doc = "< Set the task's notification value if the previous value has been read by the task."]
pub const eNotifyAction_eSetValueWithoutOverwrite: eNotifyAction = 4;
#[doc = " Actions that can be performed when vTaskNotify() is called."]
pub type eNotifyAction = u32;
#[doc = " @cond */"]
#[doc = " Used internally only."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTIME_OUT {
    pub xOverflowCount: BaseType_t,
    pub xTimeOnEntering: TickType_t,
}
pub type TimeOut_t = xTIME_OUT;
#[doc = " Defines the memory ranges allocated to the task when an MPU is used."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMEMORY_REGION {
    pub pvBaseAddress: *mut ::core::ffi::c_void,
    pub ulLengthInBytes: u32,
    pub ulParameters: u32,
}
pub type MemoryRegion_t = xMEMORY_REGION;
#[doc = " Parameters required to create an MPU protected task."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_PARAMETERS {
    pub pvTaskCode: TaskFunction_t,
    pub pcName: *const ::std::os::raw::c_char,
    pub usStackDepth: u32,
    pub pvParameters: *mut ::core::ffi::c_void,
    pub uxPriority: UBaseType_t,
    pub puxStackBuffer: *mut StackType_t,
    pub xRegions: [MemoryRegion_t; 1usize],
}
pub type TaskParameters_t = xTASK_PARAMETERS;
#[doc = "  Used with the uxTaskGetSystemState() function to return the state of each task in the system."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_STATUS {
    #[doc = "< The handle of the task to which the rest of the information in the structure relates."]
    pub xHandle: TaskHandle_t,
    #[doc = "< A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated!"]
    pub pcTaskName: *const ::std::os::raw::c_char,
    #[doc = "< A number unique to the task."]
    pub xTaskNumber: UBaseType_t,
    #[doc = "< The state in which the task existed when the structure was populated."]
    pub eCurrentState: eTaskState,
    #[doc = "< The priority at which the task was running (may be inherited) when the structure was populated."]
    pub uxCurrentPriority: UBaseType_t,
    #[doc = "< The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h."]
    pub uxBasePriority: UBaseType_t,
    #[doc = "< The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h."]
    pub ulRunTimeCounter: u32,
    #[doc = "< Points to the lowest address of the task's stack area."]
    pub pxStackBase: *mut StackType_t,
    #[doc = "< The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack."]
    pub usStackHighWaterMark: u32,
}
pub type TaskStatus_t = xTASK_STATUS;
#[doc = " Used with the uxTaskGetSnapshotAll() function to save memory snapshot of each task in the system."]
#[doc = " We need this struct because TCB_t is defined (hidden) in tasks.c."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_SNAPSHOT {
    #[doc = "< Address of task control block."]
    pub pxTCB: *mut ::core::ffi::c_void,
    #[doc = "< Points to the location of the last item placed on the tasks stack."]
    pub pxTopOfStack: *mut StackType_t,
    #[doc = "< Points to the end of the stack. pxTopOfStack < pxEndOfStack, stack grows hi2lo"]
    #[doc = "pxTopOfStack > pxEndOfStack, stack grows lo2hi"]
    pub pxEndOfStack: *mut StackType_t,
}
pub type TaskSnapshot_t = xTASK_SNAPSHOT;
#[doc = "< A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode."]
pub const eSleepModeStatus_eAbortSleep: eSleepModeStatus = 0;
#[doc = "< Enter a sleep mode that will not last any longer than the expected idle time."]
pub const eSleepModeStatus_eStandardSleep: eSleepModeStatus = 1;
#[doc = "< No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt."]
pub const eSleepModeStatus_eNoTasksWaitingTimeout: eSleepModeStatus = 2;
#[doc = " Possible return values for eTaskConfirmSleepModeStatus()."]
pub type eSleepModeStatus = u32;
extern "C" {
    pub fn xTaskCreatePinnedToCore(
        pvTaskCode: TaskFunction_t,
        pcName: *const ::std::os::raw::c_char,
        usStackDepth: u32,
        pvParameters: *mut ::core::ffi::c_void,
        uxPriority: UBaseType_t,
        pvCreatedTask: *mut TaskHandle_t,
        xCoreID: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskCreateRestricted(
        pxTaskDefinition: *const TaskParameters_t,
        pxCreatedTask: *mut TaskHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Memory regions are assigned to a restricted task when the task is created by"]
    #[doc = " a call to xTaskCreateRestricted().  These regions can be redefined using"]
    #[doc = " vTaskAllocateMPURegions()."]
    #[doc = ""]
    #[doc = " @param xTask The handle of the task being updated."]
    #[doc = ""]
    #[doc = " @param xRegions A pointer to an MemoryRegion_t structure that contains the"]
    #[doc = " new memory region definitions."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = ""]
    #[doc = " @code{c}"]
    #[doc = " // Define an array of MemoryRegion_t structures that configures an MPU region"]
    #[doc = " // allowing read/write access for 1024 bytes starting at the beginning of the"]
    #[doc = " // ucOneKByte array.  The other two of the maximum 3 definable regions are"]
    #[doc = " // unused so set to zero."]
    #[doc = " static const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] ="]
    #[doc = " {"]
    #[doc = " \t// Base address\t\tLength\t\tParameters"]
    #[doc = " \t{ ucOneKByte,\t\t1024,\t\tportMPU_REGION_READ_WRITE },"]
    #[doc = " \t{ 0,\t\t\t\t0,\t\t\t0 },"]
    #[doc = " \t{ 0,\t\t\t\t0,\t\t\t0 }"]
    #[doc = " };"]
    #[doc = ""]
    #[doc = " void vATask( void *pvParameters )"]
    #[doc = " {"]
    #[doc = " \t// This task was created such that it has access to certain regions of"]
    #[doc = " \t// memory as defined by the MPU configuration.  At some point it is"]
    #[doc = " \t// desired that these MPU regions are replaced with that defined in the"]
    #[doc = " \t// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()"]
    #[doc = " \t// for this purpose.  NULL is used as the task handle to indicate that this"]
    #[doc = " \t// function should modify the MPU regions of the calling task."]
    #[doc = " \tvTaskAllocateMPURegions( NULL, xAltRegions );"]
    #[doc = ""]
    #[doc = " \t// Now the task can continue its function, but from this point on can only"]
    #[doc = " \t// access its stack and the ucOneKByte array (unless any other statically"]
    #[doc = " \t// defined or shared regions have been declared elsewhere)."]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup Tasks"]
    pub fn vTaskAllocateMPURegions(xTask: TaskHandle_t, pxRegions: *const MemoryRegion_t);
}
extern "C" {
    #[doc = " Remove a task from the RTOS real time kernel's management."]
    #[doc = ""]
    #[doc = " The task being deleted will be removed from all ready, blocked, suspended"]
    #[doc = " and event lists."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskDelete must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " @note The idle task is responsible for freeing the kernel allocated"]
    #[doc = " memory from tasks that have been deleted.  It is therefore important that"]
    #[doc = " the idle task is not starved of microcontroller processing time if your"]
    #[doc = " application makes any calls to vTaskDelete ().  Memory allocated by the"]
    #[doc = " task code is not automatically freed, and should be freed before the task"]
    #[doc = " is deleted."]
    #[doc = ""]
    #[doc = " See the demo application file death.c for sample code that utilises"]
    #[doc = " vTaskDelete ()."]
    #[doc = ""]
    #[doc = " @param xTaskToDelete The handle of the task to be deleted.  Passing NULL will"]
    #[doc = " cause the calling task to be deleted."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vOtherFunction( void )"]
    #[doc = "  {"]
    #[doc = "  TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = " \t // Create the task, storing the handle."]
    #[doc = " \t xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = " \t // Use the handle to delete the task."]
    #[doc = " \t vTaskDelete( xHandle );"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup Tasks"]
    pub fn vTaskDelete(xTaskToDelete: TaskHandle_t);
}
extern "C" {
    #[doc = " Delay a task for a given number of ticks."]
    #[doc = ""]
    #[doc = " The actual time that the task remains blocked depends on the tick rate."]
    #[doc = " The constant portTICK_PERIOD_MS can be used to calculate real time from"]
    #[doc = " the tick rate - with the resolution of one tick period."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskDelay must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " vTaskDelay() specifies a time at which the task wishes to unblock relative to"]
    #[doc = " the time at which vTaskDelay() is called.  For example, specifying a block"]
    #[doc = " period of 100 ticks will cause the task to unblock 100 ticks after"]
    #[doc = " vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method"]
    #[doc = " of controlling the frequency of a periodic task as the path taken through the"]
    #[doc = " code, as well as other task and interrupt activity, will effect the frequency"]
    #[doc = " at which vTaskDelay() gets called and therefore the time at which the task"]
    #[doc = " next executes.  See vTaskDelayUntil() for an alternative API function designed"]
    #[doc = " to facilitate fixed frequency execution.  It does this by specifying an"]
    #[doc = " absolute time (rather than a relative time) at which the calling task should"]
    #[doc = " unblock."]
    #[doc = ""]
    #[doc = " @param xTicksToDelay The amount of time, in tick periods, that"]
    #[doc = " the calling task should block."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vTaskFunction( void * pvParameters )"]
    #[doc = "  {"]
    #[doc = "  // Block for 500ms."]
    #[doc = "  const TickType_t xDelay = 500 / portTICK_PERIOD_MS;"]
    #[doc = ""]
    #[doc = " \t for( ;; )"]
    #[doc = " \t {"]
    #[doc = " \t\t // Simply toggle the LED every 500ms, blocking between each toggle."]
    #[doc = " \t\t vToggleLED();"]
    #[doc = " \t\t vTaskDelay( xDelay );"]
    #[doc = " \t }"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskDelay(xTicksToDelay: TickType_t);
}
extern "C" {
    #[doc = " Delay a task until a specified time."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " This function can be used by periodic tasks to ensure a constant execution frequency."]
    #[doc = ""]
    #[doc = " This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will"]
    #[doc = " cause a task to block for the specified number of ticks from the time vTaskDelay () is"]
    #[doc = " called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed"]
    #[doc = " execution frequency as the time between a task starting to execute and that task"]
    #[doc = " calling vTaskDelay () may not be fixed [the task may take a different path though the"]
    #[doc = " code between calls, or may get interrupted or preempted a different number of times"]
    #[doc = " each time it executes]."]
    #[doc = ""]
    #[doc = " Whereas vTaskDelay () specifies a wake time relative to the time at which the function"]
    #[doc = " is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to"]
    #[doc = " unblock."]
    #[doc = ""]
    #[doc = " The constant portTICK_PERIOD_MS can be used to calculate real time from the tick"]
    #[doc = " rate - with the resolution of one tick period."]
    #[doc = ""]
    #[doc = " @param pxPreviousWakeTime Pointer to a variable that holds the time at which the"]
    #[doc = " task was last unblocked.  The variable must be initialised with the current time"]
    #[doc = " prior to its first use (see the example below).  Following this the variable is"]
    #[doc = " automatically updated within vTaskDelayUntil ()."]
    #[doc = ""]
    #[doc = " @param xTimeIncrement The cycle time period.  The task will be unblocked at"]
    #[doc = " time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the"]
    #[doc = " same xTimeIncrement parameter value will cause the task to execute with"]
    #[doc = " a fixed interface period."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  // Perform an action every 10 ticks."]
    #[doc = "  void vTaskFunction( void * pvParameters )"]
    #[doc = "  {"]
    #[doc = "  TickType_t xLastWakeTime;"]
    #[doc = "  const TickType_t xFrequency = 10;"]
    #[doc = ""]
    #[doc = " \t // Initialise the xLastWakeTime variable with the current time."]
    #[doc = " \t xLastWakeTime = xTaskGetTickCount ();"]
    #[doc = " \t for( ;; )"]
    #[doc = " \t {"]
    #[doc = " \t\t // Wait for the next cycle."]
    #[doc = " \t\t vTaskDelayUntil( &xLastWakeTime, xFrequency );"]
    #[doc = ""]
    #[doc = " \t\t // Perform action here."]
    #[doc = " \t }"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskDelayUntil(pxPreviousWakeTime: *mut TickType_t, xTimeIncrement: TickType_t);
}
extern "C" {
    #[doc = " Obtain the priority of any task."]
    #[doc = ""]
    #[doc = " INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task to be queried.  Passing a NULL"]
    #[doc = " handle results in the priority of the calling task being returned."]
    #[doc = ""]
    #[doc = " @return The priority of xTask."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "  TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "   // Create a task, storing the handle."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use the handle to obtain the priority of the created task."]
    #[doc = "   // It was created with tskIDLE_PRIORITY, but may have changed"]
    #[doc = "   // it itself."]
    #[doc = "   if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )"]
    #[doc = "   {"]
    #[doc = "       // The task has changed it's priority."]
    #[doc = "   }"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Is our priority higher than the created task?"]
    #[doc = "   if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )"]
    #[doc = "   {"]
    #[doc = "       // Our priority (obtained using NULL handle) is higher."]
    #[doc = "   }"]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn uxTaskPriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " A version of uxTaskPriorityGet() that can be used from an ISR."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task to be queried.  Passing a NULL"]
    #[doc = " handle results in the priority of the calling task being returned."]
    #[doc = ""]
    #[doc = " @return The priority of xTask."]
    #[doc = ""]
    pub fn uxTaskPriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " Obtain the state of any task."]
    #[doc = ""]
    #[doc = " States are encoded by the eTaskState enumerated type."]
    #[doc = ""]
    #[doc = " INCLUDE_eTaskGetState must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task to be queried."]
    #[doc = ""]
    #[doc = " @return The state of xTask at the time the function was called.  Note the"]
    #[doc = " state of the task might change between the function being called, and the"]
    #[doc = " functions return value being tested by the calling task."]
    pub fn eTaskGetState(xTask: TaskHandle_t) -> eTaskState;
}
extern "C" {
    #[doc = " Set the priority of any task."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " A context switch will occur before the function returns if the priority"]
    #[doc = " being set is higher than the currently executing task."]
    #[doc = ""]
    #[doc = " @param xTask Handle to the task for which the priority is being set."]
    #[doc = " Passing a NULL handle results in the priority of the calling task being set."]
    #[doc = ""]
    #[doc = " @param uxNewPriority The priority to which the task will be set."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "  TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "   // Create a task, storing the handle."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use the handle to raise the priority of the created task."]
    #[doc = "   vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use a NULL handle to raise our priority to the same value."]
    #[doc = "   vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
extern "C" {
    #[doc = " Suspend a task."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskSuspend must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " When suspended, a task will never get any microcontroller processing time,"]
    #[doc = " no matter what its priority."]
    #[doc = ""]
    #[doc = " Calls to vTaskSuspend are not accumulative -"]
    #[doc = " i.e. calling vTaskSuspend () twice on the same task still only requires one"]
    #[doc = " call to vTaskResume () to ready the suspended task."]
    #[doc = ""]
    #[doc = " @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL"]
    #[doc = " handle will cause the calling task to be suspended."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "  TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "   // Create a task, storing the handle."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use the handle to suspend the created task."]
    #[doc = "   vTaskSuspend( xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // The created task will not run during this period, unless"]
    #[doc = "   // another task calls vTaskResume( xHandle )."]
    #[doc = ""]
    #[doc = "   //..."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "   // Suspend ourselves."]
    #[doc = "   vTaskSuspend( NULL );"]
    #[doc = ""]
    #[doc = "   // We cannot get here unless another task calls vTaskResume"]
    #[doc = "   // with our handle as the parameter."]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskSuspend(xTaskToSuspend: TaskHandle_t);
}
extern "C" {
    #[doc = " Resumes a suspended task."]
    #[doc = ""]
    #[doc = " INCLUDE_vTaskSuspend must be defined as 1 for this function to be available."]
    #[doc = " See the configuration section for more information."]
    #[doc = ""]
    #[doc = " A task that has been suspended by one or more calls to vTaskSuspend ()"]
    #[doc = " will be made available for running again by a single call to"]
    #[doc = " vTaskResume ()."]
    #[doc = ""]
    #[doc = " @param xTaskToResume Handle to the task being readied."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "  TaskHandle_t xHandle;"]
    #[doc = ""]
    #[doc = "   // Create a task, storing the handle."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // Use the handle to suspend the created task."]
    #[doc = "   vTaskSuspend( xHandle );"]
    #[doc = ""]
    #[doc = "   // ..."]
    #[doc = ""]
    #[doc = "   // The created task will not run during this period, unless"]
    #[doc = "   // another task calls vTaskResume( xHandle )."]
    #[doc = ""]
    #[doc = "   //..."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "   // Resume the suspended task ourselves."]
    #[doc = "   vTaskResume( xHandle );"]
    #[doc = ""]
    #[doc = "   // The created task will once again get microcontroller processing"]
    #[doc = "   // time in accordance with its priority within the system."]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn vTaskResume(xTaskToResume: TaskHandle_t);
}
extern "C" {
    #[doc = " An implementation of vTaskResume() that can be called from within an ISR."]
    #[doc = ""]
    #[doc = " INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be"]
    #[doc = " available.  See the configuration section for more information."]
    #[doc = ""]
    #[doc = " A task that has been suspended by one or more calls to vTaskSuspend ()"]
    #[doc = " will be made available for running again by a single call to"]
    #[doc = " xTaskResumeFromISR ()."]
    #[doc = ""]
    #[doc = " xTaskResumeFromISR() should not be used to synchronise a task with an"]
    #[doc = " interrupt if there is a chance that the interrupt could arrive prior to the"]
    #[doc = " task being suspended - as this can lead to interrupts being missed. Use of a"]
    #[doc = " semaphore as a synchronisation mechanism would avoid this eventuality."]
    #[doc = ""]
    #[doc = " @param xTaskToResume Handle to the task being readied."]
    #[doc = ""]
    #[doc = " @return pdTRUE if resuming the task should result in a context switch,"]
    #[doc = " otherwise pdFALSE. This is used by the ISR to determine if a context switch"]
    #[doc = " may be required following the ISR."]
    #[doc = ""]
    #[doc = " \\ingroup TaskCtrl"]
    pub fn xTaskResumeFromISR(xTaskToResume: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    #[doc = " @cond */"]
    #[doc = " Starts the real time kernel tick processing."]
    #[doc = ""]
    #[doc = " After calling the kernel has control over which tasks are executed and when."]
    #[doc = ""]
    #[doc = " See the demo application file main.c for an example of creating"]
    #[doc = " tasks and starting the kernel."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "   // Create at least one task before starting the kernel."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );"]
    #[doc = ""]
    #[doc = "   // Start the real time kernel with preemption."]
    #[doc = "   vTaskStartScheduler ();"]
    #[doc = ""]
    #[doc = "   // Will not get here unless a task calls vTaskEndScheduler ()"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn vTaskStartScheduler();
}
extern "C" {
    #[doc = " Stops the real time kernel tick."]
    #[doc = ""]
    #[doc = " @note At the time of writing only the x86 real mode port, which runs on a PC"]
    #[doc = " in place of DOS, implements this function."]
    #[doc = ""]
    #[doc = " All created tasks will be automatically deleted and multitasking"]
    #[doc = " (either preemptive or cooperative) will stop."]
    #[doc = " Execution then resumes from the point where vTaskStartScheduler ()"]
    #[doc = " was called, as if vTaskStartScheduler () had just returned."]
    #[doc = ""]
    #[doc = " See the demo application file main. c in the demo/PC directory for an"]
    #[doc = " example that uses vTaskEndScheduler ()."]
    #[doc = ""]
    #[doc = " vTaskEndScheduler () requires an exit function to be defined within the"]
    #[doc = " portable layer (see vPortEndScheduler () in port. c for the PC port).  This"]
    #[doc = " performs hardware specific operations such as stopping the kernel tick."]
    #[doc = ""]
    #[doc = " vTaskEndScheduler () will cause all of the resources allocated by the"]
    #[doc = " kernel to be freed - but will not free resources allocated by application"]
    #[doc = " tasks."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vTaskCode( void * pvParameters )"]
    #[doc = "  {"]
    #[doc = "   for( ;; )"]
    #[doc = "   {"]
    #[doc = "       // Task code goes here."]
    #[doc = ""]
    #[doc = "       // At some point we want to end the real time kernel processing"]
    #[doc = "       // so call ..."]
    #[doc = "       vTaskEndScheduler ();"]
    #[doc = "   }"]
    #[doc = "  }"]
    #[doc = ""]
    #[doc = "  void vAFunction( void )"]
    #[doc = "  {"]
    #[doc = "   // Create at least one task before starting the kernel."]
    #[doc = "   xTaskCreate( vTaskCode, \"NAME\", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );"]
    #[doc = ""]
    #[doc = "   // Start the real time kernel with preemption."]
    #[doc = "   vTaskStartScheduler ();"]
    #[doc = ""]
    #[doc = "   // Will only get here when the vTaskCode () task has called"]
    #[doc = "   // vTaskEndScheduler ().  When we get here we are back to single task"]
    #[doc = "   // execution."]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn vTaskEndScheduler();
}
extern "C" {
    #[doc = " Suspends the scheduler without disabling interrupts."]
    #[doc = ""]
    #[doc = " Context switches will not occur while the scheduler is suspended."]
    #[doc = ""]
    #[doc = " After calling vTaskSuspendAll () the calling task will continue to execute"]
    #[doc = " without risk of being swapped out until a call to xTaskResumeAll () has been"]
    #[doc = " made."]
    #[doc = ""]
    #[doc = " API functions that have the potential to cause a context switch (for example,"]
    #[doc = " vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler"]
    #[doc = " is suspended."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vTask1( void * pvParameters )"]
    #[doc = "  {"]
    #[doc = "   for( ;; )"]
    #[doc = "   {"]
    #[doc = "       // Task code goes here."]
    #[doc = ""]
    #[doc = "       // ..."]
    #[doc = ""]
    #[doc = "       // At some point the task wants to perform a long operation during"]
    #[doc = "       // which it does not want to get swapped out.  It cannot use"]
    #[doc = "       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the"]
    #[doc = "       // operation may cause interrupts to be missed - including the"]
    #[doc = "       // ticks."]
    #[doc = ""]
    #[doc = "       // Prevent the real time kernel swapping out the task."]
    #[doc = "       vTaskSuspendAll ();"]
    #[doc = ""]
    #[doc = "       // Perform the operation here.  There is no need to use critical"]
    #[doc = "       // sections as we have all the microcontroller processing time."]
    #[doc = "       // During this time interrupts will still operate and the kernel"]
    #[doc = "       // tick count will be maintained."]
    #[doc = ""]
    #[doc = "       // ..."]
    #[doc = ""]
    #[doc = "       // The operation is complete.  Restart the kernel."]
    #[doc = "       xTaskResumeAll ();"]
    #[doc = "   }"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn vTaskSuspendAll();
}
extern "C" {
    #[doc = " Resumes scheduler activity after it was suspended by a call to"]
    #[doc = " vTaskSuspendAll()."]
    #[doc = ""]
    #[doc = " xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks"]
    #[doc = " that were previously suspended by a call to vTaskSuspend()."]
    #[doc = ""]
    #[doc = " @return If resuming the scheduler caused a context switch then pdTRUE is"]
    #[doc = "\t\t  returned, otherwise pdFALSE is returned."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = "  void vTask1( void * pvParameters )"]
    #[doc = "  {"]
    #[doc = "   for( ;; )"]
    #[doc = "   {"]
    #[doc = "       // Task code goes here."]
    #[doc = ""]
    #[doc = "       // ..."]
    #[doc = ""]
    #[doc = "       // At some point the task wants to perform a long operation during"]
    #[doc = "       // which it does not want to get swapped out.  It cannot use"]
    #[doc = "       // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the"]
    #[doc = "       // operation may cause interrupts to be missed - including the"]
    #[doc = "       // ticks."]
    #[doc = ""]
    #[doc = "       // Prevent the real time kernel swapping out the task."]
    #[doc = "       vTaskSuspendAll ();"]
    #[doc = ""]
    #[doc = "       // Perform the operation here.  There is no need to use critical"]
    #[doc = "       // sections as we have all the microcontroller processing time."]
    #[doc = "       // During this time interrupts will still operate and the real"]
    #[doc = "       // time kernel tick count will be maintained."]
    #[doc = ""]
    #[doc = "       // ..."]
    #[doc = ""]
    #[doc = "       // The operation is complete.  Restart the kernel.  We want to force"]
    #[doc = "       // a context switch - but there is no point if resuming the scheduler"]
    #[doc = "       // caused a context switch already."]
    #[doc = "       if( !xTaskResumeAll () )"]
    #[doc = "       {"]
    #[doc = "            taskYIELD ();"]
    #[doc = "       }"]
    #[doc = "   }"]
    #[doc = "  }"]
    #[doc = " @endcode"]
    #[doc = " \\ingroup SchedulerControl"]
    pub fn xTaskResumeAll() -> BaseType_t;
}
extern "C" {
    #[doc = " Get tick count"]
    #[doc = ""]
    #[doc = " @return The count of ticks since vTaskStartScheduler was called."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn xTaskGetTickCount() -> TickType_t;
}
extern "C" {
    #[doc = " Get tick count from ISR"]
    #[doc = ""]
    #[doc = " @return The count of ticks since vTaskStartScheduler was called."]
    #[doc = ""]
    #[doc = " This is a version of xTaskGetTickCount() that is safe to be called from an"]
    #[doc = " ISR - provided that TickType_t is the natural word size of the"]
    #[doc = " microcontroller being used or interrupt nesting is either not supported or"]
    #[doc = " not being used."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn xTaskGetTickCountFromISR() -> TickType_t;
}
extern "C" {
    #[doc = " Get current number of tasks"]
    #[doc = ""]
    #[doc = " @return The number of tasks that the real time kernel is currently managing."]
    #[doc = " This includes all ready, blocked and suspended tasks.  A task that"]
    #[doc = " has been deleted but not yet freed by the idle task will also be"]
    #[doc = " included in the count."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn uxTaskGetNumberOfTasks() -> UBaseType_t;
}
extern "C" {
    #[doc = " Get task name"]
    #[doc = ""]
    #[doc = " @return The text (human readable) name of the task referenced by the handle"]
    #[doc = " xTaskToQuery.  A task can query its own name by either passing in its own"]
    #[doc = " handle, or by setting xTaskToQuery to NULL.  INCLUDE_pcTaskGetTaskName must be"]
    #[doc = " set to 1 in FreeRTOSConfig.h for pcTaskGetTaskName() to be available."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn pcTaskGetTaskName(xTaskToQuery: TaskHandle_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the high water mark of the stack associated with xTask."]
    #[doc = ""]
    #[doc = " INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for"]
    #[doc = " this function to be available."]
    #[doc = ""]
    #[doc = " High water mark is the minimum free stack space there has been (in bytes"]
    #[doc = " rather than words as found in vanilla FreeRTOS) since the task started."]
    #[doc = " The smaller the returned number the closer the task has come to overflowing its stack."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task associated with the stack to be checked."]
    #[doc = " Set xTask to NULL to check the stack of the calling task."]
    #[doc = ""]
    #[doc = " @return The smallest amount of free stack space there has been (in bytes"]
    #[doc = " rather than words as found in vanilla FreeRTOS) since the task referenced by"]
    #[doc = " xTask was created."]
    pub fn uxTaskGetStackHighWaterMark(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    #[doc = " Returns the start of the stack associated with xTask."]
    #[doc = ""]
    #[doc = " INCLUDE_pxTaskGetStackStart must be set to 1 in FreeRTOSConfig.h for"]
    #[doc = " this function to be available."]
    #[doc = ""]
    #[doc = " Returns the highest stack memory address on architectures where the stack grows down"]
    #[doc = " from high memory, and the lowest memory address on architectures where the"]
    #[doc = " stack grows up from low memory."]
    #[doc = ""]
    #[doc = " @param xTask Handle of the task associated with the stack returned."]
    #[doc = " Set xTask to NULL to return the stack of the calling task."]
    #[doc = ""]
    #[doc = " @return A pointer to the start of the stack."]
    pub fn pxTaskGetStackStart(xTask: TaskHandle_t) -> *mut u8;
}
extern "C" {
    #[doc = " Set local storage pointer specific to the given task."]
    #[doc = ""]
    #[doc = " Each task contains an array of pointers that is dimensioned by the"]
    #[doc = " configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h."]
    #[doc = " The kernel does not use the pointers itself, so the application writer"]
    #[doc = " can use the pointers for any purpose they wish."]
    #[doc = ""]
    #[doc = " @param xTaskToSet  Task to set thread local storage pointer for"]
    #[doc = " @param xIndex The index of the pointer to set, from 0 to"]
    #[doc = "               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1."]
    #[doc = " @param pvValue  Pointer value to set."]
    pub fn vTaskSetThreadLocalStoragePointer(
        xTaskToSet: TaskHandle_t,
        xIndex: BaseType_t,
        pvValue: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Get local storage pointer specific to the given task."]
    #[doc = ""]
    #[doc = " Each task contains an array of pointers that is dimensioned by the"]
    #[doc = " configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h."]
    #[doc = " The kernel does not use the pointers itself, so the application writer"]
    #[doc = " can use the pointers for any purpose they wish."]
    #[doc = ""]
    #[doc = " @param xTaskToQuery  Task to get thread local storage pointer for"]
    #[doc = " @param xIndex The index of the pointer to get, from 0 to"]
    #[doc = "               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1."]
    #[doc = " @return  Pointer value"]
    pub fn pvTaskGetThreadLocalStoragePointer(
        xTaskToQuery: TaskHandle_t,
        xIndex: BaseType_t,
    ) -> *mut ::core::ffi::c_void;
}
#[doc = " Prototype of local storage pointer deletion callback."]
pub type TlsDeleteCallbackFunction_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: ::std::os::raw::c_int, arg2: *mut ::core::ffi::c_void),
>;
extern "C" {
    #[doc = " Set local storage pointer and deletion callback."]
    #[doc = ""]
    #[doc = " Each task contains an array of pointers that is dimensioned by the"]
    #[doc = " configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h."]
    #[doc = " The kernel does not use the pointers itself, so the application writer"]
    #[doc = " can use the pointers for any purpose they wish."]
    #[doc = ""]
    #[doc = " Local storage pointers set for a task can reference dynamically"]
    #[doc = " allocated resources. This function is similar to"]
    #[doc = " vTaskSetThreadLocalStoragePointer, but provides a way to release"]
    #[doc = " these resources when the task gets deleted. For each pointer,"]
    #[doc = " a callback function can be set. This function will be called"]
    #[doc = " when task is deleted, with the local storage pointer index"]
    #[doc = " and value as arguments."]
    #[doc = ""]
    #[doc = " @param xTaskToSet  Task to set thread local storage pointer for"]
    #[doc = " @param xIndex The index of the pointer to set, from 0 to"]
    #[doc = "               configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1."]
    #[doc = " @param pvValue  Pointer value to set."]
    #[doc = " @param pvDelCallback  Function to call to dispose of the local"]
    #[doc = "                       storage pointer when the task is deleted."]
    pub fn vTaskSetThreadLocalStoragePointerAndDelCallback(
        xTaskToSet: TaskHandle_t,
        xIndex: BaseType_t,
        pvValue: *mut ::core::ffi::c_void,
        pvDelCallback: TlsDeleteCallbackFunction_t,
    );
}
extern "C" {
    #[doc = " Calls the hook function associated with xTask. Passing xTask as NULL has"]
    #[doc = " the effect of calling the Running tasks (the calling task) hook function."]
    #[doc = ""]
    #[doc = " @param xTask  Handle of the task to call the hook for."]
    #[doc = " @param pvParameter  Parameter passed to the hook function for the task to interpret as it"]
    #[doc = " wants.  The return value is the value returned by the task hook function"]
    #[doc = " registered by the user."]
    pub fn xTaskCallApplicationTaskHook(
        xTask: TaskHandle_t,
        pvParameter: *mut ::core::ffi::c_void,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Get the handle of idle task for the current CPU."]
    #[doc = ""]
    #[doc = " xTaskGetIdleTaskHandle() is only available if"]
    #[doc = " INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h."]
    #[doc = ""]
    #[doc = " @return The handle of the idle task.  It is not valid to call"]
    #[doc = " xTaskGetIdleTaskHandle() before the scheduler has been started."]
    pub fn xTaskGetIdleTaskHandle() -> TaskHandle_t;
}
extern "C" {
    #[doc = " Get the handle of idle task for the given CPU."]
    #[doc = ""]
    #[doc = " xTaskGetIdleTaskHandleForCPU() is only available if"]
    #[doc = " INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h."]
    #[doc = ""]
    #[doc = " @param cpuid The CPU to get the handle for"]
    #[doc = ""]
    #[doc = " @return Idle task handle of a given cpu. It is not valid to call"]
    #[doc = " xTaskGetIdleTaskHandleForCPU() before the scheduler has been started."]
    pub fn xTaskGetIdleTaskHandleForCPU(cpuid: UBaseType_t) -> TaskHandle_t;
}
extern "C" {
    #[doc = " Get the state of tasks in the system."]
    #[doc = ""]
    #[doc = " configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for"]
    #[doc = " uxTaskGetSystemState() to be available."]
    #[doc = ""]
    #[doc = " uxTaskGetSystemState() populates an TaskStatus_t structure for each task in"]
    #[doc = " the system.  TaskStatus_t structures contain, among other things, members"]
    #[doc = " for the task handle, task name, task priority, task state, and total amount"]
    #[doc = " of run time consumed by the task.  See the TaskStatus_t structure"]
    #[doc = " definition in this file for the full member list."]
    #[doc = ""]
    #[doc = " @note  This function is intended for debugging use only as its use results in"]
    #[doc = " the scheduler remaining suspended for an extended period."]
    #[doc = ""]
    #[doc = " @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures."]
    #[doc = " The array must contain at least one TaskStatus_t structure for each task"]
    #[doc = " that is under the control of the RTOS.  The number of tasks under the control"]
    #[doc = " of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function."]
    #[doc = ""]
    #[doc = " @param uxArraySize The size of the array pointed to by the pxTaskStatusArray"]
    #[doc = " parameter.  The size is specified as the number of indexes in the array, or"]
    #[doc = " the number of TaskStatus_t structures contained in the array, not by the"]
    #[doc = " number of bytes in the array."]
    #[doc = ""]
    #[doc = " @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in"]
    #[doc = " FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the"]
    #[doc = " total run time (as defined by the run time stats clock, see"]
    #[doc = " http://www.freertos.org/rtos-run-time-stats.html) since the target booted."]
    #[doc = " pulTotalRunTime can be set to NULL to omit the total run time information."]
    #[doc = ""]
    #[doc = " @return The number of TaskStatus_t structures that were populated by"]
    #[doc = " uxTaskGetSystemState().  This should equal the number returned by the"]
    #[doc = " uxTaskGetNumberOfTasks() API function, but will be zero if the value passed"]
    #[doc = " in the uxArraySize parameter was too small."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = " // This example demonstrates how a human readable table of run time stats"]
    #[doc = " // information is generated from raw data provided by uxTaskGetSystemState()."]
    #[doc = " // The human readable table is written to pcWriteBuffer"]
    #[doc = " void vTaskGetRunTimeStats( char *pcWriteBuffer )"]
    #[doc = " {"]
    #[doc = " TaskStatus_t *pxTaskStatusArray;"]
    #[doc = " volatile UBaseType_t uxArraySize, x;"]
    #[doc = " uint32_t ulTotalRunTime, ulStatsAsPercentage;"]
    #[doc = ""]
    #[doc = "  // Make sure the write buffer does not contain a string."]
    #[doc = "  *pcWriteBuffer = 0x00;"]
    #[doc = ""]
    #[doc = "  // Take a snapshot of the number of tasks in case it changes while this"]
    #[doc = "  // function is executing."]
    #[doc = "  uxArraySize = uxTaskGetNumberOfTasks();"]
    #[doc = ""]
    #[doc = "  // Allocate a TaskStatus_t structure for each task.  An array could be"]
    #[doc = "  // allocated statically at compile time."]
    #[doc = "  pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );"]
    #[doc = ""]
    #[doc = "  if( pxTaskStatusArray != NULL )"]
    #[doc = "  {"]
    #[doc = "      // Generate raw status information about each task."]
    #[doc = "      uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );"]
    #[doc = ""]
    #[doc = "      // For percentage calculations."]
    #[doc = "      ulTotalRunTime /= 100UL;"]
    #[doc = ""]
    #[doc = "      // Avoid divide by zero errors."]
    #[doc = "      if( ulTotalRunTime > 0 )"]
    #[doc = "      {"]
    #[doc = "          // For each populated position in the pxTaskStatusArray array,"]
    #[doc = "          // format the raw data as human readable ASCII data"]
    #[doc = "          for( x = 0; x < uxArraySize; x++ )"]
    #[doc = "          {"]
    #[doc = "              // What percentage of the total run time has the task used?"]
    #[doc = "              // This will always be rounded down to the nearest integer."]
    #[doc = "              // ulTotalRunTimeDiv100 has already been divided by 100."]
    #[doc = "              ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;"]
    #[doc = ""]
    #[doc = "              if( ulStatsAsPercentage > 0UL )"]
    #[doc = "              {"]
    #[doc = "                  sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t%lu%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );"]
    #[doc = "              }"]
    #[doc = "              else"]
    #[doc = "              {"]
    #[doc = "                  // If the percentage is zero here then the task has"]
    #[doc = "                  // consumed less than 1% of the total run time."]
    #[doc = "                  sprintf( pcWriteBuffer, \"%s\\t\\t%lu\\t\\t<1%%\\r\\n\", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );"]
    #[doc = "              }"]
    #[doc = ""]
    #[doc = "              pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );"]
    #[doc = "          }"]
    #[doc = "      }"]
    #[doc = ""]
    #[doc = "      // The array is no longer needed, free the memory it consumes."]
    #[doc = "      vPortFree( pxTaskStatusArray );"]
    #[doc = "  }"]
    #[doc = " }"]
    #[doc = " @endcode"]
    pub fn uxTaskGetSystemState(
        pxTaskStatusArray: *mut TaskStatus_t,
        uxArraySize: UBaseType_t,
        pulTotalRunTime: *mut u32,
    ) -> UBaseType_t;
}
extern "C" {
    #[doc = " List all the current tasks."]
    #[doc = ""]
    #[doc = " configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must"]
    #[doc = " both be defined as 1 for this function to be available.  See the"]
    #[doc = " configuration section of the FreeRTOS.org website for more information."]
    #[doc = ""]
    #[doc = " @note This function will disable interrupts for its duration.  It is"]
    #[doc = " not intended for normal application runtime use but as a debug aid."]
    #[doc = ""]
    #[doc = " Lists all the current tasks, along with their current state and stack"]
    #[doc = " usage high water mark."]
    #[doc = ""]
    #[doc = " Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or"]
    #[doc = " suspended ('S')."]
    #[doc = ""]
    #[doc = " @note This function is provided for convenience only, and is used by many of the"]
    #[doc = " demo applications.  Do not consider it to be part of the scheduler."]
    #[doc = ""]
    #[doc = " vTaskList() calls uxTaskGetSystemState(), then formats part of the"]
    #[doc = " uxTaskGetSystemState() output into a human readable table that displays task"]
    #[doc = " names, states and stack usage."]
    #[doc = ""]
    #[doc = " vTaskList() has a dependency on the sprintf() C library function that might"]
    #[doc = " bloat the code size, use a lot of stack, and provide different results on"]
    #[doc = " different platforms.  An alternative, tiny, third party, and limited"]
    #[doc = " functionality implementation of sprintf() is provided in many of the"]
    #[doc = " FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note"]
    #[doc = " printf-stdarg.c does not provide a full snprintf() implementation!)."]
    #[doc = ""]
    #[doc = " It is recommended that production systems call uxTaskGetSystemState()"]
    #[doc = " directly to get access to raw stats data, rather than indirectly through a"]
    #[doc = " call to vTaskList()."]
    #[doc = ""]
    #[doc = " @param pcWriteBuffer A buffer into which the above mentioned details"]
    #[doc = " will be written, in ASCII form.  This buffer is assumed to be large"]
    #[doc = " enough to contain the generated report.  Approximately 40 bytes per"]
    #[doc = " task should be sufficient."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn vTaskList(pcWriteBuffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Get the state of running tasks as a string"]
    #[doc = ""]
    #[doc = " configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS"]
    #[doc = " must both be defined as 1 for this function to be available.  The application"]
    #[doc = " must also then provide definitions for"]
    #[doc = " portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()"]
    #[doc = " to configure a peripheral timer/counter and return the timers current count"]
    #[doc = " value respectively.  The counter should be at least 10 times the frequency of"]
    #[doc = " the tick count."]
    #[doc = ""]
    #[doc = " @note This function will disable interrupts for its duration.  It is"]
    #[doc = " not intended for normal application runtime use but as a debug aid."]
    #[doc = ""]
    #[doc = " Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total"]
    #[doc = " accumulated execution time being stored for each task.  The resolution"]
    #[doc = " of the accumulated time value depends on the frequency of the timer"]
    #[doc = " configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro."]
    #[doc = " Calling vTaskGetRunTimeStats() writes the total execution time of each"]
    #[doc = " task into a buffer, both as an absolute count value and as a percentage"]
    #[doc = " of the total system execution time."]
    #[doc = ""]
    #[doc = " @note This function is provided for convenience only, and is used by many of the"]
    #[doc = " demo applications.  Do not consider it to be part of the scheduler."]
    #[doc = ""]
    #[doc = " vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the"]
    #[doc = " uxTaskGetSystemState() output into a human readable table that displays the"]
    #[doc = " amount of time each task has spent in the Running state in both absolute and"]
    #[doc = " percentage terms."]
    #[doc = ""]
    #[doc = " vTaskGetRunTimeStats() has a dependency on the sprintf() C library function"]
    #[doc = " that might bloat the code size, use a lot of stack, and provide different"]
    #[doc = " results on different platforms.  An alternative, tiny, third party, and"]
    #[doc = " limited functionality implementation of sprintf() is provided in many of the"]
    #[doc = " FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note"]
    #[doc = " printf-stdarg.c does not provide a full snprintf() implementation!)."]
    #[doc = ""]
    #[doc = " It is recommended that production systems call uxTaskGetSystemState() directly"]
    #[doc = " to get access to raw stats data, rather than indirectly through a call to"]
    #[doc = " vTaskGetRunTimeStats()."]
    #[doc = ""]
    #[doc = " @param pcWriteBuffer A buffer into which the execution times will be"]
    #[doc = " written, in ASCII form.  This buffer is assumed to be large enough to"]
    #[doc = " contain the generated report.  Approximately 40 bytes per task should"]
    #[doc = " be sufficient."]
    #[doc = ""]
    #[doc = " \\ingroup TaskUtils"]
    pub fn vTaskGetRunTimeStats(pcWriteBuffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Send task notification."]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " A notification sent to a task will remain pending until it is cleared by the"]
    #[doc = " task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was"]
    #[doc = " already in the Blocked state to wait for a notification when the notification"]
    #[doc = " arrives then the task will automatically be removed from the Blocked state"]
    #[doc = " (unblocked) and the notification cleared."]
    #[doc = ""]
    #[doc = " A task can use xTaskNotifyWait() to [optionally] block to wait for a"]
    #[doc = " notification to be pending, or ulTaskNotifyTake() to [optionally] block"]
    #[doc = " to wait for its notification value to have a non-zero value.  The task does"]
    #[doc = " not consume any CPU time while it is in the Blocked state."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
    #[doc = ""]
    #[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
    #[doc = " task can be returned from the xTaskCreate() API function used to create the"]
    #[doc = " task, and the handle of the currently running task can be obtained by calling"]
    #[doc = " xTaskGetCurrentTaskHandle()."]
    #[doc = ""]
    #[doc = " @param ulValue Data that can be sent with the notification.  How the data is"]
    #[doc = " used depends on the value of the eAction parameter."]
    #[doc = ""]
    #[doc = " @param eAction Specifies how the notification updates the task's notification"]
    #[doc = " value, if at all.  Valid values for eAction are as follows:"]
    #[doc = "\t- eSetBits:"]
    #[doc = "\t  The task's notification value is bitwise ORed with ulValue.  xTaskNofify()"]
    #[doc = " \t  always returns pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eIncrement:"]
    #[doc = "\t  The task's notification value is incremented.  ulValue is not used and"]
    #[doc = "\t  xTaskNotify() always returns pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eSetValueWithOverwrite:"]
    #[doc = "\t  The task's notification value is set to the value of ulValue, even if the"]
    #[doc = "\t  task being notified had not yet processed the previous notification (the"]
    #[doc = "\t  task already had a notification pending).  xTaskNotify() always returns"]
    #[doc = "\t  pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eSetValueWithoutOverwrite:"]
    #[doc = "\t  If the task being notified did not already have a notification pending then"]
    #[doc = "\t  the task's notification value is set to ulValue and xTaskNotify() will"]
    #[doc = "\t  return pdPASS.  If the task being notified already had a notification"]
    #[doc = "\t  pending then no action is performed and pdFAIL is returned."]
    #[doc = ""]
    #[doc = "\t- eNoAction:"]
    #[doc = "\t  The task receives a notification without its notification value being"]
    #[doc = "\t\u{a0}\u{a0}updated.  ulValue is not used and xTaskNotify() always returns pdPASS in"]
    #[doc = "\t  this case."]
    #[doc = ""]
    #[doc = " @return Dependent on the value of eAction.  See the description of the"]
    #[doc = " eAction parameter."]
    #[doc = ""]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn xTaskNotify(
        xTaskToNotify: TaskHandle_t,
        ulValue: u32,
        eAction: eNotifyAction,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Send task notification from an ISR."]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " A version of xTaskNotify() that can be used from an interrupt service routine"]
    #[doc = " (ISR)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " A notification sent to a task will remain pending until it is cleared by the"]
    #[doc = " task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was"]
    #[doc = " already in the Blocked state to wait for a notification when the notification"]
    #[doc = " arrives then the task will automatically be removed from the Blocked state"]
    #[doc = " (unblocked) and the notification cleared."]
    #[doc = ""]
    #[doc = " A task can use xTaskNotifyWait() to [optionally] block to wait for a"]
    #[doc = " notification to be pending, or ulTaskNotifyTake() to [optionally] block"]
    #[doc = " to wait for its notification value to have a non-zero value.  The task does"]
    #[doc = " not consume any CPU time while it is in the Blocked state."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
    #[doc = ""]
    #[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
    #[doc = " task can be returned from the xTaskCreate() API function used to create the"]
    #[doc = " task, and the handle of the currently running task can be obtained by calling"]
    #[doc = " xTaskGetCurrentTaskHandle()."]
    #[doc = ""]
    #[doc = " @param ulValue Data that can be sent with the notification.  How the data is"]
    #[doc = " used depends on the value of the eAction parameter."]
    #[doc = ""]
    #[doc = " @param eAction Specifies how the notification updates the task's notification"]
    #[doc = " value, if at all.  Valid values for eAction are as follows:"]
    #[doc = "\t- eSetBits:"]
    #[doc = "\t  The task's notification value is bitwise ORed with ulValue.  xTaskNofify()"]
    #[doc = " \t  always returns pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eIncrement:"]
    #[doc = "\t  The task's notification value is incremented.  ulValue is not used and"]
    #[doc = "\t  xTaskNotify() always returns pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eSetValueWithOverwrite:"]
    #[doc = "\t  The task's notification value is set to the value of ulValue, even if the"]
    #[doc = "\t  task being notified had not yet processed the previous notification (the"]
    #[doc = "\t  task already had a notification pending).  xTaskNotify() always returns"]
    #[doc = "\t  pdPASS in this case."]
    #[doc = ""]
    #[doc = "\t- eSetValueWithoutOverwrite:"]
    #[doc = "\t  If the task being notified did not already have a notification pending then"]
    #[doc = "\t  the task's notification value is set to ulValue and xTaskNotify() will"]
    #[doc = "\t  return pdPASS.  If the task being notified already had a notification"]
    #[doc = "\t  pending then no action is performed and pdFAIL is returned."]
    #[doc = ""]
    #[doc = "\t- eNoAction:"]
    #[doc = "\t  The task receives a notification without its notification value being"]
    #[doc = "\t  updated.  ulValue is not used and xTaskNotify() always returns pdPASS in"]
    #[doc = "\t  this case."]
    #[doc = ""]
    #[doc = " @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set"]
    #[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the"]
    #[doc = " task to which the notification was sent to leave the Blocked state, and the"]
    #[doc = " unblocked task has a priority higher than the currently running task.  If"]
    #[doc = " xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should"]
    #[doc = " be requested before the interrupt is exited.  How a context switch is"]
    #[doc = " requested from an ISR is dependent on the port - see the documentation page"]
    #[doc = " for the port in use."]
    #[doc = ""]
    #[doc = " @return Dependent on the value of eAction.  See the description of the"]
    #[doc = " eAction parameter."]
    #[doc = ""]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn xTaskNotifyFromISR(
        xTaskToNotify: TaskHandle_t,
        ulValue: u32,
        eAction: eNotifyAction,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Wait for task notification"]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " A notification sent to a task will remain pending until it is cleared by the"]
    #[doc = " task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was"]
    #[doc = " already in the Blocked state to wait for a notification when the notification"]
    #[doc = " arrives then the task will automatically be removed from the Blocked state"]
    #[doc = " (unblocked) and the notification cleared."]
    #[doc = ""]
    #[doc = " A task can use xTaskNotifyWait() to [optionally] block to wait for a"]
    #[doc = " notification to be pending, or ulTaskNotifyTake() to [optionally] block"]
    #[doc = " to wait for its notification value to have a non-zero value.  The task does"]
    #[doc = " not consume any CPU time while it is in the Blocked state."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
    #[doc = ""]
    #[doc = " @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value"]
    #[doc = " will be cleared in the calling task's notification value before the task"]
    #[doc = " checks to see if any notifications are pending, and optionally blocks if no"]
    #[doc = " notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if"]
    #[doc = " limits.h is included) or 0xffffffffUL (if limits.h is not included) will have"]
    #[doc = " the effect of resetting the task's notification value to 0.  Setting"]
    #[doc = " ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged."]
    #[doc = ""]
    #[doc = " @param ulBitsToClearOnExit If a notification is pending or received before"]
    #[doc = " the calling task exits the xTaskNotifyWait() function then the task's"]
    #[doc = " notification value (see the xTaskNotify() API function) is passed out using"]
    #[doc = " the pulNotificationValue parameter.  Then any bits that are set in"]
    #[doc = " ulBitsToClearOnExit will be cleared in the task's notification value (note"]
    #[doc = " *pulNotificationValue is set before any bits are cleared).  Setting"]
    #[doc = " ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL"]
    #[doc = " (if limits.h is not included) will have the effect of resetting the task's"]
    #[doc = " notification value to 0 before the function exits.  Setting"]
    #[doc = " ulBitsToClearOnExit to 0 will leave the task's notification value unchanged"]
    #[doc = " when the function exits (in which case the value passed out in"]
    #[doc = " pulNotificationValue will match the task's notification value)."]
    #[doc = ""]
    #[doc = " @param pulNotificationValue Used to pass the task's notification value out"]
    #[doc = " of the function.  Note the value passed out will not be effected by the"]
    #[doc = " clearing of any bits caused by ulBitsToClearOnExit being non-zero."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time that the task should wait in"]
    #[doc = " the Blocked state for a notification to be received, should a notification"]
    #[doc = " not already be pending when xTaskNotifyWait() was called.  The task"]
    #[doc = " will not consume any processing time while it is in the Blocked state.  This"]
    #[doc = " is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be"]
    #[doc = " used to convert a time specified in milliseconds to a time specified in"]
    #[doc = " ticks."]
    #[doc = ""]
    #[doc = " @return If a notification was received (including notifications that were"]
    #[doc = " already pending when xTaskNotifyWait was called) then pdPASS is"]
    #[doc = " returned.  Otherwise pdFAIL is returned."]
    #[doc = ""]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn xTaskNotifyWait(
        ulBitsToClearOnEntry: u32,
        ulBitsToClearOnExit: u32,
        pulNotificationValue: *mut u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Simplified macro for sending task notification from ISR."]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro"]
    #[doc = " to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " A version of xTaskNotifyGive() that can be called from an interrupt service"]
    #[doc = " routine (ISR)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " vTaskNotifyGiveFromISR() is intended for use when task notifications are"]
    #[doc = " used as light weight and faster binary or counting semaphore equivalents."]
    #[doc = " Actual FreeRTOS semaphores are given from an ISR using the"]
    #[doc = " xSemaphoreGiveFromISR() API function, the equivalent action that instead uses"]
    #[doc = " a task notification is vTaskNotifyGiveFromISR()."]
    #[doc = ""]
    #[doc = " When task notifications are being used as a binary or counting semaphore"]
    #[doc = " equivalent then the task being notified should wait for the notification"]
    #[doc = " using the ulTaskNotificationTake() API function rather than the"]
    #[doc = " xTaskNotifyWait() API function."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details."]
    #[doc = ""]
    #[doc = " @param xTaskToNotify The handle of the task being notified.  The handle to a"]
    #[doc = " task can be returned from the xTaskCreate() API function used to create the"]
    #[doc = " task, and the handle of the currently running task can be obtained by calling"]
    #[doc = " xTaskGetCurrentTaskHandle()."]
    #[doc = ""]
    #[doc = " @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set"]
    #[doc = " *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the"]
    #[doc = " task to which the notification was sent to leave the Blocked state, and the"]
    #[doc = " unblocked task has a priority higher than the currently running task.  If"]
    #[doc = " vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch"]
    #[doc = " should be requested before the interrupt is exited.  How a context switch is"]
    #[doc = " requested from an ISR is dependent on the port - see the documentation page"]
    #[doc = " for the port in use."]
    #[doc = ""]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn vTaskNotifyGiveFromISR(
        xTaskToNotify: TaskHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
extern "C" {
    #[doc = " Simplified macro for receiving task notification."]
    #[doc = ""]
    #[doc = " configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this"]
    #[doc = " function to be available."]
    #[doc = ""]
    #[doc = " When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private"]
    #[doc = " \"notification value\", which is a 32-bit unsigned integer (uint32_t)."]
    #[doc = ""]
    #[doc = " Events can be sent to a task using an intermediary object.  Examples of such"]
    #[doc = " objects are queues, semaphores, mutexes and event groups.  Task notifications"]
    #[doc = " are a method of sending an event directly to a task without the need for such"]
    #[doc = " an intermediary object."]
    #[doc = ""]
    #[doc = " A notification sent to a task can optionally perform an action, such as"]
    #[doc = " update, overwrite or increment the task's notification value.  In that way"]
    #[doc = " task notifications can be used to send data to a task, or be used as light"]
    #[doc = " weight and fast binary or counting semaphores."]
    #[doc = ""]
    #[doc = " ulTaskNotifyTake() is intended for use when a task notification is used as a"]
    #[doc = " faster and lighter weight binary or counting semaphore alternative.  Actual"]
    #[doc = " FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the"]
    #[doc = " equivalent action that instead uses a task notification is"]
    #[doc = " ulTaskNotifyTake()."]
    #[doc = ""]
    #[doc = " When a task is using its notification value as a binary or counting semaphore"]
    #[doc = " other tasks should send notifications to it using the xTaskNotifyGive()"]
    #[doc = " macro, or xTaskNotify() function with the eAction parameter set to"]
    #[doc = " eIncrement."]
    #[doc = ""]
    #[doc = " ulTaskNotifyTake() can either clear the task's notification value to"]
    #[doc = " zero on exit, in which case the notification value acts like a binary"]
    #[doc = " semaphore, or decrement the task's notification value on exit, in which case"]
    #[doc = " the notification value acts like a counting semaphore."]
    #[doc = ""]
    #[doc = " A task can use ulTaskNotifyTake() to [optionally] block to wait for a"]
    #[doc = " the task's notification value to be non-zero.  The task does not consume any"]
    #[doc = " CPU time while it is in the Blocked state."]
    #[doc = ""]
    #[doc = " Where as xTaskNotifyWait() will return when a notification is pending,"]
    #[doc = " ulTaskNotifyTake() will return when the task's notification value is"]
    #[doc = " not zero."]
    #[doc = ""]
    #[doc = " See http://www.FreeRTOS.org/RTOS-task-notifications.html for details."]
    #[doc = ""]
    #[doc = " @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's"]
    #[doc = " notification value is decremented when the function exits.  In this way the"]
    #[doc = " notification value acts like a counting semaphore.  If xClearCountOnExit is"]
    #[doc = " not pdFALSE then the task's notification value is cleared to zero when the"]
    #[doc = " function exits.  In this way the notification value acts like a binary"]
    #[doc = " semaphore."]
    #[doc = ""]
    #[doc = " @param xTicksToWait The maximum amount of time that the task should wait in"]
    #[doc = " the Blocked state for the task's notification value to be greater than zero,"]
    #[doc = " should the count not already be greater than zero when"]
    #[doc = " ulTaskNotifyTake() was called.  The task will not consume any processing"]
    #[doc = " time while it is in the Blocked state.  This is specified in kernel ticks,"]
    #[doc = " the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time"]
    #[doc = " specified in milliseconds to a time specified in ticks."]
    #[doc = ""]
    #[doc = " @return The task's notification count before it is either cleared to zero or"]
    #[doc = " decremented (see the xClearCountOnExit parameter)."]
    #[doc = ""]
    #[doc = " \\ingroup TaskNotifications"]
    pub fn ulTaskNotifyTake(xClearCountOnExit: BaseType_t, xTicksToWait: TickType_t) -> u32;
}
extern "C" {
    #[doc = " @cond"]
    pub fn xTaskIncrementTick() -> BaseType_t;
}
extern "C" {
    pub fn vTaskPlaceOnEventList(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn vTaskPlaceOnUnorderedEventList(
        pxEventList: *mut List_t,
        xItemValue: TickType_t,
        xTicksToWait: TickType_t,
    );
}
extern "C" {
    pub fn vTaskPlaceOnEventListRestricted(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn xTaskRemoveFromEventList(pxEventList: *const List_t) -> BaseType_t;
}
extern "C" {
    pub fn xTaskRemoveFromUnorderedEventList(
        pxEventListItem: *mut ListItem_t,
        xItemValue: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskSwitchContext();
}
extern "C" {
    pub fn uxTaskResetEventItemValue() -> TickType_t;
}
extern "C" {
    pub fn xTaskGetCurrentTaskHandle() -> TaskHandle_t;
}
extern "C" {
    pub fn xTaskGetCurrentTaskHandleForCPU(cpuid: BaseType_t) -> TaskHandle_t;
}
extern "C" {
    pub fn vTaskSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
extern "C" {
    pub fn xTaskCheckForTimeOut(
        pxTimeOut: *mut TimeOut_t,
        pxTicksToWait: *mut TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskMissedYield();
}
extern "C" {
    pub fn xTaskGetSchedulerState() -> BaseType_t;
}
extern "C" {
    pub fn vTaskPriorityInherit(pxMutexHolder: TaskHandle_t);
}
extern "C" {
    pub fn xTaskPriorityDisinherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn uxTaskGetTaskNumber(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn xTaskGetAffinity(xTask: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskSetTaskNumber(xTask: TaskHandle_t, uxHandle: UBaseType_t);
}
extern "C" {
    pub fn vTaskStepTick(xTicksToJump: TickType_t);
}
extern "C" {
    pub fn eTaskConfirmSleepModeStatus() -> eSleepModeStatus;
}
extern "C" {
    pub fn pvTaskIncrementMutexHeldCount() -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn uxTaskGetSnapshotAll(
        pxTaskSnapshotArray: *mut TaskSnapshot_t,
        uxArraySize: UBaseType_t,
        pxTcbSz: *mut UBaseType_t,
    ) -> UBaseType_t;
}
#[doc = " Type by which ring buffers are referenced. For example, a call to xRingbufferCreate()"]
#[doc = " returns a RingbufHandle_t variable that can then be used as a parameter to"]
#[doc = " xRingbufferSend(), xRingbufferReceive(), etc."]
pub type RingbufHandle_t = *mut ::core::ffi::c_void;
#[doc = " No-split buffers will only store an item in contiguous memory and will"]
#[doc = " never split an item. Each item requires an 8 byte overhead for a header"]
#[doc = " and will always internally occupy a 32-bit aligned size of space."]
pub const RingbufferType_t_RINGBUF_TYPE_NOSPLIT: RingbufferType_t = 0;
#[doc = " Allow-split buffers will split an item into two parts if necessary in"]
#[doc = " order to store it. Each item requires an 8 byte overhead for a header,"]
#[doc = " splitting incurs an extra header. Each item will always internally occupy"]
#[doc = " a 32-bit aligned size of space."]
pub const RingbufferType_t_RINGBUF_TYPE_ALLOWSPLIT: RingbufferType_t = 1;
#[doc = " Byte buffers store data as a sequence of bytes and do not maintain separate"]
#[doc = " items, therefore byte buffers have no overhead. All data is stored as a"]
#[doc = " sequence of byte and any number of bytes can be sent or retrieved each"]
#[doc = " time."]
pub const RingbufferType_t_RINGBUF_TYPE_BYTEBUF: RingbufferType_t = 2;
#[doc = " Byte buffers store data as a sequence of bytes and do not maintain separate"]
#[doc = " items, therefore byte buffers have no overhead. All data is stored as a"]
#[doc = " sequence of byte and any number of bytes can be sent or retrieved each"]
#[doc = " time."]
pub const RingbufferType_t_RINGBUF_TYPE_MAX: RingbufferType_t = 3;
pub type RingbufferType_t = u32;
extern "C" {
    #[doc = " @brief       Create a ring buffer"]
    #[doc = ""]
    #[doc = " @param[in]   xBufferSize Size of the buffer in bytes. Note that items require"]
    #[doc = "              space for overhead in no-split/allow-split buffers"]
    #[doc = " @param[in]   xBufferType Type of ring buffer, see documentation."]
    #[doc = ""]
    #[doc = " @note    xBufferSize of no-split/allow-split buffers will be rounded up to the nearest 32-bit aligned size."]
    #[doc = ""]
    #[doc = " @return  A handle to the created ring buffer, or NULL in case of error."]
    pub fn xRingbufferCreate(xBufferSize: size_t, xBufferType: RingbufferType_t)
        -> RingbufHandle_t;
}
extern "C" {
    #[doc = " @brief Create a ring buffer of type RINGBUF_TYPE_NOSPLIT for a fixed item_size"]
    #[doc = ""]
    #[doc = " This API is similar to xRingbufferCreate(), but it will internally allocate"]
    #[doc = " additional space for the headers."]
    #[doc = ""]
    #[doc = " @param[in]   xItemSize   Size of each item to be put into the ring buffer"]
    #[doc = " @param[in]   xItemNum    Maximum number of items the buffer needs to hold simultaneously"]
    #[doc = ""]
    #[doc = " @return  A RingbufHandle_t handle to the created ring buffer, or NULL in case of error."]
    pub fn xRingbufferCreateNoSplit(xItemSize: size_t, xItemNum: size_t) -> RingbufHandle_t;
}
extern "C" {
    #[doc = " @brief       Insert an item into the ring buffer"]
    #[doc = ""]
    #[doc = " Attempt to insert an item into the ring buffer. This function will block until"]
    #[doc = " enough free space is available or until it times out."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to insert the item into"]
    #[doc = " @param[in]   pvItem          Pointer to data to insert. NULL is allowed if xItemSize is 0."]
    #[doc = " @param[in]   xItemSize       Size of data to insert."]
    #[doc = " @param[in]   xTicksToWait    Ticks to wait for room in the ring buffer."]
    #[doc = ""]
    #[doc = " @note    For no-split/allow-split ring buffers, the actual size of memory that"]
    #[doc = "          the item will occupy will be rounded up to the nearest 32-bit aligned"]
    #[doc = "          size. This is done to ensure all items are always stored in 32-bit"]
    #[doc = "          aligned fashion."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE if succeeded"]
    #[doc = "      - pdFALSE on time-out or when the data is larger than the maximum permissible size of the buffer"]
    pub fn xRingbufferSend(
        xRingbuffer: RingbufHandle_t,
        pvItem: *const ::core::ffi::c_void,
        xItemSize: size_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief       Insert an item into the ring buffer in an ISR"]
    #[doc = ""]
    #[doc = " Attempt to insert an item into the ring buffer from an ISR. This function"]
    #[doc = " will return immediately if there is insufficient free space in the buffer."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer Ring buffer to insert the item into"]
    #[doc = " @param[in]   pvItem      Pointer to data to insert. NULL is allowed if xItemSize is 0."]
    #[doc = " @param[in]   xItemSize   Size of data to insert."]
    #[doc = " @param[out]  pxHigherPriorityTaskWoken   Value pointed to will be set to pdTRUE if the function woke up a higher priority task."]
    #[doc = ""]
    #[doc = " @note    For no-split/allow-split ring buffers, the actual size of memory that"]
    #[doc = "          the item will occupy will be rounded up to the nearest 32-bit aligned"]
    #[doc = "          size. This is done to ensure all items are always stored in 32-bit"]
    #[doc = "          aligned fashion."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE if succeeded"]
    #[doc = "      - pdFALSE when the ring buffer does not have space."]
    pub fn xRingbufferSendFromISR(
        xRingbuffer: RingbufHandle_t,
        pvItem: *const ::core::ffi::c_void,
        xItemSize: size_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief Acquire memory from the ring buffer to be written to by an external"]
    #[doc = "        source and to be sent later."]
    #[doc = ""]
    #[doc = " Attempt to allocate buffer for an item to be sent into the ring buffer. This"]
    #[doc = " function will block until enough free space is available or until it"]
    #[doc = " timesout."]
    #[doc = ""]
    #[doc = " The item, as well as the following items ``SendAcquire`` or ``Send`` after it,"]
    #[doc = " will not be able to be read from the ring buffer until this item is actually"]
    #[doc = " sent into the ring buffer."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to allocate the memory"]
    #[doc = " @param[out]  ppvItem         Double pointer to memory acquired (set to NULL if no memory were retrieved)"]
    #[doc = " @param[in]   xItemSize       Size of item to acquire."]
    #[doc = " @param[in]   xTicksToWait    Ticks to wait for room in the ring buffer."]
    #[doc = ""]
    #[doc = " @note Only applicable for no-split ring buffers now, the actual size of"]
    #[doc = "       memory that the item will occupy will be rounded up to the nearest 32-bit"]
    #[doc = "       aligned size. This is done to ensure all items are always stored in 32-bit"]
    #[doc = "       aligned fashion."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE if succeeded"]
    #[doc = "      - pdFALSE on time-out or when the data is larger than the maximum permissible size of the buffer"]
    pub fn xRingbufferSendAcquire(
        xRingbuffer: RingbufHandle_t,
        ppvItem: *mut *mut ::core::ffi::c_void,
        xItemSize: size_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief       Actually send an item into the ring buffer allocated before by"]
    #[doc = "              ``xRingbufferSendAcquire``."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to insert the item into"]
    #[doc = " @param[in]   pvItem          Pointer to item in allocated memory to insert."]
    #[doc = ""]
    #[doc = " @note Only applicable for no-split ring buffers. Only call for items"]
    #[doc = "       allocated by ``xRingbufferSendAcquire``."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE if succeeded"]
    #[doc = "      - pdFALSE if fail for some reason."]
    pub fn xRingbufferSendComplete(
        xRingbuffer: RingbufHandle_t,
        pvItem: *mut ::core::ffi::c_void,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Retrieve an item from the ring buffer"]
    #[doc = ""]
    #[doc = " Attempt to retrieve an item from the ring buffer. This function will block"]
    #[doc = " until an item is available or until it times out."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  pxItemSize      Pointer to a variable to which the size of the retrieved item will be written."]
    #[doc = " @param[in]   xTicksToWait    Ticks to wait for items in the ring buffer."]
    #[doc = ""]
    #[doc = " @note    A call to vRingbufferReturnItem() is required after this to free the item retrieved."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - Pointer to the retrieved item on success; *pxItemSize filled with the length of the item."]
    #[doc = "      - NULL on timeout, *pxItemSize is untouched in that case."]
    pub fn xRingbufferReceive(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut size_t,
        xTicksToWait: TickType_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief   Retrieve an item from the ring buffer in an ISR"]
    #[doc = ""]
    #[doc = " Attempt to retrieve an item from the ring buffer. This function returns immediately"]
    #[doc = " if there are no items available for retrieval"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  pxItemSize      Pointer to a variable to which the size of the"]
    #[doc = "                              retrieved item will be written."]
    #[doc = ""]
    #[doc = " @note    A call to vRingbufferReturnItemFromISR() is required after this to free the item retrieved."]
    #[doc = " @note    Byte buffers do not allow multiple retrievals before returning an item"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - Pointer to the retrieved item on success; *pxItemSize filled with the length of the item."]
    #[doc = "      - NULL when the ring buffer is empty, *pxItemSize is untouched in that case."]
    pub fn xRingbufferReceiveFromISR(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief   Retrieve a split item from an allow-split ring buffer"]
    #[doc = ""]
    #[doc = " Attempt to retrieve a split item from an allow-split ring buffer. If the item"]
    #[doc = " is not split, only a single item is retried. If the item is split, both parts"]
    #[doc = " will be retrieved. This function will block until an item is available or"]
    #[doc = " until it times out."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  ppvHeadItem     Double pointer to first part (set to NULL if no items were retrieved)"]
    #[doc = " @param[out]  ppvTailItem     Double pointer to second part (set to NULL if item is not split)"]
    #[doc = " @param[out]  pxHeadItemSize  Pointer to size of first part (unmodified if no items were retrieved)"]
    #[doc = " @param[out]  pxTailItemSize  Pointer to size of second part (unmodified if item is not split)"]
    #[doc = " @param[in]   xTicksToWait    Ticks to wait for items in the ring buffer."]
    #[doc = ""]
    #[doc = " @note    Call(s) to vRingbufferReturnItem() is required after this to free up the item(s) retrieved."]
    #[doc = " @note    This function should only be called on allow-split buffers"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE if an item (split or unsplit) was retrieved"]
    #[doc = "      - pdFALSE when no item was retrieved"]
    pub fn xRingbufferReceiveSplit(
        xRingbuffer: RingbufHandle_t,
        ppvHeadItem: *mut *mut ::core::ffi::c_void,
        ppvTailItem: *mut *mut ::core::ffi::c_void,
        pxHeadItemSize: *mut size_t,
        pxTailItemSize: *mut size_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Retrieve a split item from an allow-split ring buffer in an ISR"]
    #[doc = ""]
    #[doc = " Attempt to retrieve a split item from an allow-split ring buffer. If the item"]
    #[doc = " is not split, only a single item is retried. If the item is split, both parts"]
    #[doc = " will be retrieved. This function returns immediately if there are no items"]
    #[doc = " available for retrieval"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  ppvHeadItem     Double pointer to first part (set to NULL if no items were retrieved)"]
    #[doc = " @param[out]  ppvTailItem     Double pointer to second part (set to NULL if item is not split)"]
    #[doc = " @param[out]  pxHeadItemSize  Pointer to size of first part (unmodified if no items were retrieved)"]
    #[doc = " @param[out]  pxTailItemSize  Pointer to size of second part (unmodified if item is not split)"]
    #[doc = ""]
    #[doc = " @note    Calls to vRingbufferReturnItemFromISR() is required after this to free up the item(s) retrieved."]
    #[doc = " @note    This function should only be called on allow-split buffers"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE if an item (split or unsplit) was retrieved"]
    #[doc = "      - pdFALSE when no item was retrieved"]
    pub fn xRingbufferReceiveSplitFromISR(
        xRingbuffer: RingbufHandle_t,
        ppvHeadItem: *mut *mut ::core::ffi::c_void,
        ppvTailItem: *mut *mut ::core::ffi::c_void,
        pxHeadItemSize: *mut size_t,
        pxTailItemSize: *mut size_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Retrieve bytes from a byte buffer, specifying the maximum amount of bytes to retrieve"]
    #[doc = ""]
    #[doc = " Attempt to retrieve data from a byte buffer whilst specifying a maximum number"]
    #[doc = " of bytes to retrieve. This function will block until there is data available"]
    #[doc = " for retrieval or until it times out."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  pxItemSize      Pointer to a variable to which the size of the retrieved item will be written."]
    #[doc = " @param[in]   xTicksToWait    Ticks to wait for items in the ring buffer."]
    #[doc = " @param[in]   xMaxSize        Maximum number of bytes to return."]
    #[doc = ""]
    #[doc = " @note    A call to vRingbufferReturnItem() is required after this to free up the data retrieved."]
    #[doc = " @note    This function should only be called on byte buffers"]
    #[doc = " @note    Byte buffers do not allow multiple retrievals before returning an item"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - Pointer to the retrieved item on success; *pxItemSize filled with"]
    #[doc = "        the length of the item."]
    #[doc = "      - NULL on timeout, *pxItemSize is untouched in that case."]
    pub fn xRingbufferReceiveUpTo(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut size_t,
        xTicksToWait: TickType_t,
        xMaxSize: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief   Retrieve bytes from a byte buffer, specifying the maximum amount of"]
    #[doc = "          bytes to retrieve. Call this from an ISR."]
    #[doc = ""]
    #[doc = " Attempt to retrieve bytes from a byte buffer whilst specifying a maximum number"]
    #[doc = " of bytes to retrieve. This function will return immediately if there is no data"]
    #[doc = " available for retrieval."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer Ring buffer to retrieve the item from"]
    #[doc = " @param[out]  pxItemSize  Pointer to a variable to which the size of the retrieved item will be written."]
    #[doc = " @param[in]   xMaxSize    Maximum number of bytes to return."]
    #[doc = ""]
    #[doc = " @note    A call to vRingbufferReturnItemFromISR() is required after this to free up the data received."]
    #[doc = " @note    This function should only be called on byte buffers"]
    #[doc = " @note    Byte buffers do not allow multiple retrievals before returning an item"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - Pointer to the retrieved item on success; *pxItemSize filled with"]
    #[doc = "        the length of the item."]
    #[doc = "      - NULL when the ring buffer is empty, *pxItemSize is untouched in that case."]
    pub fn xRingbufferReceiveUpToFromISR(
        xRingbuffer: RingbufHandle_t,
        pxItemSize: *mut size_t,
        xMaxSize: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " @brief   Return a previously-retrieved item to the ring buffer"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer Ring buffer the item was retrieved from"]
    #[doc = " @param[in]   pvItem      Item that was received earlier"]
    #[doc = ""]
    #[doc = " @note    If a split item is retrieved, both parts should be returned by calling this function twice"]
    pub fn vRingbufferReturnItem(xRingbuffer: RingbufHandle_t, pvItem: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief   Return a previously-retrieved item to the ring buffer from an ISR"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer Ring buffer the item was retrieved from"]
    #[doc = " @param[in]   pvItem      Item that was received earlier"]
    #[doc = " @param[out]  pxHigherPriorityTaskWoken   Value pointed to will be set to pdTRUE"]
    #[doc = "                                          if the function woke up a higher priority task."]
    #[doc = ""]
    #[doc = " @note    If a split item is retrieved, both parts should be returned by calling this function twice"]
    pub fn vRingbufferReturnItemFromISR(
        xRingbuffer: RingbufHandle_t,
        pvItem: *mut ::core::ffi::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
extern "C" {
    #[doc = " @brief   Delete a ring buffer"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to delete"]
    #[doc = ""]
    #[doc = " @note    This function will not deallocate any memory if the ring buffer was"]
    #[doc = "          created using xRingbufferCreateStatic(). Deallocation must be done"]
    #[doc = "          manually be the user."]
    pub fn vRingbufferDelete(xRingbuffer: RingbufHandle_t);
}
extern "C" {
    #[doc = " @brief   Get maximum size of an item that can be placed in the ring buffer"]
    #[doc = ""]
    #[doc = " This function returns the maximum size an item can have if it was placed in"]
    #[doc = " an empty ring buffer."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to query"]
    #[doc = ""]
    #[doc = " @note    The max item size for a no-split buffer is limited to"]
    #[doc = "          ((buffer_size/2)-header_size). This limit is imposed so that an item"]
    #[doc = "          of max item size can always be sent to the an empty no-split buffer"]
    #[doc = "          regardless of the internal positions of the buffer's read/write/free"]
    #[doc = "          pointers."]
    #[doc = ""]
    #[doc = " @return  Maximum size, in bytes, of an item that can be placed in a ring buffer."]
    pub fn xRingbufferGetMaxItemSize(xRingbuffer: RingbufHandle_t) -> size_t;
}
extern "C" {
    #[doc = " @brief   Get current free size available for an item/data in the buffer"]
    #[doc = ""]
    #[doc = " This gives the real time free space available for an item/data in the ring"]
    #[doc = " buffer. This represents the maximum size an item/data can have if it was"]
    #[doc = " currently sent to the ring buffer."]
    #[doc = ""]
    #[doc = " @warning This API is not thread safe. So, if multiple threads are accessing"]
    #[doc = "          the same ring buffer, it is the application's responsibility to"]
    #[doc = "          ensure atomic access to this API and the subsequent Send"]
    #[doc = ""]
    #[doc = " @note    An empty no-split buffer has a max current free size for an item"]
    #[doc = "          that is limited to ((buffer_size/2)-header_size). See API reference"]
    #[doc = "          for xRingbufferGetMaxItemSize()."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to query"]
    #[doc = ""]
    #[doc = " @return  Current free size, in bytes, available for an entry"]
    pub fn xRingbufferGetCurFreeSize(xRingbuffer: RingbufHandle_t) -> size_t;
}
extern "C" {
    #[doc = " @brief   Add the ring buffer's read semaphore to a queue set."]
    #[doc = ""]
    #[doc = " The ring buffer's read semaphore indicates that data has been written"]
    #[doc = " to the ring buffer. This function adds the ring buffer's read semaphore to"]
    #[doc = " a queue set."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to add to the queue set"]
    #[doc = " @param[in]   xQueueSet       Queue set to add the ring buffer's read semaphore to"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE on success, pdFALSE otherwise"]
    pub fn xRingbufferAddToQueueSetRead(
        xRingbuffer: RingbufHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Check if the selected queue set member is the ring buffer's read semaphore"]
    #[doc = ""]
    #[doc = " This API checks if queue set member returned from xQueueSelectFromSet()"]
    #[doc = " is the read semaphore of this ring buffer. If so, this indicates the ring buffer"]
    #[doc = " has items waiting to be retrieved."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer which should be checked"]
    #[doc = " @param[in]   xMember         Member returned from xQueueSelectFromSet"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE when semaphore belongs to ring buffer"]
    #[doc = "      - pdFALSE otherwise."]
    pub fn xRingbufferCanRead(
        xRingbuffer: RingbufHandle_t,
        xMember: QueueSetMemberHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Remove the ring buffer's read semaphore from a queue set."]
    #[doc = ""]
    #[doc = " This specifically removes a ring buffer's read semaphore from a queue set. The"]
    #[doc = " read semaphore is used to indicate when data has been written to the ring buffer"]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to remove from the queue set"]
    #[doc = " @param[in]   xQueueSet       Queue set to remove the ring buffer's read semaphore from"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "      - pdTRUE on success"]
    #[doc = "      - pdFALSE otherwise"]
    pub fn xRingbufferRemoveFromQueueSetRead(
        xRingbuffer: RingbufHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " @brief   Get information about ring buffer status"]
    #[doc = ""]
    #[doc = " Get information of the a ring buffer's current status such as"]
    #[doc = " free/read/write pointer positions, and number of items waiting to be retrieved."]
    #[doc = " Arguments can be set to NULL if they are not required."]
    #[doc = ""]
    #[doc = " @param[in]   xRingbuffer     Ring buffer to remove from the queue set"]
    #[doc = " @param[out]  uxFree          Pointer use to store free pointer position"]
    #[doc = " @param[out]  uxRead          Pointer use to store read pointer position"]
    #[doc = " @param[out]  uxWrite         Pointer use to store write pointer position"]
    #[doc = " @param[out]  uxAcquire       Pointer use to store acquire pointer position"]
    #[doc = " @param[out]  uxItemsWaiting  Pointer use to store number of items (bytes for byte buffer) waiting to be retrieved"]
    pub fn vRingbufferGetInfo(
        xRingbuffer: RingbufHandle_t,
        uxFree: *mut UBaseType_t,
        uxRead: *mut UBaseType_t,
        uxWrite: *mut UBaseType_t,
        uxAcquire: *mut UBaseType_t,
        uxItemsWaiting: *mut UBaseType_t,
    );
}
extern "C" {
    #[doc = " @brief   Debugging function to print the internal pointers in the ring buffer"]
    #[doc = ""]
    #[doc = " @param   xRingbuffer Ring buffer to show"]
    pub fn xRingbufferPrintInfo(xRingbuffer: RingbufHandle_t);
}
#[doc = "< mode: regular UART mode"]
pub const uart_mode_t_UART_MODE_UART: uart_mode_t = 0;
#[doc = "< mode: half duplex RS485 UART mode control by RTS pin"]
pub const uart_mode_t_UART_MODE_RS485_HALF_DUPLEX: uart_mode_t = 1;
#[doc = "< mode: IRDA  UART mode"]
pub const uart_mode_t_UART_MODE_IRDA: uart_mode_t = 2;
#[doc = "< mode: RS485 collision detection UART mode (used for test purposes)"]
pub const uart_mode_t_UART_MODE_RS485_COLLISION_DETECT: uart_mode_t = 3;
#[doc = "< mode: application control RS485 UART mode (used for test purposes)"]
pub const uart_mode_t_UART_MODE_RS485_APP_CTRL: uart_mode_t = 4;
#[doc = " @brief UART mode selection"]
pub type uart_mode_t = u32;
#[doc = "< word length: 5bits"]
pub const uart_word_length_t_UART_DATA_5_BITS: uart_word_length_t = 0;
#[doc = "< word length: 6bits"]
pub const uart_word_length_t_UART_DATA_6_BITS: uart_word_length_t = 1;
#[doc = "< word length: 7bits"]
pub const uart_word_length_t_UART_DATA_7_BITS: uart_word_length_t = 2;
#[doc = "< word length: 8bits"]
pub const uart_word_length_t_UART_DATA_8_BITS: uart_word_length_t = 3;
pub const uart_word_length_t_UART_DATA_BITS_MAX: uart_word_length_t = 4;
#[doc = " @brief UART word length constants"]
pub type uart_word_length_t = u32;
#[doc = "< stop bit: 1bit"]
pub const uart_stop_bits_t_UART_STOP_BITS_1: uart_stop_bits_t = 1;
#[doc = "< stop bit: 1.5bits"]
pub const uart_stop_bits_t_UART_STOP_BITS_1_5: uart_stop_bits_t = 2;
#[doc = "< stop bit: 2bits"]
pub const uart_stop_bits_t_UART_STOP_BITS_2: uart_stop_bits_t = 3;
pub const uart_stop_bits_t_UART_STOP_BITS_MAX: uart_stop_bits_t = 4;
#[doc = " @brief UART stop bits number"]
pub type uart_stop_bits_t = u32;
#[doc = "< UART base address 0x3ff40000"]
pub const uart_port_t_UART_NUM_0: uart_port_t = 0;
#[doc = "< UART base address 0x3ff50000"]
pub const uart_port_t_UART_NUM_1: uart_port_t = 1;
#[doc = "< UART base address 0x3ff6e000"]
pub const uart_port_t_UART_NUM_2: uart_port_t = 2;
pub const uart_port_t_UART_NUM_MAX: uart_port_t = 3;
#[doc = " @brief UART peripheral number"]
pub type uart_port_t = u32;
#[doc = "< Disable UART parity"]
pub const uart_parity_t_UART_PARITY_DISABLE: uart_parity_t = 0;
#[doc = "< Enable UART even parity"]
pub const uart_parity_t_UART_PARITY_EVEN: uart_parity_t = 2;
#[doc = "< Enable UART odd parity"]
pub const uart_parity_t_UART_PARITY_ODD: uart_parity_t = 3;
#[doc = " @brief UART parity constants"]
pub type uart_parity_t = u32;
#[doc = "< disable hardware flow control"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_DISABLE: uart_hw_flowcontrol_t = 0;
#[doc = "< enable RX hardware flow control (rts)"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_RTS: uart_hw_flowcontrol_t = 1;
#[doc = "< enable TX hardware flow control (cts)"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_CTS: uart_hw_flowcontrol_t = 2;
#[doc = "< enable hardware flow control"]
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_CTS_RTS: uart_hw_flowcontrol_t = 3;
pub const uart_hw_flowcontrol_t_UART_HW_FLOWCTRL_MAX: uart_hw_flowcontrol_t = 4;
#[doc = " @brief UART hardware flow control modes"]
pub type uart_hw_flowcontrol_t = u32;
#[doc = " @brief UART configuration parameters for uart_param_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_config_t {
    #[doc = "< UART baud rate"]
    pub baud_rate: ::std::os::raw::c_int,
    #[doc = "< UART byte size"]
    pub data_bits: uart_word_length_t,
    #[doc = "< UART parity mode"]
    pub parity: uart_parity_t,
    #[doc = "< UART stop bits"]
    pub stop_bits: uart_stop_bits_t,
    #[doc = "< UART HW flow control mode (cts/rts)"]
    pub flow_ctrl: uart_hw_flowcontrol_t,
    #[doc = "< UART HW RTS threshold"]
    pub rx_flow_ctrl_thresh: u8,
    #[doc = "< Set to true if UART should be clocked from REF_TICK"]
    pub use_ref_tick: bool,
}
#[doc = " @brief UART interrupt configuration parameters for uart_intr_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_intr_config_t {
    #[doc = "< UART interrupt enable mask, choose from UART_XXXX_INT_ENA_M under UART_INT_ENA_REG(i), connect with bit-or operator"]
    pub intr_enable_mask: u32,
    #[doc = "< UART timeout interrupt threshold (unit: time of sending one byte)"]
    pub rx_timeout_thresh: u8,
    #[doc = "< UART TX empty interrupt threshold."]
    pub txfifo_empty_intr_thresh: u8,
    #[doc = "< UART RX full interrupt threshold."]
    pub rxfifo_full_thresh: u8,
}
#[doc = "< UART data event"]
pub const uart_event_type_t_UART_DATA: uart_event_type_t = 0;
#[doc = "< UART break event"]
pub const uart_event_type_t_UART_BREAK: uart_event_type_t = 1;
#[doc = "< UART RX buffer full event"]
pub const uart_event_type_t_UART_BUFFER_FULL: uart_event_type_t = 2;
#[doc = "< UART FIFO overflow event"]
pub const uart_event_type_t_UART_FIFO_OVF: uart_event_type_t = 3;
#[doc = "< UART RX frame error event"]
pub const uart_event_type_t_UART_FRAME_ERR: uart_event_type_t = 4;
#[doc = "< UART RX parity event"]
pub const uart_event_type_t_UART_PARITY_ERR: uart_event_type_t = 5;
#[doc = "< UART TX data and break event"]
pub const uart_event_type_t_UART_DATA_BREAK: uart_event_type_t = 6;
#[doc = "< UART pattern detected"]
pub const uart_event_type_t_UART_PATTERN_DET: uart_event_type_t = 7;
#[doc = "< UART event max index"]
pub const uart_event_type_t_UART_EVENT_MAX: uart_event_type_t = 8;
#[doc = " @brief UART event types used in the ring buffer"]
pub type uart_event_type_t = u32;
#[doc = " @brief Event structure used in UART event queue"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uart_event_t {
    #[doc = "< UART event type"]
    pub type_: uart_event_type_t,
    #[doc = "< UART data size for UART_DATA event"]
    pub size: size_t,
}
pub type uart_isr_handle_t = intr_handle_t;
extern "C" {
    #[doc = " @brief Set UART data bits."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param data_bit UART data bits"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_word_length(uart_num: uart_port_t, data_bit: uart_word_length_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get UART data bits."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param data_bit Pointer to accept value of UART data bits."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL  Parameter error"]
    #[doc = "     - ESP_OK    Success, result will be put in (*data_bit)"]
    pub fn uart_get_word_length(
        uart_num: uart_port_t,
        data_bit: *mut uart_word_length_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART stop bits."]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param stop_bits  UART stop bits"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Fail"]
    pub fn uart_set_stop_bits(uart_num: uart_port_t, stop_bits: uart_stop_bits_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get UART stop bits."]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param stop_bits  Pointer to accept value of UART stop bits."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_OK   Success, result will be put in (*stop_bit)"]
    pub fn uart_get_stop_bits(uart_num: uart_port_t, stop_bits: *mut uart_stop_bits_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART parity mode."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param parity_mode the enum of uart parity configuration"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL  Parameter error"]
    #[doc = "     - ESP_OK    Success"]
    pub fn uart_set_parity(uart_num: uart_port_t, parity_mode: uart_parity_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get UART parity mode."]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param parity_mode Pointer to accept value of UART parity mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL  Parameter error"]
    #[doc = "     - ESP_OK    Success, result will be put in (*parity_mode)"]
    #[doc = ""]
    pub fn uart_get_parity(uart_num: uart_port_t, parity_mode: *mut uart_parity_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART baud rate."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param baudrate UART baud rate."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_OK   Success"]
    pub fn uart_set_baudrate(uart_num: uart_port_t, baudrate: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get UART baud rate."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param baudrate Pointer to accept value of UART baud rate"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_OK   Success, result will be put in (*baudrate)"]
    #[doc = ""]
    pub fn uart_get_baudrate(uart_num: uart_port_t, baudrate: *mut u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART line inverse mode"]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param inverse_mask Choose the wires that need to be inverted."]
    #[doc = "        Inverse_mask should be chosen from"]
    #[doc = "        UART_INVERSE_RXD / UART_INVERSE_TXD / UART_INVERSE_RTS / UART_INVERSE_CTS,"]
    #[doc = "        combined with OR operation."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_line_inverse(uart_num: uart_port_t, inverse_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set hardware flow control."]
    #[doc = ""]
    #[doc = " @param uart_num   UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param flow_ctrl Hardware flow control mode"]
    #[doc = " @param rx_thresh Threshold of Hardware RX flow control (0 ~ UART_FIFO_LEN)."]
    #[doc = "        Only when UART_HW_FLOWCTRL_RTS is set, will the rx_thresh value be set."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_hw_flow_ctrl(
        uart_num: uart_port_t,
        flow_ctrl: uart_hw_flowcontrol_t,
        rx_thresh: u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set software flow control."]
    #[doc = ""]
    #[doc = " @param uart_num   UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param enable     switch on or off"]
    #[doc = " @param rx_thresh_xon  low water mark"]
    #[doc = " @param rx_thresh_xoff high water mark"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_sw_flow_ctrl(
        uart_num: uart_port_t,
        enable: bool,
        rx_thresh_xon: u8,
        rx_thresh_xoff: u8,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get hardware flow control mode"]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param flow_ctrl Option for different flow control mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_OK   Success, result will be put in (*flow_ctrl)"]
    pub fn uart_get_hw_flow_ctrl(
        uart_num: uart_port_t,
        flow_ctrl: *mut uart_hw_flowcontrol_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear UART interrupt status"]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param clr_mask  Bit mask of the interrupt status to be cleared."]
    #[doc = "                  The bit mask should be composed from the fields of register UART_INT_CLR_REG."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_clear_intr_status(uart_num: uart_port_t, clr_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART interrupt enable"]
    #[doc = ""]
    #[doc = " @param uart_num     UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param enable_mask  Bit mask of the enable bits."]
    #[doc = "                     The bit mask should be composed from the fields of register UART_INT_ENA_REG."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_enable_intr_mask(uart_num: uart_port_t, enable_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear UART interrupt enable bits"]
    #[doc = ""]
    #[doc = " @param uart_num      UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param disable_mask  Bit mask of the disable bits."]
    #[doc = "                      The bit mask should be composed from the fields of register UART_INT_ENA_REG."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_disable_intr_mask(uart_num: uart_port_t, disable_mask: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable UART RX interrupt (RX_FULL & RX_TIMEOUT INTERRUPT)"]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_enable_rx_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable UART RX interrupt (RX_FULL & RX_TIMEOUT INTERRUPT)"]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_disable_rx_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable UART TX interrupt (TX_FULL & TX_TIMEOUT INTERRUPT)"]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_disable_tx_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable UART TX interrupt (TX_FULL & TX_TIMEOUT INTERRUPT)"]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param enable  1: enable; 0: disable"]
    #[doc = " @param thresh  Threshold of TX interrupt, 0 ~ UART_FIFO_LEN"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_enable_tx_intr(
        uart_num: uart_port_t,
        enable: ::std::os::raw::c_int,
        thresh: ::std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Register UART interrupt handler (ISR)."]
    #[doc = ""]
    #[doc = " @note UART ISR handler will be attached to the same CPU core that this function is running on."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param fn  Interrupt handler function."]
    #[doc = " @param arg parameter for handler function"]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = " @param handle Pointer to return handle. If non-NULL, a handle for the interrupt will"]
    #[doc = "        be returned here."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_isr_register(
        uart_num: uart_port_t,
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
        intr_alloc_flags: ::std::os::raw::c_int,
        handle: *mut uart_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Free UART interrupt handler registered by uart_isr_register. Must be called on the same core as"]
    #[doc = " uart_isr_register was called."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_isr_free(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART pin number"]
    #[doc = ""]
    #[doc = " @note Internal signal can be output to multiple GPIO pads."]
    #[doc = "       Only one GPIO pad can connect with input signal."]
    #[doc = ""]
    #[doc = " @note Instead of GPIO number a macro 'UART_PIN_NO_CHANGE' may be provided"]
    #[doc = "to keep the currently allocated pin."]
    #[doc = ""]
    #[doc = " @param uart_num   UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param tx_io_num  UART TX pin GPIO number."]
    #[doc = " @param rx_io_num  UART RX pin GPIO number."]
    #[doc = " @param rts_io_num UART RTS pin GPIO number."]
    #[doc = " @param cts_io_num UART CTS pin GPIO number."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_pin(
        uart_num: uart_port_t,
        tx_io_num: ::std::os::raw::c_int,
        rx_io_num: ::std::os::raw::c_int,
        rts_io_num: ::std::os::raw::c_int,
        cts_io_num: ::std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Manually set the UART RTS pin level."]
    #[doc = " @note  UART must be configured with hardware flow control disabled."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param level    1: RTS output low (active); 0: RTS output high (block)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_rts(uart_num: uart_port_t, level: ::std::os::raw::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Manually set the UART DTR pin level."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param level    1: DTR output low; 0: DTR output high"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_dtr(uart_num: uart_port_t, level: ::std::os::raw::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART idle interval after tx FIFO is empty"]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param idle_num idle interval after tx FIFO is empty(unit: the time it takes to send one bit"]
    #[doc = "        under current baudrate)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_set_tx_idle_num(uart_num: uart_port_t, idle_num: u16) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set UART configuration parameters."]
    #[doc = ""]
    #[doc = " @param uart_num    UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param uart_config UART parameter settings"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_param_config(uart_num: uart_port_t, uart_config: *const uart_config_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Configure UART interrupts."]
    #[doc = ""]
    #[doc = " @param uart_num  UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param intr_conf UART interrupt settings"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_intr_config(
        uart_num: uart_port_t,
        intr_conf: *const uart_intr_config_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install UART driver."]
    #[doc = ""]
    #[doc = " UART ISR handler will be attached to the same CPU core that this function is running on."]
    #[doc = ""]
    #[doc = " @note  Rx_buffer_size should be greater than UART_FIFO_LEN. Tx_buffer_size should be either zero or greater than UART_FIFO_LEN."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param rx_buffer_size UART RX ring buffer size."]
    #[doc = " @param tx_buffer_size UART TX ring buffer size."]
    #[doc = "        If set to zero, driver will not use TX buffer, TX function will block task until all data have been sent out."]
    #[doc = " @param queue_size UART event queue size/depth."]
    #[doc = " @param uart_queue UART event queue handle (out param). On success, a new queue handle is written here to provide"]
    #[doc = "        access to UART events. If set to NULL, driver will not use an event queue."]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "        ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info. Do not set ESP_INTR_FLAG_IRAM here"]
    #[doc = "        (the driver's ISR handler is not located in IRAM)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_driver_install(
        uart_num: uart_port_t,
        rx_buffer_size: ::std::os::raw::c_int,
        tx_buffer_size: ::std::os::raw::c_int,
        queue_size: ::std::os::raw::c_int,
        uart_queue: *mut QueueHandle_t,
        intr_alloc_flags: ::std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall UART driver."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_driver_delete(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Wait until UART TX FIFO is empty."]
    #[doc = ""]
    #[doc = " @param uart_num      UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param ticks_to_wait Timeout, count in RTOS ticks"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK   Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_ERR_TIMEOUT  Timeout"]
    pub fn uart_wait_tx_done(uart_num: uart_port_t, ticks_to_wait: TickType_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length."]
    #[doc = ""]
    #[doc = " This function will not wait for enough space in TX FIFO. It will just fill the available TX FIFO and return when the FIFO is full."]
    #[doc = " @note This function should only be used when UART TX buffer is not enabled."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param buffer data buffer address"]
    #[doc = " @param len    data length to send"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1)  Parameter error"]
    #[doc = "     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_tx_chars(
        uart_num: uart_port_t,
        buffer: *const ::std::os::raw::c_char,
        len: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length,"]
    #[doc = ""]
    #[doc = " If the UART driver's parameter 'tx_buffer_size' is set to zero:"]
    #[doc = " This function will not return until all the data have been sent out, or at least pushed into TX FIFO."]
    #[doc = ""]
    #[doc = " Otherwise, if the 'tx_buffer_size' > 0, this function will return after copying all the data to tx ring buffer,"]
    #[doc = " UART ISR will then move data from the ring buffer to TX FIFO gradually."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param src   data buffer address"]
    #[doc = " @param size  data length to send"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1) Parameter error"]
    #[doc = "     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_write_bytes(
        uart_num: uart_port_t,
        src: *const ::std::os::raw::c_char,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Send data to the UART port from a given buffer and length,"]
    #[doc = ""]
    #[doc = " If the UART driver's parameter 'tx_buffer_size' is set to zero:"]
    #[doc = " This function will not return until all the data and the break signal have been sent out."]
    #[doc = " After all data is sent out, send a break signal."]
    #[doc = ""]
    #[doc = " Otherwise, if the 'tx_buffer_size' > 0, this function will return after copying all the data to tx ring buffer,"]
    #[doc = " UART ISR will then move data from the ring buffer to TX FIFO gradually."]
    #[doc = " After all data sent out, send a break signal."]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param src   data buffer address"]
    #[doc = " @param size  data length to send"]
    #[doc = " @param brk_len break signal duration(unit: the time it takes to send one bit at current baudrate)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1) Parameter error"]
    #[doc = "     - OTHERS (>=0) The number of bytes pushed to the TX FIFO"]
    pub fn uart_write_bytes_with_break(
        uart_num: uart_port_t,
        src: *const ::std::os::raw::c_char,
        size: size_t,
        brk_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief UART read bytes from UART buffer"]
    #[doc = ""]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = " @param buf     pointer to the buffer."]
    #[doc = " @param length  data length"]
    #[doc = " @param ticks_to_wait sTimeout, count in RTOS ticks"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - (-1) Error"]
    #[doc = "     - OTHERS (>=0) The number of bytes read from UART FIFO"]
    pub fn uart_read_bytes(
        uart_num: uart_port_t,
        buf: *mut u8,
        length: u32,
        ticks_to_wait: TickType_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Alias of uart_flush_input."]
    #[doc = "        UART ring buffer flush. This will discard all data in the UART RX buffer."]
    #[doc = " @note  Instead of waiting the data sent out, this function will clear UART rx buffer."]
    #[doc = "        In order to send all the data in tx FIFO, we can use uart_wait_tx_done function."]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_flush(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Clear input buffer, discard all the data is in the ring-buffer."]
    #[doc = " @note  In order to send all the data in tx FIFO, we can use uart_wait_tx_done function."]
    #[doc = " @param uart_num UART_NUM_0, UART_NUM_1 or UART_NUM_2"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_flush_input(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   UART get RX ring buffer cached data length"]
    #[doc = ""]
    #[doc = " @param   uart_num UART port number."]
    #[doc = " @param   size Pointer of size_t to accept cached data length"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_get_buffered_data_len(uart_num: uart_port_t, size: *mut size_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   UART disable pattern detect function."]
    #[doc = "          Designed for applications like 'AT commands'."]
    #[doc = "          When the hardware detects a series of one same character, the interrupt will be triggered."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_disable_pattern_det_intr(uart_num: uart_port_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief UART enable pattern detect function."]
    #[doc = "        Designed for applications like 'AT commands'."]
    #[doc = "        When the hardware detect a series of one same character, the interrupt will be triggered."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number."]
    #[doc = " @param pattern_chr character of the pattern"]
    #[doc = " @param chr_num number of the character, 8bit value."]
    #[doc = " @param chr_tout timeout of the interval between each pattern characters, 24bit value, unit is APB (80Mhz) clock cycle."]
    #[doc = "        When the duration is less than this value, it will not take this data as at_cmd char"]
    #[doc = " @param post_idle idle time after the last pattern character, 24bit value, unit is APB (80Mhz) clock cycle."]
    #[doc = "        When the duration is less than this value, it will not take the previous data as the last at_cmd char"]
    #[doc = " @param pre_idle idle time before the first pattern character, 24bit value, unit is APB (80Mhz) clock cycle."]
    #[doc = "        When the duration is less than this value, it will not take this data as the first at_cmd char"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_FAIL Parameter error"]
    pub fn uart_enable_pattern_det_intr(
        uart_num: uart_port_t,
        pattern_chr: ::std::os::raw::c_char,
        chr_num: u8,
        chr_tout: ::std::os::raw::c_int,
        post_idle: ::std::os::raw::c_int,
        pre_idle: ::std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Return the nearest detected pattern position in buffer."]
    #[doc = "        The positions of the detected pattern are saved in a queue,"]
    #[doc = "        this function will dequeue the first pattern position and move the pointer to next pattern position."]
    #[doc = " @note  If the RX buffer is full and flow control is not enabled,"]
    #[doc = "        the detected pattern may not be found in the rx buffer due to overflow."]
    #[doc = ""]
    #[doc = "        The following APIs will modify the pattern position info:"]
    #[doc = "        uart_flush_input, uart_read_bytes, uart_driver_delete, uart_pop_pattern_pos"]
    #[doc = "        It is the application's responsibility to ensure atomic access to the pattern queue and the rx data buffer"]
    #[doc = "        when using pattern detect feature."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number"]
    #[doc = " @return"]
    #[doc = "     - (-1) No pattern found for current index or parameter error"]
    #[doc = "     - others the pattern position in rx buffer."]
    pub fn uart_pattern_pop_pos(uart_num: uart_port_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return the nearest detected pattern position in buffer."]
    #[doc = "        The positions of the detected pattern are saved in a queue,"]
    #[doc = "        This function do nothing to the queue."]
    #[doc = " @note  If the RX buffer is full and flow control is not enabled,"]
    #[doc = "        the detected pattern may not be found in the rx buffer due to overflow."]
    #[doc = ""]
    #[doc = "        The following APIs will modify the pattern position info:"]
    #[doc = "        uart_flush_input, uart_read_bytes, uart_driver_delete, uart_pop_pattern_pos"]
    #[doc = "        It is the application's responsibility to ensure atomic access to the pattern queue and the rx data buffer"]
    #[doc = "        when using pattern detect feature."]
    #[doc = ""]
    #[doc = " @param uart_num UART port number"]
    #[doc = " @return"]
    #[doc = "     - (-1) No pattern found for current index or parameter error"]
    #[doc = "     - others the pattern position in rx buffer."]
    pub fn uart_pattern_get_pos(uart_num: uart_port_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Allocate a new memory with the given length to save record the detected pattern position in rx buffer."]
    #[doc = " @param uart_num UART port number"]
    #[doc = " @param queue_length Max queue length for the detected pattern."]
    #[doc = "        If the queue length is not large enough, some pattern positions might be lost."]
    #[doc = "        Set this value to the maximum number of patterns that could be saved in data buffer at the same time."]
    #[doc = " @return"]
    #[doc = "     - ESP_ERR_NO_MEM No enough memory"]
    #[doc = "     - ESP_ERR_INVALID_STATE Driver not installed"]
    #[doc = "     - ESP_FAIL Parameter error"]
    #[doc = "     - ESP_OK Success"]
    pub fn uart_pattern_queue_reset(
        uart_num: uart_port_t,
        queue_length: ::std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief UART set communication mode"]
    #[doc = " @note  This function must be executed after uart_driver_install(), when the driver object is initialized."]
    #[doc = " @param uart_num     Uart number to configure"]
    #[doc = " @param mode UART    UART mode to set"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_set_mode(uart_num: uart_port_t, mode: uart_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief UART set threshold timeout for TOUT feature"]
    #[doc = ""]
    #[doc = " @param uart_num     Uart number to configure"]
    #[doc = " @param tout_thresh  This parameter defines timeout threshold in uart symbol periods. The maximum value of threshold is 126."]
    #[doc = "        tout_thresh = 1, defines TOUT interrupt timeout equal to transmission time of one symbol (~11 bit) on current baudrate."]
    #[doc = "        If the time is expired the UART_RXFIFO_TOUT_INT interrupt is triggered. If tout_thresh == 0,"]
    #[doc = "        the TOUT feature is disabled."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = "     - ESP_ERR_INVALID_STATE Driver is not installed"]
    pub fn uart_set_rx_timeout(uart_num: uart_port_t, tout_thresh: u8) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Returns collision detection flag for RS485 mode"]
    #[doc = "        Function returns the collision detection flag into variable pointed by collision_flag."]
    #[doc = "        *collision_flag = true, if collision detected else it is equal to false."]
    #[doc = "        This function should be executed when actual transmission is completed (after uart_write_bytes())."]
    #[doc = ""]
    #[doc = " @param uart_num       Uart number to configure"]
    #[doc = " @param collision_flag Pointer to variable of type bool to return collision flag."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn uart_get_collision_flag(uart_num: uart_port_t, collision_flag: *mut bool) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set the number of RX pin signal edges for light sleep wakeup"]
    #[doc = ""]
    #[doc = " UART can be used to wake up the system from light sleep. This feature works"]
    #[doc = " by counting the number of positive edges on RX pin and comparing the count to"]
    #[doc = " the threshold. When the count exceeds the threshold, system is woken up from"]
    #[doc = " light sleep. This function allows setting the threshold value."]
    #[doc = ""]
    #[doc = " Stop bit and parity bits (if enabled) also contribute to the number of edges."]
    #[doc = " For example, letter 'a' with ASCII code 97 is encoded as 0100001101 on the wire"]
    #[doc = " (with 8n1 configuration), start and stop bits included. This sequence has 3"]
    #[doc = " positive edges (transitions from 0 to 1). Therefore, to wake up the system"]
    #[doc = " when 'a' is sent, set wakeup_threshold=3."]
    #[doc = ""]
    #[doc = " The character that triggers wakeup is not received by UART (i.e. it can not"]
    #[doc = " be obtained from UART FIFO). Depending on the baud rate, a few characters"]
    #[doc = " after that will also not be received. Note that when the chip enters and exits"]
    #[doc = " light sleep mode, APB frequency will be changing. To make sure that UART has"]
    #[doc = " correct baud rate all the time, select REF_TICK as UART clock source,"]
    #[doc = " by setting use_ref_tick field in uart_config_t to true."]
    #[doc = ""]
    #[doc = " @note in ESP32, the wakeup signal can only be input via IO_MUX (i.e."]
    #[doc = "       GPIO3 should be configured as function_1 to wake up UART0,"]
    #[doc = "       GPIO9 should be configured as function_5 to wake up UART1), UART2"]
    #[doc = "       does not support light sleep wakeup feature."]
    #[doc = ""]
    #[doc = " @param uart_num  UART number"]
    #[doc = " @param wakeup_threshold  number of RX edges for light sleep wakeup, value is 3 .. 0x3ff."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if uart_num is incorrect or wakeup_threshold is"]
    #[doc = "        outside of [3, 0x3ff] range."]
    pub fn uart_set_wakeup_threshold(
        uart_num: uart_port_t,
        wakeup_threshold: ::std::os::raw::c_int,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get the number of RX pin signal edges for light sleep wakeup."]
    #[doc = ""]
    #[doc = " See description of uart_set_wakeup_threshold for the explanation of UART"]
    #[doc = " wakeup feature."]
    #[doc = ""]
    #[doc = " @param uart_num  UART number"]
    #[doc = " @param[out] out_wakeup_threshold  output, set to the current value of wakeup"]
    #[doc = "                                   threshold for the given UART."]
    #[doc = " @return"]
    #[doc = "      - ESP_OK on success"]
    #[doc = "      - ESP_ERR_INVALID_ARG if out_wakeup_threshold is NULL"]
    pub fn uart_get_wakeup_threshold(
        uart_num: uart_port_t,
        out_wakeup_threshold: *mut ::std::os::raw::c_int,
    ) -> esp_err_t;
}
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_DISABLE: GPIO_INT_TYPE = 0;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_POSEDGE: GPIO_INT_TYPE = 1;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_NEGEDGE: GPIO_INT_TYPE = 2;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_ANYEDGE: GPIO_INT_TYPE = 3;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_LOLEVEL: GPIO_INT_TYPE = 4;
pub const GPIO_INT_TYPE_GPIO_PIN_INTR_HILEVEL: GPIO_INT_TYPE = 5;
pub type GPIO_INT_TYPE = u32;
pub type gpio_intr_handler_fn_t = ::core::option::Option<
    unsafe extern "C" fn(intr_mask: u32, high: bool, arg: *mut ::core::ffi::c_void),
>;
extern "C" {
    #[doc = " @brief Initialize GPIO. This includes reading the GPIO Configuration DataSet"]
    #[doc = "        to initialize \"output enables\" and pin configurations for each gpio pin."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param  None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_init();
}
extern "C" {
    #[doc = " @brief Change GPIO(0-31) pin output by setting, clearing, or disabling pins, GPIO0<->BIT(0)."]
    #[doc = "         There is no particular ordering guaranteed; so if the order of writes is significant,"]
    #[doc = "         calling code should divide a single call into multiple calls."]
    #[doc = ""]
    #[doc = " @param  uint32_t set_mask : the gpios that need high level."]
    #[doc = ""]
    #[doc = " @param  uint32_t clear_mask : the gpios that need low level."]
    #[doc = ""]
    #[doc = " @param  uint32_t enable_mask : the gpios that need be changed."]
    #[doc = ""]
    #[doc = " @param  uint32_t disable_mask : the gpios that need diable output."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_output_set(set_mask: u32, clear_mask: u32, enable_mask: u32, disable_mask: u32);
}
extern "C" {
    #[doc = " @brief Change GPIO(32-39) pin output by setting, clearing, or disabling pins, GPIO32<->BIT(0)."]
    #[doc = "         There is no particular ordering guaranteed; so if the order of writes is significant,"]
    #[doc = "         calling code should divide a single call into multiple calls."]
    #[doc = ""]
    #[doc = " @param  uint32_t set_mask : the gpios that need high level."]
    #[doc = ""]
    #[doc = " @param  uint32_t clear_mask : the gpios that need low level."]
    #[doc = ""]
    #[doc = " @param  uint32_t enable_mask : the gpios that need be changed."]
    #[doc = ""]
    #[doc = " @param  uint32_t disable_mask : the gpios that need diable output."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_output_set_high(
        set_mask: u32,
        clear_mask: u32,
        enable_mask: u32,
        disable_mask: u32,
    );
}
extern "C" {
    #[doc = " @brief Sample the value of GPIO input pins(0-31) and returns a bitmask."]
    #[doc = ""]
    #[doc = " @param None"]
    #[doc = ""]
    #[doc = " @return uint32_t : bitmask for GPIO input pins, BIT(0) for GPIO0."]
    pub fn gpio_input_get() -> u32;
}
extern "C" {
    #[doc = " @brief Sample the value of GPIO input pins(32-39) and returns a bitmask."]
    #[doc = ""]
    #[doc = " @param None"]
    #[doc = ""]
    #[doc = " @return uint32_t : bitmask for GPIO input pins, BIT(0) for GPIO32."]
    pub fn gpio_input_get_high() -> u32;
}
extern "C" {
    #[doc = " @brief Register an application-specific interrupt handler for GPIO pin interrupts."]
    #[doc = "        Once the interrupt handler is called, it will not be called again until after a call to gpio_intr_ack."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param gpio_intr_handler_fn_t fn : gpio application-specific interrupt handler"]
    #[doc = ""]
    #[doc = " @param void *arg : gpio application-specific interrupt handler argument."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_intr_handler_register(fn_: gpio_intr_handler_fn_t, arg: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " @brief Get gpio interrupts which happens but not processed."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param None"]
    #[doc = ""]
    #[doc = " @return uint32_t : bitmask for GPIO pending interrupts, BIT(0) for GPIO0."]
    pub fn gpio_intr_pending() -> u32;
}
extern "C" {
    #[doc = " @brief Get gpio interrupts which happens but not processed."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param None"]
    #[doc = ""]
    #[doc = " @return uint32_t : bitmask for GPIO pending interrupts, BIT(0) for GPIO32."]
    pub fn gpio_intr_pending_high() -> u32;
}
extern "C" {
    #[doc = " @brief Ack gpio interrupts to process pending interrupts."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param uint32_t ack_mask: bitmask for GPIO ack interrupts, BIT(0) for GPIO0."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_intr_ack(ack_mask: u32);
}
extern "C" {
    #[doc = " @brief Ack gpio interrupts to process pending interrupts."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param uint32_t ack_mask: bitmask for GPIO ack interrupts, BIT(0) for GPIO32."]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_intr_ack_high(ack_mask: u32);
}
extern "C" {
    #[doc = " @brief Set GPIO to wakeup the ESP32."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param uint32_t i: gpio number."]
    #[doc = ""]
    #[doc = " @param GPIO_INT_TYPE intr_state : only GPIO_PIN_INTR_LOLEVEL\\GPIO_PIN_INTR_HILEVEL can be used"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pin_wakeup_enable(i: u32, intr_state: GPIO_INT_TYPE);
}
extern "C" {
    #[doc = " @brief disable GPIOs to wakeup the ESP32."]
    #[doc = "        Please do not call this function in SDK."]
    #[doc = ""]
    #[doc = " @param None"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pin_wakeup_disable();
}
extern "C" {
    #[doc = " @brief set gpio input to a signal, one gpio can input to several signals."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio : gpio number, 0~0x27"]
    #[doc = "                        gpio == 0x30, input 0 to signal"]
    #[doc = "                        gpio == 0x34, ???"]
    #[doc = "                        gpio == 0x38, input 1 to signal"]
    #[doc = ""]
    #[doc = " @param uint32_t signal_idx : signal index."]
    #[doc = ""]
    #[doc = " @param bool inv : the signal is inv or not"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_matrix_in(gpio: u32, signal_idx: u32, inv: bool);
}
extern "C" {
    #[doc = " @brief set signal output to gpio, one signal can output to several gpios."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @param uint32_t signal_idx : signal index."]
    #[doc = "                        signal_idx == 0x100, cancel output put to the gpio"]
    #[doc = ""]
    #[doc = " @param bool out_inv : the signal output is inv or not"]
    #[doc = ""]
    #[doc = " @param bool oen_inv : the signal output enable is inv or not"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_matrix_out(gpio: u32, signal_idx: u32, out_inv: bool, oen_inv: bool);
}
extern "C" {
    #[doc = " @brief Select pad as a gpio function from IOMUX."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_select_gpio(gpio_num: u8);
}
extern "C" {
    #[doc = " @brief Set pad driver capability."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @param uint8_t drv : 0-3"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_set_drv(gpio_num: u8, drv: u8);
}
extern "C" {
    #[doc = " @brief Pull up the pad from gpio number."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_pullup(gpio_num: u8);
}
extern "C" {
    #[doc = " @brief Pull down the pad from gpio number."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_pulldown(gpio_num: u8);
}
extern "C" {
    #[doc = " @brief Unhold the pad from gpio number."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_unhold(gpio_num: u8);
}
extern "C" {
    #[doc = " @brief Hold the pad from gpio number."]
    #[doc = ""]
    #[doc = " @param uint32_t gpio_num : gpio number, 0~0x27"]
    #[doc = ""]
    #[doc = " @return None"]
    pub fn gpio_pad_hold(gpio_num: u8);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_dev_s {
    pub bt_select: u32,
    pub out: u32,
    pub out_w1ts: u32,
    pub out_w1tc: u32,
    pub out1: gpio_dev_s__bindgen_ty_1,
    pub out1_w1ts: gpio_dev_s__bindgen_ty_2,
    pub out1_w1tc: gpio_dev_s__bindgen_ty_3,
    pub sdio_select: gpio_dev_s__bindgen_ty_4,
    pub enable: u32,
    pub enable_w1ts: u32,
    pub enable_w1tc: u32,
    pub enable1: gpio_dev_s__bindgen_ty_5,
    pub enable1_w1ts: gpio_dev_s__bindgen_ty_6,
    pub enable1_w1tc: gpio_dev_s__bindgen_ty_7,
    pub strap: gpio_dev_s__bindgen_ty_8,
    pub in_: u32,
    pub in1: gpio_dev_s__bindgen_ty_9,
    pub status: u32,
    pub status_w1ts: u32,
    pub status_w1tc: u32,
    pub status1: gpio_dev_s__bindgen_ty_10,
    pub status1_w1ts: gpio_dev_s__bindgen_ty_11,
    pub status1_w1tc: gpio_dev_s__bindgen_ty_12,
    pub reserved_5c: u32,
    pub acpu_int: u32,
    pub acpu_nmi_int: u32,
    pub pcpu_int: u32,
    pub pcpu_nmi_int: u32,
    pub cpusdio_int: u32,
    pub acpu_int1: gpio_dev_s__bindgen_ty_13,
    pub acpu_nmi_int1: gpio_dev_s__bindgen_ty_14,
    pub pcpu_int1: gpio_dev_s__bindgen_ty_15,
    pub pcpu_nmi_int1: gpio_dev_s__bindgen_ty_16,
    pub cpusdio_int1: gpio_dev_s__bindgen_ty_17,
    pub pin: [gpio_dev_s__bindgen_ty_18; 40usize],
    pub cali_conf: gpio_dev_s__bindgen_ty_19,
    pub cali_data: gpio_dev_s__bindgen_ty_20,
    pub func_in_sel_cfg: [gpio_dev_s__bindgen_ty_21; 256usize],
    pub func_out_sel_cfg: [gpio_dev_s__bindgen_ty_22; 40usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_1 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_1__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_2 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_2__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_3 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_3__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_4 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_4__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(sel: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let sel: u32 = unsafe { ::core::mem::transmute(sel) };
            sel as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_5 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_5__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_6 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_6__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_7 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_7__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_8 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_8__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_8__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl gpio_dev_s__bindgen_ty_8__bindgen_ty_1 {
    #[inline]
    pub fn strapping(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_strapping(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved16(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved16(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        strapping: u32,
        reserved16: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let strapping: u32 = unsafe { ::core::mem::transmute(strapping) };
            strapping as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved16: u32 = unsafe { ::core::mem::transmute(reserved16) };
            reserved16 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_9 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_9__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn data(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(data: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_10 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_10__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn intr_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intr_st: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr_st: u32 = unsafe { ::core::mem::transmute(intr_st) };
            intr_st as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_11 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_11__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn intr_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intr_st: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr_st: u32 = unsafe { ::core::mem::transmute(intr_st) };
            intr_st as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_12 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_12__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn intr_st(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr_st(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intr_st: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr_st: u32 = unsafe { ::core::mem::transmute(intr_st) };
            intr_st as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_13 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_13__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_13__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_13__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_14 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_14__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_14__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_14__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_15 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_15__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_15__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_15__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_16 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_16__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_16__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_16__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_17 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_17__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_17__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_17__bindgen_ty_1 {
    #[inline]
    pub fn intr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_intr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(intr: u32, reserved8: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let intr: u32 = unsafe { ::core::mem::transmute(intr) };
            intr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_18 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_18__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_18__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl gpio_dev_s__bindgen_ty_18__bindgen_ty_1 {
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pad_driver(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pad_driver(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn int_type(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_int_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn wakeup_enable(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wakeup_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn config(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_config(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn int_ena(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_int_ena(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved18(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved18(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved0: u32,
        pad_driver: u32,
        reserved3: u32,
        int_type: u32,
        wakeup_enable: u32,
        config: u32,
        int_ena: u32,
        reserved18: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let reserved0: u32 = unsafe { ::core::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pad_driver: u32 = unsafe { ::core::mem::transmute(pad_driver) };
            pad_driver as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let reserved3: u32 = unsafe { ::core::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let int_type: u32 = unsafe { ::core::mem::transmute(int_type) };
            int_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wakeup_enable: u32 = unsafe { ::core::mem::transmute(wakeup_enable) };
            wakeup_enable as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let config: u32 = unsafe { ::core::mem::transmute(config) };
            config as u64
        });
        __bindgen_bitfield_unit.set(13usize, 5u8, {
            let int_ena: u32 = unsafe { ::core::mem::transmute(int_ena) };
            int_ena as u64
        });
        __bindgen_bitfield_unit.set(18usize, 14u8, {
            let reserved18: u32 = unsafe { ::core::mem::transmute(reserved18) };
            reserved18 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_19 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_19__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_19__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_19__bindgen_ty_1 {
    #[inline]
    pub fn rtc_max(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_rtc_max(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn start(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_start(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rtc_max: u32,
        reserved10: u32,
        start: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let rtc_max: u32 = unsafe { ::core::mem::transmute(rtc_max) };
            rtc_max as u64
        });
        __bindgen_bitfield_unit.set(10usize, 21u8, {
            let reserved10: u32 = unsafe { ::core::mem::transmute(reserved10) };
            reserved10 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let start: u32 = unsafe { ::core::mem::transmute(start) };
            start as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_20 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_20__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_20__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_20__bindgen_ty_1 {
    #[inline]
    pub fn value_sync2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_value_sync2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved20(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved20(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn rdy_real(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdy_real(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rdy_sync2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdy_sync2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        value_sync2: u32,
        reserved20: u32,
        rdy_real: u32,
        rdy_sync2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let value_sync2: u32 = unsafe { ::core::mem::transmute(value_sync2) };
            value_sync2 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 10u8, {
            let reserved20: u32 = unsafe { ::core::mem::transmute(reserved20) };
            reserved20 as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rdy_real: u32 = unsafe { ::core::mem::transmute(rdy_real) };
            rdy_real as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let rdy_sync2: u32 = unsafe { ::core::mem::transmute(rdy_sync2) };
            rdy_sync2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_21 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_21__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_21__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_21__bindgen_ty_1 {
    #[inline]
    pub fn func_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_func_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_in_inv(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_in_inv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sig_in_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sig_in_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        func_sel: u32,
        sig_in_inv: u32,
        sig_in_sel: u32,
        reserved8: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let func_sel: u32 = unsafe { ::core::mem::transmute(func_sel) };
            func_sel as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let sig_in_inv: u32 = unsafe { ::core::mem::transmute(sig_in_inv) };
            sig_in_inv as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sig_in_sel: u32 = unsafe { ::core::mem::transmute(sig_in_sel) };
            sig_in_sel as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved8: u32 = unsafe { ::core::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_dev_s__bindgen_ty_22 {
    pub __bindgen_anon_1: gpio_dev_s__bindgen_ty_22__bindgen_ty_1,
    pub val: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct gpio_dev_s__bindgen_ty_22__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl gpio_dev_s__bindgen_ty_22__bindgen_ty_1 {
    #[inline]
    pub fn func_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_func_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn inv_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inv_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oen_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oen_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oen_inv_sel(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oen_inv_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        func_sel: u32,
        inv_sel: u32,
        oen_sel: u32,
        oen_inv_sel: u32,
        reserved12: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let func_sel: u32 = unsafe { ::core::mem::transmute(func_sel) };
            func_sel as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let inv_sel: u32 = unsafe { ::core::mem::transmute(inv_sel) };
            inv_sel as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let oen_sel: u32 = unsafe { ::core::mem::transmute(oen_sel) };
            oen_sel as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let oen_inv_sel: u32 = unsafe { ::core::mem::transmute(oen_inv_sel) };
            oen_inv_sel as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let reserved12: u32 = unsafe { ::core::mem::transmute(reserved12) };
            reserved12 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpio_dev_t = gpio_dev_s;
extern "C" {
    pub static mut GPIO: gpio_dev_t;
}
extern "C" {
    pub static GPIO_PIN_MUX_REG: [u32; 40usize];
}
#[doc = "< Use to signal not connected to S/W"]
pub const gpio_num_t_GPIO_NUM_NC: gpio_num_t = -1;
#[doc = "< GPIO0, input and output"]
pub const gpio_num_t_GPIO_NUM_0: gpio_num_t = 0;
#[doc = "< GPIO1, input and output"]
pub const gpio_num_t_GPIO_NUM_1: gpio_num_t = 1;
#[doc = "< GPIO2, input and output"]
#[doc = "@note There are more enumerations like that"]
#[doc = "up to GPIO39, excluding GPIO20, GPIO24 and GPIO28..31."]
#[doc = "They are not shown here to reduce redundant information."]
#[doc = "@note GPIO34..39 are input mode only."]
pub const gpio_num_t_GPIO_NUM_2: gpio_num_t = 2;
#[doc = "< GPIO3, input and output"]
pub const gpio_num_t_GPIO_NUM_3: gpio_num_t = 3;
#[doc = "< GPIO4, input and output"]
pub const gpio_num_t_GPIO_NUM_4: gpio_num_t = 4;
#[doc = "< GPIO5, input and output"]
pub const gpio_num_t_GPIO_NUM_5: gpio_num_t = 5;
#[doc = "< GPIO6, input and output"]
pub const gpio_num_t_GPIO_NUM_6: gpio_num_t = 6;
#[doc = "< GPIO7, input and output"]
pub const gpio_num_t_GPIO_NUM_7: gpio_num_t = 7;
#[doc = "< GPIO8, input and output"]
pub const gpio_num_t_GPIO_NUM_8: gpio_num_t = 8;
#[doc = "< GPIO9, input and output"]
pub const gpio_num_t_GPIO_NUM_9: gpio_num_t = 9;
#[doc = "< GPIO10, input and output"]
pub const gpio_num_t_GPIO_NUM_10: gpio_num_t = 10;
#[doc = "< GPIO11, input and output"]
pub const gpio_num_t_GPIO_NUM_11: gpio_num_t = 11;
#[doc = "< GPIO12, input and output"]
pub const gpio_num_t_GPIO_NUM_12: gpio_num_t = 12;
#[doc = "< GPIO13, input and output"]
pub const gpio_num_t_GPIO_NUM_13: gpio_num_t = 13;
#[doc = "< GPIO14, input and output"]
pub const gpio_num_t_GPIO_NUM_14: gpio_num_t = 14;
#[doc = "< GPIO15, input and output"]
pub const gpio_num_t_GPIO_NUM_15: gpio_num_t = 15;
#[doc = "< GPIO16, input and output"]
pub const gpio_num_t_GPIO_NUM_16: gpio_num_t = 16;
#[doc = "< GPIO17, input and output"]
pub const gpio_num_t_GPIO_NUM_17: gpio_num_t = 17;
#[doc = "< GPIO18, input and output"]
pub const gpio_num_t_GPIO_NUM_18: gpio_num_t = 18;
#[doc = "< GPIO19, input and output"]
pub const gpio_num_t_GPIO_NUM_19: gpio_num_t = 19;
#[doc = "< GPIO21, input and output"]
pub const gpio_num_t_GPIO_NUM_21: gpio_num_t = 21;
#[doc = "< GPIO22, input and output"]
pub const gpio_num_t_GPIO_NUM_22: gpio_num_t = 22;
#[doc = "< GPIO23, input and output"]
pub const gpio_num_t_GPIO_NUM_23: gpio_num_t = 23;
#[doc = "< GPIO25, input and output"]
pub const gpio_num_t_GPIO_NUM_25: gpio_num_t = 25;
#[doc = "< GPIO26, input and output"]
pub const gpio_num_t_GPIO_NUM_26: gpio_num_t = 26;
#[doc = "< GPIO27, input and output"]
pub const gpio_num_t_GPIO_NUM_27: gpio_num_t = 27;
#[doc = "< GPIO32, input and output"]
pub const gpio_num_t_GPIO_NUM_32: gpio_num_t = 32;
#[doc = "< GPIO33, input and output"]
pub const gpio_num_t_GPIO_NUM_33: gpio_num_t = 33;
#[doc = "< GPIO34, input mode only"]
pub const gpio_num_t_GPIO_NUM_34: gpio_num_t = 34;
#[doc = "< GPIO35, input mode only"]
pub const gpio_num_t_GPIO_NUM_35: gpio_num_t = 35;
#[doc = "< GPIO36, input mode only"]
pub const gpio_num_t_GPIO_NUM_36: gpio_num_t = 36;
#[doc = "< GPIO37, input mode only"]
pub const gpio_num_t_GPIO_NUM_37: gpio_num_t = 37;
#[doc = "< GPIO38, input mode only"]
pub const gpio_num_t_GPIO_NUM_38: gpio_num_t = 38;
#[doc = "< GPIO39, input mode only"]
pub const gpio_num_t_GPIO_NUM_39: gpio_num_t = 39;
pub const gpio_num_t_GPIO_NUM_MAX: gpio_num_t = 40;
pub type gpio_num_t = i32;
#[doc = "< Disable GPIO interrupt"]
pub const gpio_int_type_t_GPIO_INTR_DISABLE: gpio_int_type_t = 0;
#[doc = "< GPIO interrupt type : rising edge"]
pub const gpio_int_type_t_GPIO_INTR_POSEDGE: gpio_int_type_t = 1;
#[doc = "< GPIO interrupt type : falling edge"]
pub const gpio_int_type_t_GPIO_INTR_NEGEDGE: gpio_int_type_t = 2;
#[doc = "< GPIO interrupt type : both rising and falling edge"]
pub const gpio_int_type_t_GPIO_INTR_ANYEDGE: gpio_int_type_t = 3;
#[doc = "< GPIO interrupt type : input low level trigger"]
pub const gpio_int_type_t_GPIO_INTR_LOW_LEVEL: gpio_int_type_t = 4;
#[doc = "< GPIO interrupt type : input high level trigger"]
pub const gpio_int_type_t_GPIO_INTR_HIGH_LEVEL: gpio_int_type_t = 5;
pub const gpio_int_type_t_GPIO_INTR_MAX: gpio_int_type_t = 6;
pub type gpio_int_type_t = u32;
#[doc = "< GPIO mode : disable input and output"]
pub const gpio_mode_t_GPIO_MODE_DISABLE: gpio_mode_t = 0;
#[doc = "< GPIO mode : input only"]
pub const gpio_mode_t_GPIO_MODE_INPUT: gpio_mode_t = 1;
#[doc = "< GPIO mode : output only mode"]
pub const gpio_mode_t_GPIO_MODE_OUTPUT: gpio_mode_t = 2;
#[doc = "< GPIO mode : output only with open-drain mode"]
pub const gpio_mode_t_GPIO_MODE_OUTPUT_OD: gpio_mode_t = 6;
#[doc = "< GPIO mode : output and input with open-drain mode"]
pub const gpio_mode_t_GPIO_MODE_INPUT_OUTPUT_OD: gpio_mode_t = 7;
#[doc = "< GPIO mode : output and input mode"]
pub const gpio_mode_t_GPIO_MODE_INPUT_OUTPUT: gpio_mode_t = 3;
pub type gpio_mode_t = u32;
#[doc = "< Disable GPIO pull-up resistor"]
pub const gpio_pullup_t_GPIO_PULLUP_DISABLE: gpio_pullup_t = 0;
#[doc = "< Enable GPIO pull-up resistor"]
pub const gpio_pullup_t_GPIO_PULLUP_ENABLE: gpio_pullup_t = 1;
pub type gpio_pullup_t = u32;
#[doc = "< Disable GPIO pull-down resistor"]
pub const gpio_pulldown_t_GPIO_PULLDOWN_DISABLE: gpio_pulldown_t = 0;
#[doc = "< Enable GPIO pull-down resistor"]
pub const gpio_pulldown_t_GPIO_PULLDOWN_ENABLE: gpio_pulldown_t = 1;
pub type gpio_pulldown_t = u32;
#[doc = " @brief Configuration parameters of GPIO pad for gpio_config function"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpio_config_t {
    #[doc = "< GPIO pin: set with bit mask, each bit maps to a GPIO"]
    pub pin_bit_mask: u64,
    #[doc = "< GPIO mode: set input/output mode"]
    pub mode: gpio_mode_t,
    #[doc = "< GPIO pull-up"]
    pub pull_up_en: gpio_pullup_t,
    #[doc = "< GPIO pull-down"]
    pub pull_down_en: gpio_pulldown_t,
    #[doc = "< GPIO interrupt type"]
    pub intr_type: gpio_int_type_t,
}
#[doc = "< Pad pull up"]
pub const gpio_pull_mode_t_GPIO_PULLUP_ONLY: gpio_pull_mode_t = 0;
#[doc = "< Pad pull down"]
pub const gpio_pull_mode_t_GPIO_PULLDOWN_ONLY: gpio_pull_mode_t = 1;
#[doc = "< Pad pull up + pull down"]
pub const gpio_pull_mode_t_GPIO_PULLUP_PULLDOWN: gpio_pull_mode_t = 2;
#[doc = "< Pad floating"]
pub const gpio_pull_mode_t_GPIO_FLOATING: gpio_pull_mode_t = 3;
pub type gpio_pull_mode_t = u32;
#[doc = "< Pad drive capability: weak"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_0: gpio_drive_cap_t = 0;
#[doc = "< Pad drive capability: stronger"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_1: gpio_drive_cap_t = 1;
#[doc = "< Pad drive capability: default value"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_2: gpio_drive_cap_t = 2;
#[doc = "< Pad drive capability: default value"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_DEFAULT: gpio_drive_cap_t = 2;
#[doc = "< Pad drive capability: strongest"]
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_3: gpio_drive_cap_t = 3;
pub const gpio_drive_cap_t_GPIO_DRIVE_CAP_MAX: gpio_drive_cap_t = 4;
pub type gpio_drive_cap_t = u32;
pub type gpio_isr_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>;
pub type gpio_isr_handle_t = intr_handle_t;
extern "C" {
    #[doc = " @brief GPIO common configuration"]
    #[doc = ""]
    #[doc = "        Configure GPIO's Mode,pull-up,PullDown,IntrType"]
    #[doc = ""]
    #[doc = " @param  pGPIOConfig Pointer to GPIO configure struct"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn gpio_config(pGPIOConfig: *const gpio_config_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Reset an gpio to default state (select gpio function, enable pullup and disable input and output)."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number."]
    #[doc = ""]
    #[doc = " @note This function also configures the IOMUX for this pin to the GPIO"]
    #[doc = "       function, and disconnects any other peripheral output configured via GPIO"]
    #[doc = "       Matrix."]
    #[doc = ""]
    #[doc = " @return Always return ESP_OK."]
    pub fn gpio_reset_pin(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO set interrupt trigger type"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set the trigger type of e.g. of GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  intr_type Interrupt type, select from gpio_int_type_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK  Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn gpio_set_intr_type(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Enable GPIO module interrupt signal"]
    #[doc = ""]
    #[doc = " @note Please do not use the interrupt of GPIO36 and GPIO39 when using ADC."]
    #[doc = "       Please refer to the comments of `adc1_get_raw`."]
    #[doc = "       Please refer to section 3.11 of 'ECO_and_Workarounds_for_Bugs_in_ESP32' for the description of this issue."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to enable an interrupt on e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn gpio_intr_enable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Disable GPIO module interrupt signal"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to disable the interrupt of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    #[doc = ""]
    pub fn gpio_intr_disable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO set output level"]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set the output level of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  level Output level. 0: low ; 1: high"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO number error"]
    #[doc = ""]
    pub fn gpio_set_level(gpio_num: gpio_num_t, level: u32) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  GPIO get input level"]
    #[doc = ""]
    #[doc = " @warning If the pad is not configured for input (or input and output) the returned value is always 0."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to get the logic level of e.g. pin GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - 0 the GPIO input level is 0"]
    #[doc = "     - 1 the GPIO input level is 1"]
    #[doc = ""]
    pub fn gpio_get_level(gpio_num: gpio_num_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief\t GPIO set direction"]
    #[doc = ""]
    #[doc = " Configure GPIO direction,such as output_only,input_only,output_and_input"]
    #[doc = ""]
    #[doc = " @param  gpio_num  Configure GPIO pins number, it should be GPIO number. If you want to set direction of e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  mode GPIO direction"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    #[doc = ""]
    pub fn gpio_set_direction(gpio_num: gpio_num_t, mode: gpio_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief  Configure GPIO pull-up/pull-down resistors"]
    #[doc = ""]
    #[doc = " Only pins that support both input & output have integrated pull-up and pull-down resistors. Input-only GPIOs 34-39 do not."]
    #[doc = ""]
    #[doc = " @param  gpio_num GPIO number. If you want to set pull up or down mode for e.g. GPIO16, gpio_num should be GPIO_NUM_16 (16);"]
    #[doc = " @param  pull GPIO pull up/down mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG : Parameter error"]
    #[doc = ""]
    pub fn gpio_set_pull_mode(gpio_num: gpio_num_t, pull: gpio_pull_mode_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable GPIO wake-up function."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number."]
    #[doc = ""]
    #[doc = " @param intr_type GPIO wake-up type. Only GPIO_INTR_LOW_LEVEL or GPIO_INTR_HIGH_LEVEL can be used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_wakeup_enable(gpio_num: gpio_num_t, intr_type: gpio_int_type_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable GPIO wake-up function."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_wakeup_disable(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief   Register GPIO interrupt handler, the handler is an ISR."]
    #[doc = "          The handler will be attached to the same CPU core that this function is running on."]
    #[doc = ""]
    #[doc = " This ISR function is called whenever any GPIO interrupt occurs. See"]
    #[doc = " the alternative gpio_install_isr_service() and"]
    #[doc = " gpio_isr_handler_add() API in order to have the driver support"]
    #[doc = " per-GPIO ISRs."]
    #[doc = ""]
    #[doc = " @param  fn  Interrupt handler function."]
    #[doc = " @param  intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "            ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = " @param  arg  Parameter for handler function"]
    #[doc = " @param  handle Pointer to return handle. If non-NULL, a handle for the interrupt will be returned here."]
    #[doc = ""]
    #[doc = " \\verbatim embed:rst:leading-asterisk"]
    #[doc = " To disable or remove the ISR, pass the returned handle to the :doc:`interrupt allocation functions </api-reference/system/intr_alloc>`."]
    #[doc = " \\endverbatim"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success ;"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    #[doc = "     - ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    pub fn gpio_isr_register(
        fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
        arg: *mut ::core::ffi::c_void,
        intr_alloc_flags: ::std::os::raw::c_int,
        handle: *mut gpio_isr_handle_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable pull-up on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pullup_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable pull-up on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pullup_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable pull-down on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pulldown_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable pull-down on GPIO."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_pulldown_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Install the driver's GPIO ISR handler service, which allows per-pin GPIO interrupt handlers."]
    #[doc = ""]
    #[doc = " This function is incompatible with gpio_isr_register() - if that function is used, a single global ISR is registered for all GPIO interrupts. If this function is used, the ISR service provides a global GPIO ISR and individual pin handlers are registered via the gpio_isr_handler_add() function."]
    #[doc = ""]
    #[doc = " @param intr_alloc_flags Flags used to allocate the interrupt. One or multiple (ORred)"]
    #[doc = "            ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NO_MEM No memory to install this service"]
    #[doc = "     - ESP_ERR_INVALID_STATE ISR service already installed."]
    #[doc = "     - ESP_ERR_NOT_FOUND No free interrupt found with the specified flags"]
    #[doc = "     - ESP_ERR_INVALID_ARG GPIO error"]
    pub fn gpio_install_isr_service(intr_alloc_flags: ::std::os::raw::c_int) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Uninstall the driver's GPIO ISR service, freeing related resources."]
    pub fn gpio_uninstall_isr_service();
}
extern "C" {
    #[doc = " @brief Add ISR handler for the corresponding GPIO pin."]
    #[doc = ""]
    #[doc = " Call this function after using gpio_install_isr_service() to"]
    #[doc = " install the driver's GPIO ISR handler service."]
    #[doc = ""]
    #[doc = " The pin ISR handlers no longer need to be declared with IRAM_ATTR,"]
    #[doc = " unless you pass the ESP_INTR_FLAG_IRAM flag when allocating the"]
    #[doc = " ISR in gpio_install_isr_service()."]
    #[doc = ""]
    #[doc = " This ISR handler will be called from an ISR. So there is a stack"]
    #[doc = " size limit (configurable as \"ISR stack size\" in menuconfig). This"]
    #[doc = " limit is smaller compared to a global GPIO interrupt handler due"]
    #[doc = " to the additional level of indirection."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = " @param isr_handler ISR handler function for the corresponding GPIO number."]
    #[doc = " @param args parameter for ISR handler."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Wrong state, the ISR service has not been initialized."]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_isr_handler_add(
        gpio_num: gpio_num_t,
        isr_handler: gpio_isr_t,
        args: *mut ::core::ffi::c_void,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Remove ISR handler for the corresponding GPIO pin."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_STATE Wrong state, the ISR service has not been initialized."]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_isr_handler_remove(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Set GPIO pad drive capability"]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output GPIOs"]
    #[doc = " @param strength Drive capability of the pad"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_set_drive_capability(gpio_num: gpio_num_t, strength: gpio_drive_cap_t)
        -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Get GPIO pad drive capability"]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output GPIOs"]
    #[doc = " @param strength Pointer to accept drive capability of the pad"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_INVALID_ARG Parameter error"]
    pub fn gpio_get_drive_capability(
        gpio_num: gpio_num_t,
        strength: *mut gpio_drive_cap_t,
    ) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable gpio pad hold function."]
    #[doc = ""]
    #[doc = " The gpio pad hold function works in both input and output modes, but must be output-capable gpios."]
    #[doc = " If pad hold enabled:"]
    #[doc = "   in output mode: the output level of the pad will be force locked and can not be changed."]
    #[doc = "   in input mode: the input value read will not change, regardless the changes of input signal."]
    #[doc = ""]
    #[doc = " The state of digital gpio cannot be held during Deep-sleep, and it will resume the hold function"]
    #[doc = " when the chip wakes up from Deep-sleep. If the digital gpio also needs to be held during Deep-sleep,"]
    #[doc = " `gpio_deep_sleep_hold_en` should also be called."]
    #[doc = ""]
    #[doc = " Power down or call gpio_hold_dis will disable this function."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output-capable GPIOs"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NOT_SUPPORTED Not support pad hold function"]
    pub fn gpio_hold_en(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Disable gpio pad hold function."]
    #[doc = ""]
    #[doc = " When the chip is woken up from Deep-sleep, the gpio will be set to the default mode, so, the gpio will output"]
    #[doc = " the default level if this function is called. If you dont't want the level changes, the gpio should be configured to"]
    #[doc = " a known state before this function is called."]
    #[doc = "  e.g."]
    #[doc = "     If you hold gpio18 high during Deep-sleep, after the chip is woken up and `gpio_hold_dis` is called,"]
    #[doc = "     gpio18 will output low level(because gpio18 is input mode by default). If you don't want this behavior,"]
    #[doc = "     you should configure gpio18 as output mode and set it to hight level before calling `gpio_hold_dis`."]
    #[doc = ""]
    #[doc = " @param gpio_num GPIO number, only support output-capable GPIOs"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     - ESP_OK Success"]
    #[doc = "     - ESP_ERR_NOT_SUPPORTED Not support pad hold function"]
    pub fn gpio_hold_dis(gpio_num: gpio_num_t) -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Enable all digital gpio pad hold function during Deep-sleep."]
    #[doc = ""]
    #[doc = " When the chip is in Deep-sleep mode, all digital gpio will hold the state before sleep, and when the chip is woken up,"]
    #[doc = " the status of digital gpio will not be held. Note that the pad hold feature only works when the chip is in Deep-sleep mode,"]
    #[doc = " when not in sleep mode, the digital gpio state can be changed even you have called this function."]
    #[doc = ""]
    #[doc = " Power down or call gpio_hold_dis will disable this function, otherwise, the digital gpio hold feature works as long as the chip enter Deep-sleep."]
    pub fn gpio_deep_sleep_hold_en();
}
extern "C" {
    #[doc = " @brief Disable all digital gpio pad hold function during Deep-sleep."]
    #[doc = ""]
    pub fn gpio_deep_sleep_hold_dis();
}
extern "C" {
    #[doc = " @brief Set pad input to a peripheral signal through the IOMUX."]
    #[doc = " @param gpio_num GPIO number of the pad."]
    #[doc = " @param signal_idx Peripheral signal id to input. One of the ``*_IN_IDX`` signals in ``soc/gpio_sig_map.h``."]
    pub fn gpio_iomux_in(gpio_num: u32, signal_idx: u32);
}
extern "C" {
    #[doc = " @brief Set peripheral output to an GPIO pad through the IOMUX."]
    #[doc = " @param gpio_num gpio_num GPIO number of the pad."]
    #[doc = " @param func The function number of the peripheral pin to output pin."]
    #[doc = "        One of the ``FUNC_X_*`` of specified pin (X) in ``soc/io_mux_reg.h``."]
    #[doc = " @param oen_inv True if the output enable needs to be inversed, otherwise False."]
    pub fn gpio_iomux_out(gpio_num: u8, func: ::std::os::raw::c_int, oen_inv: bool);
}
#[doc = "< No log output"]
pub const esp_log_level_t_ESP_LOG_NONE: esp_log_level_t = 0;
#[doc = "< Critical errors, software module can not recover on its own"]
pub const esp_log_level_t_ESP_LOG_ERROR: esp_log_level_t = 1;
#[doc = "< Error conditions from which recovery measures have been taken"]
pub const esp_log_level_t_ESP_LOG_WARN: esp_log_level_t = 2;
#[doc = "< Information messages which describe normal flow of events"]
pub const esp_log_level_t_ESP_LOG_INFO: esp_log_level_t = 3;
#[doc = "< Extra information which is not necessary for normal use (values, pointers, sizes, etc)."]
pub const esp_log_level_t_ESP_LOG_DEBUG: esp_log_level_t = 4;
#[doc = "< Bigger chunks of debugging information, or frequent messages which can potentially flood the output."]
pub const esp_log_level_t_ESP_LOG_VERBOSE: esp_log_level_t = 5;
pub type esp_log_level_t = u32;
extern "C" {
    pub fn esp_log_timestamp() -> u32;
}
extern "C" {
    pub fn esp_log_write(
        level: esp_log_level_t,
        tag: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(numer: intmax_t, denomer: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type ble_npl_event_fn = ::core::option::Option<unsafe extern "C" fn(ev: *mut ble_npl_event)>;
pub const ble_npl_error_BLE_NPL_OK: ble_npl_error = 0;
pub const ble_npl_error_BLE_NPL_ENOMEM: ble_npl_error = 1;
pub const ble_npl_error_BLE_NPL_EINVAL: ble_npl_error = 2;
pub const ble_npl_error_BLE_NPL_INVALID_PARAM: ble_npl_error = 3;
pub const ble_npl_error_BLE_NPL_MEM_NOT_ALIGNED: ble_npl_error = 4;
pub const ble_npl_error_BLE_NPL_BAD_MUTEX: ble_npl_error = 5;
pub const ble_npl_error_BLE_NPL_TIMEOUT: ble_npl_error = 6;
pub const ble_npl_error_BLE_NPL_ERR_IN_ISR: ble_npl_error = 7;
pub const ble_npl_error_BLE_NPL_ERR_PRIV: ble_npl_error = 8;
pub const ble_npl_error_BLE_NPL_OS_NOT_STARTED: ble_npl_error = 9;
pub const ble_npl_error_BLE_NPL_ENOENT: ble_npl_error = 10;
pub const ble_npl_error_BLE_NPL_EBUSY: ble_npl_error = 11;
pub const ble_npl_error_BLE_NPL_ERROR: ble_npl_error = 12;
pub type ble_npl_error = u32;
pub use self::ble_npl_error as ble_npl_error_t;
extern "C" {
    pub fn memchr(
        arg1: *const ::core::ffi::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::std::os::raw::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::std::os::raw::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn strerror(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const ::core::ffi::c_void, arg2: *mut ::core::ffi::c_void, arg3: size_t);
}
extern "C" {
    pub fn bzero(arg1: *mut ::core::ffi::c_void, arg2: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memrchr(
        arg1: *const ::core::ffi::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strdup_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: size_t) -> size_t;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__signo: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
#[doc = " Type by which software timers are referenced.  For example, a call to"]
#[doc = " xTimerCreate() returns an TimerHandle_t variable that can then be used to"]
#[doc = " reference the subject timer in calls to other software timer API functions"]
#[doc = " (for example, xTimerStart(), xTimerReset(), etc.)."]
pub type TimerHandle_t = *mut ::core::ffi::c_void;
#[doc = " Defines the prototype to which timer callback functions must conform."]
pub type TimerCallbackFunction_t =
    ::core::option::Option<unsafe extern "C" fn(xTimer: TimerHandle_t)>;
#[doc = " Defines the prototype to which functions used with the"]
#[doc = " xTimerPendFunctionCallFromISR() function must conform."]
pub type PendedFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void, arg2: u32)>;
extern "C" {
    pub fn xTimerCreate(
        pcTimerName: *const ::std::os::raw::c_char,
        xTimerPeriodInTicks: TickType_t,
        uxAutoReload: UBaseType_t,
        pvTimerID: *mut ::core::ffi::c_void,
        pxCallbackFunction: TimerCallbackFunction_t,
    ) -> TimerHandle_t;
}
extern "C" {
    #[doc = " Returns the ID assigned to the timer."]
    #[doc = ""]
    #[doc = " IDs are assigned to timers using the pvTimerID parameter of the call to"]
    #[doc = " xTimerCreated() that was used to create the timer."]
    #[doc = ""]
    #[doc = " If the same callback function is assigned to multiple timers then the timer"]
    #[doc = " ID can be used within the callback function to identify which timer actually"]
    #[doc = " expired."]
    #[doc = ""]
    #[doc = " @param xTimer The timer being queried."]
    #[doc = ""]
    #[doc = " @return The ID assigned to the timer being queried."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = ""]
    #[doc = " See the xTimerCreate() API function example usage scenario."]
    pub fn pvTimerGetTimerID(xTimer: TimerHandle_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Sets the ID assigned to the timer."]
    #[doc = ""]
    #[doc = " IDs are assigned to timers using the pvTimerID parameter of the call to"]
    #[doc = " xTimerCreated() that was used to create the timer."]
    #[doc = ""]
    #[doc = " If the same callback function is assigned to multiple timers then the timer"]
    #[doc = " ID can be used as time specific (timer local) storage."]
    #[doc = ""]
    #[doc = " @param xTimer The timer being updated."]
    #[doc = ""]
    #[doc = " @param pvNewID The ID to assign to the timer."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = ""]
    #[doc = " See the xTimerCreate() API function example usage scenario."]
    pub fn vTimerSetTimerID(xTimer: TimerHandle_t, pvNewID: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " Queries a timer to see if it is active or dormant."]
    #[doc = ""]
    #[doc = " A timer will be dormant if:"]
    #[doc = ""]
    #[doc = "     1) It has been created but not started, or"]
    #[doc = ""]
    #[doc = "     2) It is an expired one-shot timer that has not been restarted."]
    #[doc = ""]
    #[doc = " Timers are created in the dormant state.  The xTimerStart(), xTimerReset(),"]
    #[doc = " xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and"]
    #[doc = " xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the"]
    #[doc = " active state."]
    #[doc = ""]
    #[doc = " @param xTimer The timer being queried."]
    #[doc = ""]
    #[doc = " @return pdFALSE will be returned if the timer is dormant.  A value other than"]
    #[doc = " pdFALSE will be returned if the timer is active."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = " // This function assumes xTimer has already been created."]
    #[doc = " void vAFunction( TimerHandle_t xTimer )"]
    #[doc = " {"]
    #[doc = "     if( xTimerIsTimerActive( xTimer ) != pdFALSE ) // or more simply and equivalently \"if( xTimerIsTimerActive( xTimer ) )\""]
    #[doc = "     {"]
    #[doc = "         // xTimer is active, do something."]
    #[doc = "     }"]
    #[doc = "     else"]
    #[doc = "     {"]
    #[doc = "         // xTimer is not active, do something else."]
    #[doc = "     }"]
    #[doc = " }"]
    #[doc = " @endcode"]
    pub fn xTimerIsTimerActive(xTimer: TimerHandle_t) -> BaseType_t;
}
extern "C" {
    #[doc = " xTimerGetTimerDaemonTaskHandle() is only available if"]
    #[doc = " INCLUDE_xTimerGetTimerDaemonTaskHandle is set to 1 in FreeRTOSConfig.h."]
    #[doc = ""]
    #[doc = " Simply returns the handle of the timer service/daemon task.  It it not valid"]
    #[doc = " to call xTimerGetTimerDaemonTaskHandle() before the scheduler has been started."]
    pub fn xTimerGetTimerDaemonTaskHandle() -> TaskHandle_t;
}
extern "C" {
    #[doc = " Returns the period of a timer."]
    #[doc = ""]
    #[doc = " @param xTimer The handle of the timer being queried."]
    #[doc = ""]
    #[doc = " @return The period of the timer in ticks."]
    pub fn xTimerGetPeriod(xTimer: TimerHandle_t) -> TickType_t;
}
extern "C" {
    #[doc = " Returns the time in ticks at which the timer will expire.  If this is less"]
    #[doc = " than the current tick count then the expiry time has overflowed from the"]
    #[doc = " current time."]
    #[doc = ""]
    #[doc = " @param xTimer The handle of the timer being queried."]
    #[doc = ""]
    #[doc = " @return If the timer is running then the time in ticks at which the timer"]
    #[doc = " will next expire is returned.  If the timer is not running then the return"]
    #[doc = " value is undefined."]
    pub fn xTimerGetExpiryTime(xTimer: TimerHandle_t) -> TickType_t;
}
extern "C" {
    #[doc = " Used from application interrupt service routines to defer the execution of a"]
    #[doc = " function to the RTOS daemon task (the timer service task, hence this function"]
    #[doc = " is implemented in timers.c and is prefixed with 'Timer')."]
    #[doc = ""]
    #[doc = " Ideally an interrupt service routine (ISR) is kept as short as possible, but"]
    #[doc = " sometimes an ISR either has a lot of processing to do, or needs to perform"]
    #[doc = " processing that is not deterministic.  In these cases"]
    #[doc = " xTimerPendFunctionCallFromISR() can be used to defer processing of a function"]
    #[doc = " to the RTOS daemon task."]
    #[doc = ""]
    #[doc = " A mechanism is provided that allows the interrupt to return directly to the"]
    #[doc = " task that will subsequently execute the pended callback function.  This"]
    #[doc = " allows the callback function to execute contiguously in time with the"]
    #[doc = " interrupt - just as if the callback had executed in the interrupt itself."]
    #[doc = ""]
    #[doc = " @param xFunctionToPend The function to execute from the timer service/"]
    #[doc = " daemon task.  The function must conform to the PendedFunction_t"]
    #[doc = " prototype."]
    #[doc = ""]
    #[doc = " @param pvParameter1 The value of the callback function's first parameter."]
    #[doc = " The parameter has a void * type to allow it to be used to pass any type."]
    #[doc = " For example, unsigned longs can be cast to a void *, or the void * can be"]
    #[doc = " used to point to a structure."]
    #[doc = ""]
    #[doc = " @param ulParameter2 The value of the callback function's second parameter."]
    #[doc = ""]
    #[doc = " @param pxHigherPriorityTaskWoken As mentioned above, calling this function"]
    #[doc = " will result in a message being sent to the timer daemon task.  If the"]
    #[doc = " priority of the timer daemon task (which is set using"]
    #[doc = " configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of"]
    #[doc = " the currently running task (the task the interrupt interrupted) then"]
    #[doc = " *pxHigherPriorityTaskWoken will be set to pdTRUE within"]
    #[doc = " xTimerPendFunctionCallFromISR(), indicating that a context switch should be"]
    #[doc = " requested before the interrupt exits.  For that reason"]
    #[doc = " *pxHigherPriorityTaskWoken must be initialised to pdFALSE.  See the"]
    #[doc = " example code below."]
    #[doc = ""]
    #[doc = " @return pdPASS is returned if the message was successfully sent to the"]
    #[doc = " timer daemon task, otherwise pdFALSE is returned."]
    #[doc = ""]
    #[doc = " Example usage:"]
    #[doc = " @code{c}"]
    #[doc = ""]
    #[doc = "\t// The callback function that will execute in the context of the daemon task."]
    #[doc = "  // Note callback functions must all use this same prototype."]
    #[doc = "  void vProcessInterface( void *pvParameter1, uint32_t ulParameter2 )"]
    #[doc = "\t{"]
    #[doc = "\t\tBaseType_t xInterfaceToService;"]
    #[doc = ""]
    #[doc = "\t\t// The interface that requires servicing is passed in the second"]
    #[doc = "      // parameter.  The first parameter is not used in this case."]
    #[doc = "\t\txInterfaceToService = ( BaseType_t ) ulParameter2;"]
    #[doc = ""]
    #[doc = "\t\t// ...Perform the processing here..."]
    #[doc = "\t}"]
    #[doc = ""]
    #[doc = "\t// An ISR that receives data packets from multiple interfaces"]
    #[doc = "  void vAnISR( void )"]
    #[doc = "\t{"]
    #[doc = "\t\tBaseType_t xInterfaceToService, xHigherPriorityTaskWoken;"]
    #[doc = ""]
    #[doc = "\t\t// Query the hardware to determine which interface needs processing."]
    #[doc = "\t\txInterfaceToService = prvCheckInterfaces();"]
    #[doc = ""]
    #[doc = "      // The actual processing is to be deferred to a task.  Request the"]
    #[doc = "      // vProcessInterface() callback function is executed, passing in the"]
    #[doc = "\t\t// number of the interface that needs processing.  The interface to"]
    #[doc = "\t\t// service is passed in the second parameter.  The first parameter is"]
    #[doc = "\t\t// not used in this case."]
    #[doc = "\t\txHigherPriorityTaskWoken = pdFALSE;"]
    #[doc = "\t\txTimerPendFunctionCallFromISR( vProcessInterface, NULL, ( uint32_t ) xInterfaceToService, &xHigherPriorityTaskWoken );"]
    #[doc = ""]
    #[doc = "\t\t// If xHigherPriorityTaskWoken is now set to pdTRUE then a context"]
    #[doc = "\t\t// switch should be requested.  The macro used is port specific and will"]
    #[doc = "\t\t// be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() - refer to"]
    #[doc = "\t\t// the documentation page for the port being used."]
    #[doc = "\t\tportYIELD_FROM_ISR( xHigherPriorityTaskWoken );"]
    #[doc = ""]
    #[doc = "\t}"]
    #[doc = " @endcode"]
    pub fn xTimerPendFunctionCallFromISR(
        xFunctionToPend: PendedFunction_t,
        pvParameter1: *mut ::core::ffi::c_void,
        ulParameter2: u32,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Used to defer the execution of a function to the RTOS daemon task (the timer"]
    #[doc = " service task, hence this function is implemented in timers.c and is prefixed"]
    #[doc = " with 'Timer')."]
    #[doc = ""]
    #[doc = " @param xFunctionToPend The function to execute from the timer service/"]
    #[doc = " daemon task.  The function must conform to the PendedFunction_t"]
    #[doc = " prototype."]
    #[doc = ""]
    #[doc = " @param pvParameter1 The value of the callback function's first parameter."]
    #[doc = " The parameter has a void * type to allow it to be used to pass any type."]
    #[doc = " For example, unsigned longs can be cast to a void *, or the void * can be"]
    #[doc = " used to point to a structure."]
    #[doc = ""]
    #[doc = " @param ulParameter2 The value of the callback function's second parameter."]
    #[doc = ""]
    #[doc = " @param xTicksToWait Calling this function will result in a message being"]
    #[doc = " sent to the timer daemon task on a queue.  xTicksToWait is the amount of"]
    #[doc = " time the calling task should remain in the Blocked state (so not using any"]
    #[doc = " processing time) for space to become available on the timer queue if the"]
    #[doc = " queue is found to be full."]
    #[doc = ""]
    #[doc = " @return pdPASS is returned if the message was successfully sent to the"]
    #[doc = " timer daemon task, otherwise pdFALSE is returned."]
    #[doc = ""]
    pub fn xTimerPendFunctionCall(
        xFunctionToPend: PendedFunction_t,
        pvParameter1: *mut ::core::ffi::c_void,
        ulParameter2: u32,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    #[doc = " Returns the name that was assigned to a timer when the timer was created."]
    #[doc = ""]
    #[doc = " @param xTimer The handle of the timer being queried."]
    #[doc = ""]
    #[doc = " @return The name assigned to the timer specified by the xTimer parameter."]
    pub fn pcTimerGetTimerName(xTimer: TimerHandle_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @cond"]
    pub fn xTimerCreateTimerTask() -> BaseType_t;
}
extern "C" {
    pub fn xTimerGenericCommand(
        xTimer: TimerHandle_t,
        xCommandID: BaseType_t,
        xOptionalValue: TickType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
pub type ble_npl_time_t = u32;
pub type ble_npl_stime_t = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_npl_event {
    pub queued: bool,
    pub fn_: ble_npl_event_fn,
    pub arg: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_npl_eventq {
    pub q: QueueHandle_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_npl_callout {
    pub handle: TimerHandle_t,
    pub evq: *mut ble_npl_eventq,
    pub ev: ble_npl_event,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_npl_mutex {
    pub handle: SemaphoreHandle_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_npl_sem {
    pub handle: SemaphoreHandle_t,
}
extern "C" {
    pub fn npl_freertos_eventq_dflt_get() -> *mut ble_npl_eventq;
}
extern "C" {
    pub fn npl_freertos_eventq_get(
        evq: *mut ble_npl_eventq,
        tmo: ble_npl_time_t,
    ) -> *mut ble_npl_event;
}
extern "C" {
    pub fn npl_freertos_eventq_put(evq: *mut ble_npl_eventq, ev: *mut ble_npl_event);
}
extern "C" {
    pub fn npl_freertos_eventq_remove(evq: *mut ble_npl_eventq, ev: *mut ble_npl_event);
}
extern "C" {
    pub fn npl_freertos_mutex_init(mu: *mut ble_npl_mutex) -> ble_npl_error_t;
}
extern "C" {
    pub fn npl_freertos_mutex_deinit(mu: *mut ble_npl_mutex) -> ble_npl_error_t;
}
extern "C" {
    pub fn npl_freertos_mutex_pend(
        mu: *mut ble_npl_mutex,
        timeout: ble_npl_time_t,
    ) -> ble_npl_error_t;
}
extern "C" {
    pub fn npl_freertos_mutex_release(mu: *mut ble_npl_mutex) -> ble_npl_error_t;
}
extern "C" {
    pub fn npl_freertos_sem_init(sem: *mut ble_npl_sem, tokens: u16) -> ble_npl_error_t;
}
extern "C" {
    pub fn npl_freertos_sem_deinit(sem: *mut ble_npl_sem) -> ble_npl_error_t;
}
extern "C" {
    pub fn npl_freertos_sem_pend(sem: *mut ble_npl_sem, timeout: ble_npl_time_t)
        -> ble_npl_error_t;
}
extern "C" {
    pub fn npl_freertos_sem_release(sem: *mut ble_npl_sem) -> ble_npl_error_t;
}
extern "C" {
    pub fn npl_freertos_callout_init(
        co: *mut ble_npl_callout,
        evq: *mut ble_npl_eventq,
        ev_cb: ble_npl_event_fn,
        ev_arg: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    pub fn npl_freertos_callout_deinit(co: *mut ble_npl_callout);
}
extern "C" {
    pub fn npl_freertos_callout_reset(
        co: *mut ble_npl_callout,
        ticks: ble_npl_time_t,
    ) -> ble_npl_error_t;
}
extern "C" {
    pub fn npl_freertos_callout_remaining_ticks(
        co: *mut ble_npl_callout,
        now: ble_npl_time_t,
    ) -> ble_npl_time_t;
}
extern "C" {
    pub fn npl_freertos_time_ms_to_ticks(
        ms: u32,
        out_ticks: *mut ble_npl_time_t,
    ) -> ble_npl_error_t;
}
extern "C" {
    pub fn npl_freertos_time_ticks_to_ms(
        ticks: ble_npl_time_t,
        out_ms: *mut u32,
    ) -> ble_npl_error_t;
}
extern "C" {
    pub fn npl_freertos_hw_set_isr(irqn: ::std::os::raw::c_int, addr: u32);
}
extern "C" {
    pub fn npl_freertos_hw_enter_critical() -> u32;
}
extern "C" {
    pub fn npl_freertos_hw_exit_critical(ctx: u32);
}
extern "C" {
    pub static mut ble_port_mutex: portMUX_TYPE;
}
extern "C" {
    pub fn ble_npl_hw_is_in_critical() -> bool;
}
pub type os_sr_t = u32;
extern "C" {
    pub fn put_le16(buf: *mut ::core::ffi::c_void, x: u16);
}
extern "C" {
    pub fn put_le32(buf: *mut ::core::ffi::c_void, x: u32);
}
extern "C" {
    pub fn put_le64(buf: *mut ::core::ffi::c_void, x: u64);
}
extern "C" {
    pub fn get_le16(buf: *const ::core::ffi::c_void) -> u16;
}
extern "C" {
    pub fn get_le32(buf: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn get_le64(buf: *const ::core::ffi::c_void) -> u64;
}
extern "C" {
    pub fn put_be16(buf: *mut ::core::ffi::c_void, x: u16);
}
extern "C" {
    pub fn put_be32(buf: *mut ::core::ffi::c_void, x: u32);
}
extern "C" {
    pub fn put_be64(buf: *mut ::core::ffi::c_void, x: u64);
}
extern "C" {
    pub fn get_be16(buf: *const ::core::ffi::c_void) -> u16;
}
extern "C" {
    pub fn get_be32(buf: *const ::core::ffi::c_void) -> u32;
}
extern "C" {
    pub fn get_be64(buf: *const ::core::ffi::c_void) -> u64;
}
extern "C" {
    pub fn swap_in_place(buf: *mut ::core::ffi::c_void, len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn swap_buf(dst: *mut u8, src: *const u8, len: ::std::os::raw::c_int);
}
pub const os_error_OS_OK: os_error = 0;
pub const os_error_OS_ENOMEM: os_error = 1;
pub const os_error_OS_EINVAL: os_error = 2;
pub const os_error_OS_INVALID_PARM: os_error = 3;
pub const os_error_OS_MEM_NOT_ALIGNED: os_error = 4;
pub const os_error_OS_BAD_MUTEX: os_error = 5;
pub const os_error_OS_TIMEOUT: os_error = 6;
pub const os_error_OS_ERR_IN_ISR: os_error = 7;
pub const os_error_OS_ERR_PRIV: os_error = 8;
pub const os_error_OS_NOT_STARTED: os_error = 9;
pub const os_error_OS_ENOENT: os_error = 10;
pub const os_error_OS_EBUSY: os_error = 11;
pub const os_error_OS_ERROR: os_error = 12;
pub type os_error = u32;
pub use self::os_error as os_error_t;
#[doc = " A mbuf pool from which to allocate mbufs. This contains a pointer to the os"]
#[doc = " mempool to allocate mbufs out of, the total number of elements in the pool,"]
#[doc = " and the amount of \"user\" data in a non-packet header mbuf. The total pool"]
#[doc = " size, in bytes, should be:"]
#[doc = "  os_mbuf_count * (omp_databuf_len + sizeof(struct os_mbuf))"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_mbuf_pool {
    #[doc = " Total length of the databuf in each mbuf.  This is the size of the"]
    #[doc = " mempool block, minus the mbuf header"]
    pub omp_databuf_len: u16,
    #[doc = " The memory pool which to allocate mbufs out of"]
    pub omp_pool: *mut os_mempool,
    pub omp_next: os_mbuf_pool__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_mbuf_pool__bindgen_ty_1 {
    pub stqe_next: *mut os_mbuf_pool,
}
#[doc = " A packet header structure that preceeds the mbuf packet headers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_mbuf_pkthdr {
    #[doc = " Overall length of the packet."]
    pub omp_len: u16,
    #[doc = " Flags"]
    pub omp_flags: u16,
    pub omp_next: os_mbuf_pkthdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_mbuf_pkthdr__bindgen_ty_1 {
    pub stqe_next: *mut os_mbuf_pkthdr,
}
#[doc = " Chained memory buffer."]
#[repr(C)]
#[derive(Debug)]
pub struct os_mbuf {
    #[doc = " Current pointer to data in the structure"]
    pub om_data: *mut u8,
    #[doc = " Flags associated with this buffer, see OS_MBUF_F_* defintions"]
    pub om_flags: u8,
    #[doc = " Length of packet header"]
    pub om_pkthdr_len: u8,
    #[doc = " Length of data in this buffer"]
    pub om_len: u16,
    #[doc = " The mbuf pool this mbuf was allocated out of"]
    pub om_omp: *mut os_mbuf_pool,
    pub om_next: os_mbuf__bindgen_ty_1,
    #[doc = " Pointer to the beginning of the data, after this buffer"]
    pub om_databuf: __IncompleteArrayField<u8>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_mbuf__bindgen_ty_1 {
    pub sle_next: *mut os_mbuf,
}
#[doc = " Structure representing a queue of mbufs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_mqueue {
    pub mq_head: os_mqueue__bindgen_ty_1,
    #[doc = " Event to post when new buffers are available on the queue."]
    pub mq_ev: ble_npl_event,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_mqueue__bindgen_ty_1 {
    pub stqh_first: *mut os_mbuf_pkthdr,
    pub stqh_last: *mut *mut os_mbuf_pkthdr,
}
extern "C" {
    #[doc = " Initializes an mqueue.  An mqueue is a queue of mbufs that ties to a"]
    #[doc = " particular task's event queue.  Mqueues form a helper API around a common"]
    #[doc = " paradigm: wait on an event queue until at least one packet is available,"]
    #[doc = " then process a queue of packets."]
    #[doc = ""]
    #[doc = " When mbufs are available on the queue, an event OS_EVENT_T_MQUEUE_DATA"]
    #[doc = " will be posted to the task's mbuf queue."]
    #[doc = ""]
    #[doc = " @param mq                    The mqueue to initialize"]
    #[doc = " @param ev_cb                 The callback to associate with the mqeueue"]
    #[doc = "                                  event.  Typically, this callback pulls each"]
    #[doc = "                                  packet off the mqueue and processes them."]
    #[doc = " @param arg                   The argument to associate with the mqueue event."]
    #[doc = ""]
    #[doc = " @return                      0 on success, non-zero on failure."]
    pub fn os_mqueue_init(
        mq: *mut os_mqueue,
        ev_cb: ble_npl_event_fn,
        arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove and return a single mbuf from the mbuf queue.  Does not block."]
    #[doc = ""]
    #[doc = " @param mq The mbuf queue to pull an element off of."]
    #[doc = ""]
    #[doc = " @return The next mbuf in the queue, or NULL if queue has no mbufs."]
    pub fn os_mqueue_get(arg1: *mut os_mqueue) -> *mut os_mbuf;
}
extern "C" {
    #[doc = " Adds a packet (i.e. packet header mbuf) to an mqueue. The event associated"]
    #[doc = " with the mqueue gets posted to the specified eventq."]
    #[doc = ""]
    #[doc = " @param mq                    The mbuf queue to append the mbuf to."]
    #[doc = " @param evq                   The event queue to post an event to."]
    #[doc = " @param m                     The mbuf to append to the mbuf queue."]
    #[doc = ""]
    #[doc = " @return 0 on success, non-zero on failure."]
    pub fn os_mqueue_put(
        arg1: *mut os_mqueue,
        arg2: *mut ble_npl_eventq,
        arg3: *mut os_mbuf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " MSYS is a system level mbuf registry.  Allows the system to share"]
    #[doc = " packet buffers amongst the various networking stacks that can be running"]
    #[doc = " simultaeneously."]
    #[doc = ""]
    #[doc = " Mbuf pools are created in the system initialization code, and then when"]
    #[doc = " a mbuf is allocated out of msys, it will try and find the best fit based"]
    #[doc = " upon estimated mbuf size."]
    #[doc = ""]
    #[doc = " os_msys_register() registers a mbuf pool with MSYS, and allows MSYS to"]
    #[doc = " allocate mbufs out of it."]
    #[doc = ""]
    #[doc = " @param new_pool The pool to register with MSYS"]
    #[doc = ""]
    #[doc = " @return 0 on success, non-zero on failure"]
    pub fn os_msys_register(arg1: *mut os_mbuf_pool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a mbuf from msys.  Based upon the data size requested,"]
    #[doc = " os_msys_get() will choose the mbuf pool that has the best fit."]
    #[doc = ""]
    #[doc = " @param dsize The estimated size of the data being stored in the mbuf"]
    #[doc = " @param leadingspace The amount of leadingspace to allocate in the mbuf"]
    #[doc = ""]
    #[doc = " @return A freshly allocated mbuf on success, NULL on failure."]
    pub fn os_msys_get(dsize: u16, leadingspace: u16) -> *mut os_mbuf;
}
extern "C" {
    #[doc = " De-registers all mbuf pools from msys."]
    pub fn os_msys_reset();
}
extern "C" {
    #[doc = " Allocate a packet header structure from the MSYS pool.  See"]
    #[doc = " os_msys_register() for a description of MSYS."]
    #[doc = ""]
    #[doc = " @param dsize The estimated size of the data being stored in the mbuf"]
    #[doc = " @param user_hdr_len The length to allocate for the packet header structure"]
    #[doc = ""]
    #[doc = " @return A freshly allocated mbuf on success, NULL on failure."]
    pub fn os_msys_get_pkthdr(dsize: u16, user_hdr_len: u16) -> *mut os_mbuf;
}
extern "C" {
    #[doc = " Count the number of blocks in all the mbuf pools that are allocated."]
    #[doc = ""]
    #[doc = " @return total number of blocks allocated in Msys"]
    pub fn os_msys_count() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the number of free blocks in Msys"]
    #[doc = ""]
    #[doc = " @return Number of free blocks available in Msys"]
    pub fn os_msys_num_free() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize a pool of mbufs."]
    #[doc = ""]
    #[doc = " @param omp     The mbuf pool to initialize"]
    #[doc = " @param mp      The memory pool that will hold this mbuf pool"]
    #[doc = " @param buf_len The length of the buffer itself."]
    #[doc = " @param nbufs   The number of buffers in the pool"]
    #[doc = ""]
    #[doc = " @return 0 on success, error code on failure."]
    pub fn os_mbuf_pool_init(
        arg1: *mut os_mbuf_pool,
        mp: *mut os_mempool,
        arg2: u16,
        arg3: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get an mbuf from the mbuf pool.  The mbuf is allocated, and initialized"]
    #[doc = " prior to being returned."]
    #[doc = ""]
    #[doc = " @param omp The mbuf pool to return the packet from"]
    #[doc = " @param leadingspace The amount of leadingspace to put before the data"]
    #[doc = "     section by default."]
    #[doc = ""]
    #[doc = " @return An initialized mbuf on success, and NULL on failure."]
    pub fn os_mbuf_get(omp: *mut os_mbuf_pool, arg1: u16) -> *mut os_mbuf;
}
extern "C" {
    #[doc = " Allocate a new packet header mbuf out of the os_mbuf_pool."]
    #[doc = ""]
    #[doc = " @param omp The mbuf pool to allocate out of"]
    #[doc = " @param user_pkthdr_len The packet header length to reserve for the caller."]
    #[doc = ""]
    #[doc = " @return A freshly allocated mbuf on success, NULL on failure."]
    pub fn os_mbuf_get_pkthdr(omp: *mut os_mbuf_pool, pkthdr_len: u8) -> *mut os_mbuf;
}
extern "C" {
    #[doc = " Duplicate a chain of mbufs.  Return the start of the duplicated chain."]
    #[doc = ""]
    #[doc = " @param omp The mbuf pool to duplicate out of"]
    #[doc = " @param om  The mbuf chain to duplicate"]
    #[doc = ""]
    #[doc = " @return A pointer to the new chain of mbufs"]
    pub fn os_mbuf_dup(m: *mut os_mbuf) -> *mut os_mbuf;
}
extern "C" {
    #[doc = " Locates the specified absolute offset within an mbuf chain.  The offset"]
    #[doc = " can be one past than the total length of the chain, but no greater."]
    #[doc = ""]
    #[doc = " @param om                    The start of the mbuf chain to seek within."]
    #[doc = " @param off                   The absolute address to find."]
    #[doc = " @param out_off               On success, this points to the relative offset"]
    #[doc = "                                  within the returned mbuf."]
    #[doc = ""]
    #[doc = " @return                      The mbuf containing the specified offset on"]
    #[doc = "                                  success."]
    #[doc = "                              NULL if the specified offset is out of bounds."]
    pub fn os_mbuf_off(
        om: *const os_mbuf,
        off: ::std::os::raw::c_int,
        out_off: *mut u16,
    ) -> *mut os_mbuf;
}
extern "C" {
    pub fn os_mbuf_copydata(
        m: *const os_mbuf,
        off: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
        dst: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Append data onto a mbuf"]
    #[doc = ""]
    #[doc = " @param om   The mbuf to append the data onto"]
    #[doc = " @param data The data to append onto the mbuf"]
    #[doc = " @param len  The length of the data to append"]
    #[doc = ""]
    #[doc = " @return 0 on success, and an error code on failure"]
    pub fn os_mbuf_append(
        m: *mut os_mbuf,
        arg1: *const ::core::ffi::c_void,
        arg2: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reads data from one mbuf and appends it to another.  On error, the specified"]
    #[doc = " data range may be partially appended.  Neither mbuf is required to contain"]
    #[doc = " an mbuf packet header."]
    #[doc = ""]
    #[doc = " @param dst                   The mbuf to append to."]
    #[doc = " @param src                   The mbuf to copy data from."]
    #[doc = " @param src_off               The absolute offset within the source mbuf"]
    #[doc = "                                  chain to read from."]
    #[doc = " @param len                   The number of bytes to append."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              OS_EINVAL if the specified range extends beyond"]
    #[doc = "                                  the end of the source mbuf chain."]
    pub fn os_mbuf_appendfrom(
        dst: *mut os_mbuf,
        src: *const os_mbuf,
        src_off: u16,
        len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release a mbuf back to the pool"]
    #[doc = ""]
    #[doc = " @param omp The Mbuf pool to release back to"]
    #[doc = " @param om  The Mbuf to release back to the pool"]
    #[doc = ""]
    #[doc = " @return 0 on success, -1 on failure"]
    pub fn os_mbuf_free(mb: *mut os_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free a chain of mbufs"]
    #[doc = ""]
    #[doc = " @param omp The mbuf pool to free the chain of mbufs into"]
    #[doc = " @param om  The starting mbuf of the chain to free back into the pool"]
    #[doc = ""]
    #[doc = " @return 0 on success, -1 on failure"]
    pub fn os_mbuf_free_chain(om: *mut os_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adjust the length of a mbuf, trimming either from the head or the tail"]
    #[doc = " of the mbuf."]
    #[doc = ""]
    #[doc = " @param mp The mbuf chain to adjust"]
    #[doc = " @param req_len The length to trim from the mbuf.  If positive, trims"]
    #[doc = "                from the head of the mbuf, if negative, trims from the"]
    #[doc = "                tail of the mbuf."]
    pub fn os_mbuf_adj(mp: *mut os_mbuf, req_len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Performs a memory compare of the specified region of an mbuf chain against a"]
    #[doc = " flat buffer."]
    #[doc = ""]
    #[doc = " @param om                    The start of the mbuf chain to compare."]
    #[doc = " @param off                   The offset within the mbuf chain to start the"]
    #[doc = "                                  comparison."]
    #[doc = " @param data                  The flat buffer to compare."]
    #[doc = " @param len                   The length of the flat buffer."]
    #[doc = ""]
    #[doc = " @return                      0 if both memory regions are identical;"]
    #[doc = "                              A memcmp return code if there is a mismatch;"]
    #[doc = "                              INT_MAX if the mbuf is too short."]
    pub fn os_mbuf_cmpf(
        om: *const os_mbuf,
        off: ::std::os::raw::c_int,
        data: *const ::core::ffi::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compares the contents of two mbuf chains.  The ranges of the two chains to"]
    #[doc = " be compared are specified via the two offset parameters and the len"]
    #[doc = " parameter.  Neither mbuf chain is required to contain a packet header."]
    #[doc = ""]
    #[doc = " @param om1                   The first mbuf chain to compare."]
    #[doc = " @param offset1               The absolute offset within om1 at which to"]
    #[doc = "                                  start the comparison."]
    #[doc = " @param om2                   The second mbuf chain to compare."]
    #[doc = " @param offset2               The absolute offset within om2 at which to"]
    #[doc = "                                  start the comparison."]
    #[doc = " @param len                   The number of bytes to compare."]
    #[doc = ""]
    #[doc = " @return                      0 if both mbuf segments are identical;"]
    #[doc = "                              A memcmp() return code if the segment contents"]
    #[doc = "                                  differ;"]
    #[doc = "                              INT_MAX if a specified range extends beyond the"]
    #[doc = "                                  end of its corresponding mbuf chain."]
    pub fn os_mbuf_cmpm(
        om1: *const os_mbuf,
        offset1: u16,
        om2: *const os_mbuf,
        offset2: u16,
        len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Increases the length of an mbuf chain by adding data to the front.  If there"]
    #[doc = " is insufficient room in the leading mbuf, additional mbufs are allocated and"]
    #[doc = " prepended as necessary.  If this function fails to allocate an mbuf, the"]
    #[doc = " entire chain is freed."]
    #[doc = ""]
    #[doc = " The specified mbuf chain does not need to contain a packet header."]
    #[doc = ""]
    #[doc = " @param omp                   The mbuf pool to allocate from."]
    #[doc = " @param om                    The head of the mbuf chain."]
    #[doc = " @param len                   The number of bytes to prepend."]
    #[doc = ""]
    #[doc = " @return                      The new head of the chain on success;"]
    #[doc = "                              NULL on failure."]
    pub fn os_mbuf_prepend(om: *mut os_mbuf, len: ::std::os::raw::c_int) -> *mut os_mbuf;
}
extern "C" {
    #[doc = " Prepends a chunk of empty data to the specified mbuf chain and ensures the"]
    #[doc = " chunk is contiguous.  If either operation fails, the specified mbuf chain is"]
    #[doc = " freed and NULL is returned."]
    #[doc = ""]
    #[doc = " @param om                    The mbuf chain to prepend to."]
    #[doc = " @param len                   The number of bytes to prepend and pullup."]
    #[doc = ""]
    #[doc = " @return                      The modified mbuf on success;"]
    #[doc = "                              NULL on failure (and the mbuf chain is freed)."]
    pub fn os_mbuf_prepend_pullup(om: *mut os_mbuf, len: u16) -> *mut os_mbuf;
}
extern "C" {
    #[doc = " Copies the contents of a flat buffer into an mbuf chain, starting at the"]
    #[doc = " specified destination offset.  If the mbuf is too small for the source data,"]
    #[doc = " it is extended as necessary.  If the destination mbuf contains a packet"]
    #[doc = " header, the header length is updated."]
    #[doc = ""]
    #[doc = " @param omp                   The mbuf pool to allocate from."]
    #[doc = " @param om                    The mbuf chain to copy into."]
    #[doc = " @param off                   The offset within the chain to copy to."]
    #[doc = " @param src                   The source buffer to copy from."]
    #[doc = " @param len                   The number of bytes to copy."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn os_mbuf_copyinto(
        om: *mut os_mbuf,
        off: ::std::os::raw::c_int,
        src: *const ::core::ffi::c_void,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attaches a second mbuf chain onto the end of the first.  If the first chain"]
    #[doc = " contains a packet header, the header's length is updated.  If the second"]
    #[doc = " chain has a packet header, its header is cleared."]
    #[doc = ""]
    #[doc = " @param first                 The mbuf chain being attached to."]
    #[doc = " @param second                The mbuf chain that gets attached."]
    pub fn os_mbuf_concat(first: *mut os_mbuf, second: *mut os_mbuf);
}
extern "C" {
    #[doc = " Increases the length of an mbuf chain by the specified amount.  If there is"]
    #[doc = " not sufficient room in the last buffer, a new buffer is allocated and"]
    #[doc = " appended to the chain.  It is an error to request more data than can fit in"]
    #[doc = " a single buffer."]
    #[doc = ""]
    #[doc = " @param omp"]
    #[doc = " @param om                    The head of the chain to extend."]
    #[doc = " @param len                   The number of bytes to extend by."]
    #[doc = ""]
    #[doc = " @return                      A pointer to the new data on success;"]
    #[doc = "                              NULL on failure."]
    pub fn os_mbuf_extend(om: *mut os_mbuf, len: u16) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Rearrange a mbuf chain so that len bytes are contiguous,"]
    #[doc = " and in the data area of an mbuf (so that OS_MBUF_DATA() will"]
    #[doc = " work on a structure of size len.)  Returns the resulting"]
    #[doc = " mbuf chain on success, free's it and returns NULL on failure."]
    #[doc = ""]
    #[doc = " If there is room, it will add up to \"max_protohdr - len\""]
    #[doc = " extra bytes to the contiguous region, in an attempt to avoid being"]
    #[doc = " called next time."]
    #[doc = ""]
    #[doc = " @param omp The mbuf pool to take the mbufs out of"]
    #[doc = " @param om The mbuf chain to make contiguous"]
    #[doc = " @param len The number of bytes in the chain to make contiguous"]
    #[doc = ""]
    #[doc = " @return The contiguous mbuf chain on success, NULL on failure."]
    pub fn os_mbuf_pullup(om: *mut os_mbuf, len: u16) -> *mut os_mbuf;
}
extern "C" {
    #[doc = " Removes and frees empty mbufs from the front of a chain.  If the chain"]
    #[doc = " contains a packet header, it is preserved."]
    #[doc = ""]
    #[doc = " @param om                    The mbuf chain to trim."]
    #[doc = ""]
    #[doc = " @return                      The head of the trimmed mbuf chain."]
    pub fn os_mbuf_trim_front(om: *mut os_mbuf) -> *mut os_mbuf;
}
#[doc = " A memory block structure. This simply contains a pointer to the free list"]
#[doc = " chain and is only used when the block is on the free list. When the block"]
#[doc = " has been removed from the free list the entire memory block is usable by the"]
#[doc = " caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_memblock {
    pub mb_next: os_memblock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_memblock__bindgen_ty_1 {
    pub sle_next: *mut os_memblock,
}
#[doc = " Memory pool"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_mempool {
    #[doc = " Size of the memory blocks, in bytes."]
    pub mp_block_size: u32,
    #[doc = " The number of memory blocks."]
    pub mp_num_blocks: u16,
    #[doc = " The number of free blocks left"]
    pub mp_num_free: u16,
    #[doc = " The lowest number of free blocks seen"]
    pub mp_min_free: u16,
    #[doc = " Bitmap of OS_MEMPOOL_F_[...] values."]
    pub mp_flags: u8,
    #[doc = " Address of memory buffer used by pool"]
    pub mp_membuf_addr: usize,
    pub mp_list: os_mempool__bindgen_ty_1,
    pub __bindgen_anon_1: os_mempool__bindgen_ty_2,
    #[doc = " Name for memory block"]
    pub name: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_mempool__bindgen_ty_1 {
    pub stqe_next: *mut os_mempool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_mempool__bindgen_ty_2 {
    pub slh_first: *mut os_memblock,
}
#[doc = " Block put callback function.  If configured, this callback gets executed"]
#[doc = " whenever a block is freed to the corresponding extended mempool.  Note: The"]
#[doc = " os_memblock_put() function calls this callback instead of freeing the block"]
#[doc = " itself.  Therefore, it is the callback's responsibility to free the block"]
#[doc = " via a call to os_memblock_put_from_cb()."]
#[doc = ""]
#[doc = " @param ome                   The extended mempool that a block is being"]
#[doc = "                                  freed back to."]
#[doc = " @param data                  The block being freed."]
#[doc = " @param arg                   Optional argument configured along with the"]
#[doc = "                                  callback."]
#[doc = ""]
#[doc = " @return                      Indicates whether the block was successfully"]
#[doc = "                                  freed.  A non-zero value should only be"]
#[doc = "                                  returned if the block was not successfully"]
#[doc = "                                  released back to its pool."]
pub type os_mempool_put_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ome: *mut os_mempool_ext,
        data: *mut ::core::ffi::c_void,
        arg: *mut ::core::ffi::c_void,
    ) -> os_error_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_mempool_ext {
    pub mpe_mp: os_mempool,
    pub mpe_put_cb: os_mempool_put_fn,
    pub mpe_put_arg: *mut ::core::ffi::c_void,
}
#[doc = " Information describing a memory pool, used to return OS information"]
#[doc = " to the management layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct os_mempool_info {
    #[doc = " Size of the memory blocks in the pool"]
    pub omi_block_size: ::std::os::raw::c_int,
    #[doc = " Number of memory blocks in the pool"]
    pub omi_num_blocks: ::std::os::raw::c_int,
    #[doc = " Number of free memory blocks"]
    pub omi_num_free: ::std::os::raw::c_int,
    #[doc = " Minimum number of free memory blocks ever"]
    pub omi_min_free: ::std::os::raw::c_int,
    #[doc = " Name of the memory pool"]
    pub omi_name: [::std::os::raw::c_char; 32usize],
}
extern "C" {
    #[doc = " Get information about the next system memory pool."]
    #[doc = ""]
    #[doc = " @param mempool The current memory pool, or NULL if starting iteration."]
    #[doc = " @param info    A pointer to the structure to return memory pool information"]
    #[doc = "                into."]
    #[doc = ""]
    #[doc = " @return The next memory pool in the list to get information about, or NULL"]
    #[doc = "         when at the last memory pool."]
    pub fn os_mempool_info_get_next(
        arg1: *mut os_mempool,
        arg2: *mut os_mempool_info,
    ) -> *mut os_mempool;
}
pub type os_membuf_t = u32;
extern "C" {
    #[doc = " Initialize a memory pool."]
    #[doc = ""]
    #[doc = " @param mp            Pointer to a pointer to a mempool"]
    #[doc = " @param blocks        The number of blocks in the pool"]
    #[doc = " @param blocks_size   The size of the block, in bytes."]
    #[doc = " @param membuf        Pointer to memory to contain blocks."]
    #[doc = " @param name          Name of the pool."]
    #[doc = ""]
    #[doc = " @return os_error_t"]
    pub fn os_mempool_init(
        mp: *mut os_mempool,
        blocks: u16,
        block_size: u32,
        membuf: *mut ::core::ffi::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> os_error_t;
}
extern "C" {
    #[doc = " Initializes an extended memory pool.  Extended attributes (e.g., callbacks)"]
    #[doc = " are not specified when this function is called; they are assigned manually"]
    #[doc = " after initialization."]
    #[doc = ""]
    #[doc = " @param mpe           The extended memory pool to initialize."]
    #[doc = " @param blocks        The number of blocks in the pool."]
    #[doc = " @param block_size    The size of each block, in bytes."]
    #[doc = " @param membuf        Pointer to memory to contain blocks."]
    #[doc = " @param name          Name of the pool."]
    #[doc = ""]
    #[doc = " @return os_error_t"]
    pub fn os_mempool_ext_init(
        mpe: *mut os_mempool_ext,
        blocks: u16,
        block_size: u32,
        membuf: *mut ::core::ffi::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> os_error_t;
}
extern "C" {
    #[doc = " Clears a memory pool."]
    #[doc = ""]
    #[doc = " @param mp            The mempool to clear."]
    #[doc = ""]
    #[doc = " @return os_error_t"]
    pub fn os_mempool_clear(mp: *mut os_mempool) -> os_error_t;
}
extern "C" {
    #[doc = " Clears an extended memory pool."]
    #[doc = ""]
    #[doc = " @param mpe            The extended memory pool to clear."]
    #[doc = ""]
    #[doc = " @return os_error_t"]
    pub fn os_mempool_ext_clear(mpe: *mut os_mempool_ext) -> os_error_t;
}
extern "C" {
    #[doc = " Performs an integrity check of the specified mempool.  This function"]
    #[doc = " attempts to detect memory corruption in the specified memory pool."]
    #[doc = ""]
    #[doc = " @param mp                    The mempool to check."]
    #[doc = ""]
    #[doc = " @return                      true if the memory pool passes the integrity"]
    #[doc = "                                  check;"]
    #[doc = "                              false if the memory pool is corrupt."]
    pub fn os_mempool_is_sane(mp: *const os_mempool) -> bool;
}
extern "C" {
    #[doc = " Checks if a memory block was allocated from the specified mempool."]
    #[doc = ""]
    #[doc = " @param mp                    The mempool to check as parent."]
    #[doc = " @param block_addr            The memory block to check as child."]
    #[doc = ""]
    #[doc = " @return                      0 if the block does not belong to the mempool;"]
    #[doc = "                              1 if the block does belong to the mempool."]
    pub fn os_memblock_from(
        mp: *const os_mempool,
        block_addr: *const ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a memory block from a memory pool"]
    #[doc = ""]
    #[doc = " @param mp Pointer to the memory pool"]
    #[doc = ""]
    #[doc = " @return void* Pointer to block if available; NULL otherwise"]
    pub fn os_memblock_get(mp: *mut os_mempool) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Puts the memory block back into the pool, ignoring the put callback, if any."]
    #[doc = " This function should only be called from a put callback to free a block"]
    #[doc = " without causing infinite recursion."]
    #[doc = ""]
    #[doc = " @param mp Pointer to memory pool"]
    #[doc = " @param block_addr Pointer to memory block"]
    #[doc = ""]
    #[doc = " @return os_error_t"]
    pub fn os_memblock_put_from_cb(
        mp: *mut os_mempool,
        block_addr: *mut ::core::ffi::c_void,
    ) -> os_error_t;
}
extern "C" {
    #[doc = " Puts the memory block back into the pool"]
    #[doc = ""]
    #[doc = " @param mp Pointer to memory pool"]
    #[doc = " @param block_addr Pointer to memory block"]
    #[doc = ""]
    #[doc = " @return os_error_t"]
    pub fn os_memblock_put(mp: *mut os_mempool, block_addr: *mut ::core::ffi::c_void)
        -> os_error_t;
}
#[doc = " Callback function types; executed when HCI packets are received."]
pub type ble_hci_trans_rx_cmd_fn = ::core::option::Option<
    unsafe extern "C" fn(cmd: *mut u8, arg: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int,
>;
pub type ble_hci_trans_rx_acl_fn = ::core::option::Option<
    unsafe extern "C" fn(om: *mut os_mbuf, arg: *mut ::core::ffi::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Sends an HCI event from the controller to the host."]
    #[doc = ""]
    #[doc = " @param cmd                   The HCI event to send.  This buffer must be"]
    #[doc = "                                  allocated via ble_hci_trans_buf_alloc()."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              A BLE_ERR_[...] error code on failure."]
    pub fn ble_hci_trans_ll_evt_tx(hci_ev: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sends ACL data from controller to host."]
    #[doc = ""]
    #[doc = " @param om                    The ACL data packet to send."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              A BLE_ERR_[...] error code on failure."]
    pub fn ble_hci_trans_ll_acl_tx(om: *mut os_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sends an HCI command from the host to the controller."]
    #[doc = ""]
    #[doc = " @param cmd                   The HCI command to send.  This buffer must be"]
    #[doc = "                                  allocated via ble_hci_trans_buf_alloc()."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              A BLE_ERR_[...] error code on failure."]
    pub fn ble_hci_trans_hs_cmd_tx(cmd: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sends ACL data from host to controller."]
    #[doc = ""]
    #[doc = " @param om                    The ACL data packet to send."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              A BLE_ERR_[...] error code on failure."]
    pub fn ble_hci_trans_hs_acl_tx(om: *mut os_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocates a flat buffer of the specified type."]
    #[doc = ""]
    #[doc = " @param type                  The type of buffer to allocate; one of the"]
    #[doc = "                                  BLE_HCI_TRANS_BUF_[...] constants."]
    #[doc = ""]
    #[doc = " @return                      The allocated buffer on success;"]
    #[doc = "                              NULL on buffer exhaustion."]
    pub fn ble_hci_trans_buf_alloc(type_: ::std::os::raw::c_int) -> *mut u8;
}
extern "C" {
    #[doc = " Frees the specified flat buffer.  The buffer must have been allocated via"]
    #[doc = " ble_hci_trans_buf_alloc()."]
    #[doc = ""]
    #[doc = " @param buf                   The buffer to free."]
    pub fn ble_hci_trans_buf_free(buf: *mut u8);
}
extern "C" {
    #[doc = " Configures a callback to get executed whenever an ACL data packet is freed."]
    #[doc = " The function is called immediately before the free occurs."]
    #[doc = ""]
    #[doc = " @param cb                    The callback to configure."]
    #[doc = " @param arg                   An optional argument to pass to the callback."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_ERR_UNSUPPORTED if the transport does not"]
    #[doc = "                                  support this operation."]
    pub fn ble_hci_trans_set_acl_free_cb(
        cb: os_mempool_put_fn,
        arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configures the HCI transport to operate with a controller.  The transport"]
    #[doc = " will execute specified callbacks upon receiving HCI packets from the host."]
    #[doc = ""]
    #[doc = " @param cmd_cb                The callback to execute upon receiving an HCI"]
    #[doc = "                                  command."]
    #[doc = " @param cmd_arg               Optional argument to pass to the command"]
    #[doc = "                                  callback."]
    #[doc = " @param acl_cb                The callback to execute upon receiving ACL"]
    #[doc = "                                  data."]
    #[doc = " @param acl_arg               Optional argument to pass to the ACL"]
    #[doc = "                                  callback."]
    pub fn ble_hci_trans_cfg_ll(
        cmd_cb: ble_hci_trans_rx_cmd_fn,
        cmd_arg: *mut ::core::ffi::c_void,
        acl_cb: ble_hci_trans_rx_acl_fn,
        acl_arg: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Configures the HCI transport to operate with a host.  The transport will"]
    #[doc = " execute specified callbacks upon receiving HCI packets from the controller."]
    #[doc = ""]
    #[doc = " @param evt_cb                The callback to execute upon receiving an HCI"]
    #[doc = "                                  event."]
    #[doc = " @param evt_arg               Optional argument to pass to the event"]
    #[doc = "                                  callback."]
    #[doc = " @param acl_cb                The callback to execute upon receiving ACL"]
    #[doc = "                                  data."]
    #[doc = " @param acl_arg               Optional argument to pass to the ACL"]
    #[doc = "                                  callback."]
    pub fn ble_hci_trans_cfg_hs(
        evt_cb: ble_hci_trans_rx_cmd_fn,
        evt_arg: *mut ::core::ffi::c_void,
        acl_cb: ble_hci_trans_rx_acl_fn,
        acl_arg: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " Resets the HCI module to a clean state.  Frees all buffers and reinitializes"]
    #[doc = " the underlying transport."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              A BLE_ERR_[...] error code on failure."]
    pub fn ble_hci_trans_reset() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Initialize VHCI transport layer between NimBLE Host and"]
    #[doc = " ESP Bluetooth controller"]
    #[doc = ""]
    #[doc = " This function initializes the transport buffers to be exchanged"]
    #[doc = " between NimBLE host and ESP controller. It also registers required"]
    #[doc = " host callbacks with the controller."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK if the initialization is successful"]
    #[doc = "    - Appropriate error code from esp_err_t in case of an error"]
    pub fn esp_nimble_hci_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Initialize ESP Bluetooth controller(link layer) and VHCI transport"]
    #[doc = " layer between NimBLE Host and ESP Bluetooth controller"]
    #[doc = ""]
    #[doc = " This function initializes ESP controller in BLE only mode and the"]
    #[doc = " transport buffers to be exchanged between NimBLE host and ESP controller."]
    #[doc = " It also registers required host callbacks with the controller."]
    #[doc = ""]
    #[doc = " Below is the sequence of APIs to be called to init/enable NimBLE host and ESP controller:"]
    #[doc = ""]
    #[doc = " @code{c}"]
    #[doc = " void ble_host_task(void *param)"]
    #[doc = " {"]
    #[doc = "      nimble_port_run(); //This function will return only when nimble_port_stop() is executed."]
    #[doc = "      nimble_port_freertos_deinit();"]
    #[doc = " }"]
    #[doc = ""]
    #[doc = " int ret = esp_nimble_hci_and_controller_init();"]
    #[doc = " if (ret != ESP_OK) {"]
    #[doc = "ESP_LOGE(TAG, \"esp_nimble_hci_and_controller_init() failed with error: %d\", ret);"]
    #[doc = "      return;"]
    #[doc = " }"]
    #[doc = ""]
    #[doc = " nimble_port_init();"]
    #[doc = ""]
    #[doc = " //Initialize the NimBLE Host configuration"]
    #[doc = ""]
    #[doc = " nimble_port_freertos_init(ble_host_task);"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " nimble_port_freertos_init() is an optional call that creates a new task in which the NimBLE"]
    #[doc = " host will run. The task function should have a call to nimble_port_run(). If a separate task"]
    #[doc = " is not required, calling nimble_port_run() will run the NimBLE host in the current task."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK if the initialization is successful"]
    #[doc = "    - Appropriate error code from esp_err_t in case of an error"]
    pub fn esp_nimble_hci_and_controller_init() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize VHCI transport layer between NimBLE Host and"]
    #[doc = " ESP Bluetooth controller"]
    #[doc = ""]
    #[doc = " @note This function should be called after the NimBLE host is deinitialized."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK if the deinitialization is successful"]
    #[doc = "    - Appropriate error codes from esp_err_t in case of an error"]
    pub fn esp_nimble_hci_deinit() -> esp_err_t;
}
extern "C" {
    #[doc = " @brief Deinitialize VHCI transport layer between NimBLE Host and"]
    #[doc = " ESP Bluetooth controller and disable and deinitialize the controller"]
    #[doc = ""]
    #[doc = " @note This function should not be executed in the context of Bluetooth host task."]
    #[doc = ""]
    #[doc = " @note This function should be called after the NimBLE host is deinitialized."]
    #[doc = ""]
    #[doc = " Below is the sequence of APIs to be called to disable/deinit NimBLE host and ESP controller:"]
    #[doc = ""]
    #[doc = " @code{c}"]
    #[doc = " int ret = nimble_port_stop();"]
    #[doc = " if (ret == 0) {"]
    #[doc = "      nimble_port_deinit();"]
    #[doc = ""]
    #[doc = "      ret = esp_nimble_hci_and_controller_deinit();"]
    #[doc = "      if (ret != ESP_OK) {"]
    #[doc = "ESP_LOGE(TAG, \"esp_nimble_hci_and_controller_deinit() failed with error: %d\", ret);"]
    #[doc = "      }"]
    #[doc = " }"]
    #[doc = " @endcode"]
    #[doc = ""]
    #[doc = " If nimble_port_freertos_init() is used during initialization, then"]
    #[doc = " nimble_port_freertos_deinit() should be called in the host task after nimble_port_run()."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    - ESP_OK if the deinitialization is successful"]
    #[doc = "    - Appropriate error codes from esp_err_t in case of an error"]
    pub fn esp_nimble_hci_and_controller_deinit() -> esp_err_t;
}
extern "C" {
    pub fn nimble_port_init();
}
extern "C" {
    pub fn nimble_port_deinit();
}
extern "C" {
    pub fn nimble_port_run();
}
extern "C" {
    pub fn nimble_port_stop() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nimble_port_get_dflt_eventq() -> *mut ble_npl_eventq;
}
extern "C" {
    pub fn nimble_port_freertos_init(host_task_fn: TaskFunction_t);
}
extern "C" {
    pub fn nimble_port_freertos_deinit();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_encryption_block {
    pub key: [u8; 16usize],
    pub plain_text: [u8; 16usize],
    pub cipher_text: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_mbuf_hdr_rxinfo {
    pub flags: u16,
    pub channel: u8,
    pub handle: u8,
    pub rssi: i8,
    pub phy: i8,
    pub phy_mode: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_mbuf_hdr_txinfo {
    pub flags: u8,
    pub offset: u8,
    pub pyld_len: u8,
    pub hdr_byte: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_mbuf_hdr {
    pub __bindgen_anon_1: ble_mbuf_hdr__bindgen_ty_1,
    pub beg_cputime: u32,
    pub rem_usecs: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_mbuf_hdr__bindgen_ty_1 {
    pub rxinfo: ble_mbuf_hdr_rxinfo,
    pub txinfo: ble_mbuf_hdr_txinfo,
    _bindgen_union_align: [u16; 4usize],
}
extern "C" {
    pub static mut g_dev_addr: [u8; 6usize];
}
extern "C" {
    pub static mut g_random_addr: [u8; 6usize];
}
pub const ble_error_codes_BLE_ERR_SUCCESS: ble_error_codes = 0;
pub const ble_error_codes_BLE_ERR_UNKNOWN_HCI_CMD: ble_error_codes = 1;
pub const ble_error_codes_BLE_ERR_UNK_CONN_ID: ble_error_codes = 2;
pub const ble_error_codes_BLE_ERR_HW_FAIL: ble_error_codes = 3;
pub const ble_error_codes_BLE_ERR_PAGE_TMO: ble_error_codes = 4;
pub const ble_error_codes_BLE_ERR_AUTH_FAIL: ble_error_codes = 5;
pub const ble_error_codes_BLE_ERR_PINKEY_MISSING: ble_error_codes = 6;
pub const ble_error_codes_BLE_ERR_MEM_CAPACITY: ble_error_codes = 7;
pub const ble_error_codes_BLE_ERR_CONN_SPVN_TMO: ble_error_codes = 8;
pub const ble_error_codes_BLE_ERR_CONN_LIMIT: ble_error_codes = 9;
pub const ble_error_codes_BLE_ERR_SYNCH_CONN_LIMIT: ble_error_codes = 10;
pub const ble_error_codes_BLE_ERR_ACL_CONN_EXISTS: ble_error_codes = 11;
pub const ble_error_codes_BLE_ERR_CMD_DISALLOWED: ble_error_codes = 12;
pub const ble_error_codes_BLE_ERR_CONN_REJ_RESOURCES: ble_error_codes = 13;
pub const ble_error_codes_BLE_ERR_CONN_REJ_SECURITY: ble_error_codes = 14;
pub const ble_error_codes_BLE_ERR_CONN_REJ_BD_ADDR: ble_error_codes = 15;
pub const ble_error_codes_BLE_ERR_CONN_ACCEPT_TMO: ble_error_codes = 16;
pub const ble_error_codes_BLE_ERR_UNSUPPORTED: ble_error_codes = 17;
pub const ble_error_codes_BLE_ERR_INV_HCI_CMD_PARMS: ble_error_codes = 18;
pub const ble_error_codes_BLE_ERR_REM_USER_CONN_TERM: ble_error_codes = 19;
pub const ble_error_codes_BLE_ERR_RD_CONN_TERM_RESRCS: ble_error_codes = 20;
pub const ble_error_codes_BLE_ERR_RD_CONN_TERM_PWROFF: ble_error_codes = 21;
pub const ble_error_codes_BLE_ERR_CONN_TERM_LOCAL: ble_error_codes = 22;
pub const ble_error_codes_BLE_ERR_REPEATED_ATTEMPTS: ble_error_codes = 23;
pub const ble_error_codes_BLE_ERR_NO_PAIRING: ble_error_codes = 24;
pub const ble_error_codes_BLE_ERR_UNK_LMP: ble_error_codes = 25;
pub const ble_error_codes_BLE_ERR_UNSUPP_REM_FEATURE: ble_error_codes = 26;
pub const ble_error_codes_BLE_ERR_SCO_OFFSET: ble_error_codes = 27;
pub const ble_error_codes_BLE_ERR_SCO_ITVL: ble_error_codes = 28;
pub const ble_error_codes_BLE_ERR_SCO_AIR_MODE: ble_error_codes = 29;
pub const ble_error_codes_BLE_ERR_INV_LMP_LL_PARM: ble_error_codes = 30;
pub const ble_error_codes_BLE_ERR_UNSPECIFIED: ble_error_codes = 31;
pub const ble_error_codes_BLE_ERR_UNSUPP_LMP_LL_PARM: ble_error_codes = 32;
pub const ble_error_codes_BLE_ERR_NO_ROLE_CHANGE: ble_error_codes = 33;
pub const ble_error_codes_BLE_ERR_LMP_LL_RSP_TMO: ble_error_codes = 34;
pub const ble_error_codes_BLE_ERR_LMP_COLLISION: ble_error_codes = 35;
pub const ble_error_codes_BLE_ERR_LMP_PDU: ble_error_codes = 36;
pub const ble_error_codes_BLE_ERR_ENCRYPTION_MODE: ble_error_codes = 37;
pub const ble_error_codes_BLE_ERR_LINK_KEY_CHANGE: ble_error_codes = 38;
pub const ble_error_codes_BLE_ERR_UNSUPP_QOS: ble_error_codes = 39;
pub const ble_error_codes_BLE_ERR_INSTANT_PASSED: ble_error_codes = 40;
pub const ble_error_codes_BLE_ERR_UNIT_KEY_PAIRING: ble_error_codes = 41;
pub const ble_error_codes_BLE_ERR_DIFF_TRANS_COLL: ble_error_codes = 42;
pub const ble_error_codes_BLE_ERR_QOS_PARM: ble_error_codes = 44;
pub const ble_error_codes_BLE_ERR_QOS_REJECTED: ble_error_codes = 45;
pub const ble_error_codes_BLE_ERR_CHAN_CLASS: ble_error_codes = 46;
pub const ble_error_codes_BLE_ERR_INSUFFICIENT_SEC: ble_error_codes = 47;
pub const ble_error_codes_BLE_ERR_PARM_OUT_OF_RANGE: ble_error_codes = 48;
pub const ble_error_codes_BLE_ERR_PENDING_ROLE_SW: ble_error_codes = 50;
pub const ble_error_codes_BLE_ERR_RESERVED_SLOT: ble_error_codes = 52;
pub const ble_error_codes_BLE_ERR_ROLE_SW_FAIL: ble_error_codes = 53;
pub const ble_error_codes_BLE_ERR_INQ_RSP_TOO_BIG: ble_error_codes = 54;
pub const ble_error_codes_BLE_ERR_SEC_SIMPLE_PAIR: ble_error_codes = 55;
pub const ble_error_codes_BLE_ERR_HOST_BUSY_PAIR: ble_error_codes = 56;
pub const ble_error_codes_BLE_ERR_CONN_REJ_CHANNEL: ble_error_codes = 57;
pub const ble_error_codes_BLE_ERR_CTLR_BUSY: ble_error_codes = 58;
pub const ble_error_codes_BLE_ERR_CONN_PARMS: ble_error_codes = 59;
pub const ble_error_codes_BLE_ERR_DIR_ADV_TMO: ble_error_codes = 60;
pub const ble_error_codes_BLE_ERR_CONN_TERM_MIC: ble_error_codes = 61;
pub const ble_error_codes_BLE_ERR_CONN_ESTABLISHMENT: ble_error_codes = 62;
pub const ble_error_codes_BLE_ERR_MAC_CONN_FAIL: ble_error_codes = 63;
pub const ble_error_codes_BLE_ERR_COARSE_CLK_ADJ: ble_error_codes = 64;
pub const ble_error_codes_BLE_ERR_TYPE0_SUBMAP_NDEF: ble_error_codes = 65;
pub const ble_error_codes_BLE_ERR_UNK_ADV_INDENT: ble_error_codes = 66;
pub const ble_error_codes_BLE_RR_LIMIT_REACHED: ble_error_codes = 67;
pub const ble_error_codes_BLE_ERR_MAX: ble_error_codes = 255;
pub type ble_error_codes = u32;
extern "C" {
    pub fn ble_err_from_os(os_err: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_addr_t {
    pub type_: u8,
    pub val: [u8; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_host_buf_size {
    pub acl_pkt_len: u16,
    pub sync_pkt_len: u8,
    pub num_acl_pkts: u16,
    pub num_sync_pkts: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_host_num_comp_pkts_entry {
    pub conn_handle: u16,
    pub num_pkts: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_loc_ver_info {
    pub status: u8,
    pub hci_version: u8,
    pub hci_revision: u16,
    pub lmp_pal_version: u8,
    pub mfrg_name: u16,
    pub lmp_pal_subversion: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_rand_addr {
    pub addr: [u8; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_adv_params {
    pub adv_type: u8,
    pub adv_channel_map: u8,
    pub own_addr_type: u8,
    pub peer_addr_type: u8,
    pub adv_filter_policy: u8,
    pub adv_itvl_min: u16,
    pub adv_itvl_max: u16,
    pub peer_addr: [u8; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_create_conn {
    pub scan_itvl: u16,
    pub scan_window: u16,
    pub filter_policy: u8,
    pub peer_addr_type: u8,
    pub peer_addr: [u8; 6usize],
    pub own_addr_type: u8,
    pub conn_itvl_min: u16,
    pub conn_itvl_max: u16,
    pub conn_latency: u16,
    pub supervision_timeout: u16,
    pub min_ce_len: u16,
    pub max_ce_len: u16,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct hci_le_subev_rd_loc_p256_pubkey {
    pub status: u8,
    pub pubkey: [u8; 64usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct hci_le_subev_gen_dhkey_complete {
    pub status: u8,
    pub dhkey: [u8; 32usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct hci_le_subev_direct_adv_rpt_param {
    pub evt_type: u8,
    pub addr_type: u8,
    pub addr: [u8; 6usize],
    pub dir_addr_type: u8,
    pub dir_addr: [u8; 6usize],
    pub rssi: i8,
}
#[repr(C, packed)]
#[derive(Debug)]
pub struct hci_le_subev_direct_adv_rpt {
    pub num_reports: u8,
    pub params: __IncompleteArrayField<hci_le_subev_direct_adv_rpt_param>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct hci_le_subev_chan_sel_alg {
    pub conn_handle: u16,
    pub chan_sel_alg: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_conn_update {
    pub handle: u16,
    pub conn_itvl_min: u16,
    pub conn_itvl_max: u16,
    pub conn_latency: u16,
    pub supervision_timeout: u16,
    pub min_ce_len: u16,
    pub max_ce_len: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_start_encrypt {
    pub connection_handle: u16,
    pub encrypted_diversifier: u16,
    pub random_number: u64,
    pub long_term_key: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_lt_key_req_reply {
    pub conn_handle: u16,
    pub long_term_key: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_conn_param_reply {
    pub handle: u16,
    pub conn_itvl_min: u16,
    pub conn_itvl_max: u16,
    pub conn_latency: u16,
    pub supervision_timeout: u16,
    pub min_ce_len: u16,
    pub max_ce_len: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_conn_param_neg_reply {
    pub handle: u16,
    pub reason: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_encrypt_change {
    pub status: u8,
    pub encryption_enabled: u8,
    pub connection_handle: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_encrypt_key_refresh {
    pub status: u8,
    pub connection_handle: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_le_conn_complete {
    pub subevent_code: u8,
    pub status: u8,
    pub connection_handle: u16,
    pub role: u8,
    pub peer_addr_type: u8,
    pub peer_addr: [u8; 6usize],
    pub conn_itvl: u16,
    pub conn_latency: u16,
    pub supervision_timeout: u16,
    pub master_clk_acc: u8,
    pub local_rpa: [u8; 6usize],
    pub peer_rpa: [u8; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_le_conn_upd_complete {
    pub subevent_code: u8,
    pub status: u8,
    pub connection_handle: u16,
    pub conn_itvl: u16,
    pub conn_latency: u16,
    pub supervision_timeout: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_le_conn_param_req {
    pub subevent_code: u8,
    pub connection_handle: u16,
    pub itvl_min: u16,
    pub itvl_max: u16,
    pub latency: u16,
    pub timeout: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_le_rd_rem_supp_feat_complete {
    pub subevent_code: u8,
    pub status: u8,
    pub connection_handle: u16,
    pub features: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_le_lt_key_req {
    pub random_number: u64,
    pub connection_handle: u16,
    pub encrypted_diversifier: u16,
    pub subevent_code: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_disconn_complete {
    pub connection_handle: u16,
    pub status: u8,
    pub reason: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_read_rssi_ack_params {
    pub connection_handle: u16,
    pub status: u8,
    pub rssi: i8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_le_phy_upd_complete {
    pub subevent_code: u8,
    pub status: u8,
    pub connection_handle: u16,
    pub tx_phy: u8,
    pub rx_phy: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_le_adv_set_terminated {
    pub subevent_code: u8,
    pub status: u8,
    pub adv_handle: u8,
    pub conn_handle: u16,
    pub completed_events: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_data_hdr {
    pub hdh_handle_pb_bc: u16,
    pub hdh_len: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hci_add_dev_to_resolving_list {
    pub addr_type: u8,
    pub addr: [u8; 6usize],
    pub local_irk: [u8; 16usize],
    pub peer_irk: [u8; 16usize],
}
extern "C" {
    pub static g_ble_hci_le_cmd_len: [u8; 79usize];
}
extern "C" {
    #[doc = " Reads a locally registered attribute.  If the specified attribute handle"]
    #[doc = " corresponds to a GATT characteristic value or descriptor, the read is"]
    #[doc = " performed by calling the registered GATT access callback."]
    #[doc = ""]
    #[doc = " @param attr_handle           The 16-bit handle of the attribute to read."]
    #[doc = " @param out_om                On success, this is made to point to a"]
    #[doc = "                                  newly-allocated mbuf containing the"]
    #[doc = "                                  attribute data read."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              NimBLE host ATT return code if the attribute"]
    #[doc = "                                  access callback reports failure;"]
    #[doc = "                              NimBLE host core return code on unexpected"]
    #[doc = "                                  error."]
    pub fn ble_att_svr_read_local(
        attr_handle: u16,
        out_om: *mut *mut os_mbuf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Writes a locally registered attribute.  This function consumes the supplied"]
    #[doc = " mbuf regardless of the outcome.  If the specified attribute handle"]
    #[doc = " corresponds to a GATT characteristic value or descriptor, the write is"]
    #[doc = " performed by calling the registered GATT access callback."]
    #[doc = ""]
    #[doc = " @param attr_handle           The 16-bit handle of the attribute to write."]
    #[doc = " @param om                    The value to write to the attribute."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              NimBLE host ATT return code if the attribute"]
    #[doc = "                                  access callback reports failure;"]
    #[doc = "                              NimBLE host core return code on unexpected"]
    #[doc = "                                  error."]
    pub fn ble_att_svr_write_local(attr_handle: u16, om: *mut os_mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieves the ATT MTU of the specified connection.  If an MTU exchange for"]
    #[doc = " this connection has occurred, the MTU is the lower of the two peers'"]
    #[doc = " preferred values.  Otherwise, the MTU is the default value of 23."]
    #[doc = ""]
    #[doc = " @param conn_handle           The handle of the connection to query."]
    #[doc = ""]
    #[doc = " @return                      The specified connection's ATT MTU, or 0 if"]
    #[doc = "                                  there is no such connection."]
    pub fn ble_att_mtu(conn_handle: u16) -> u16;
}
extern "C" {
    #[doc = " Retrieves the preferred ATT MTU.  This is the value indicated by the device"]
    #[doc = " during an ATT MTU exchange."]
    #[doc = ""]
    #[doc = " @return                      The preferred ATT MTU."]
    pub fn ble_att_preferred_mtu() -> u16;
}
extern "C" {
    #[doc = " Sets the preferred ATT MTU; the device will indicate this value in all"]
    #[doc = " subsequent ATT MTU exchanges.  The ATT MTU of a connection is equal to the"]
    #[doc = " lower of the two peers' preferred MTU values.  The ATT MTU is what dictates"]
    #[doc = " the maximum size of any message sent during a GATT procedure."]
    #[doc = ""]
    #[doc = " The specified MTU must be within the following range: [23, BLE_ATT_MTU_MAX]."]
    #[doc = " 23 is a minimum imposed by the Bluetooth specification; BLE_ATT_MTU_MAX is a"]
    #[doc = " NimBLE compile-time setting."]
    #[doc = ""]
    #[doc = " @param mtu                   The preferred ATT MTU."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_EINVAL if the specified value is not"]
    #[doc = "                                  within the allowed range."]
    pub fn ble_att_set_preferred_mtu(mtu: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configures the device to advertise Eddystone UID beacons."]
    #[doc = ""]
    #[doc = " @param adv_fields            The base advertisement fields to transform into"]
    #[doc = "                                  an eddystone beacon.  All configured fields"]
    #[doc = "                                  are preserved; you probably want to clear"]
    #[doc = "                                  this struct before calling this function."]
    #[doc = " @param uid                   The 16-byte UID to advertise."]
    #[doc = " @param measured_power        The Measured Power (RSSI value at 0 Meter)."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_EBUSY if advertising is in progress;"]
    #[doc = "                              BLE_HS_EMSGSIZE if the specified data is too"]
    #[doc = "                                  large to fit in an advertisement;"]
    #[doc = "                              Other nonzero on failure."]
    pub fn ble_eddystone_set_adv_data_uid(
        adv_fields: *mut ble_hs_adv_fields,
        uid: *mut ::core::ffi::c_void,
        measured_power: i8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configures the device to advertise Eddystone URL beacons."]
    #[doc = ""]
    #[doc = " @param adv_fields            The base advertisement fields to transform into"]
    #[doc = "                                  an eddystone beacon.  All configured fields"]
    #[doc = "                                  are preserved; you probably want to clear"]
    #[doc = "                                  this struct before calling this function."]
    #[doc = " @param url_scheme            The prefix of the URL; one of the"]
    #[doc = "                                  BLE_EDDYSTONE_URL_SCHEME values."]
    #[doc = " @param url_body              The middle of the URL.  Don't include the"]
    #[doc = "                                  suffix if there is a suitable suffix code."]
    #[doc = " @param url_body_len          The string length of the url_body argument."]
    #[doc = " @param url_suffix            The suffix of the URL; one of the"]
    #[doc = "                                  BLE_EDDYSTONE_URL_SUFFIX values; use"]
    #[doc = "                                  BLE_EDDYSTONE_URL_SUFFIX_NONE if the suffix"]
    #[doc = "                                  is embedded in the body argument."]
    #[doc = " @param measured_power        The Measured Power (RSSI value at 0 Meter)."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_EBUSY if advertising is in progress;"]
    #[doc = "                              BLE_HS_EMSGSIZE if the specified data is too"]
    #[doc = "                                  large to fit in an advertisement;"]
    #[doc = "                              Other nonzero on failure."]
    pub fn ble_eddystone_set_adv_data_url(
        adv_fields: *mut ble_hs_adv_fields,
        url_scheme: u8,
        url_body: *mut ::std::os::raw::c_char,
        url_body_len: u8,
        suffix: u8,
        measured_power: i8,
    ) -> ::std::os::raw::c_int;
}
#[doc = " 16-bit UUID (BT SIG assigned)"]
pub const BLE_UUID_TYPE_16: _bindgen_ty_1 = 16;
#[doc = " 32-bit UUID (BT SIG assigned)"]
pub const BLE_UUID_TYPE_32: _bindgen_ty_1 = 32;
#[doc = " 128-bit UUID"]
pub const BLE_UUID_TYPE_128: _bindgen_ty_1 = 128;
#[doc = " Type of UUID"]
pub type _bindgen_ty_1 = u32;
#[doc = " Generic UUID type, to be used only as a pointer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_uuid_t {
    #[doc = " Type of the UUID"]
    pub type_: u8,
}
#[doc = " 16-bit UUID"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_uuid16_t {
    pub u: ble_uuid_t,
    pub value: u16,
}
#[doc = " 32-bit UUID"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_uuid32_t {
    pub u: ble_uuid_t,
    pub value: u32,
}
#[doc = " 128-bit UUID"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_uuid128_t {
    pub u: ble_uuid_t,
    pub value: [u8; 16usize],
}
#[doc = " Universal UUID type, to be used for any-UUID static allocation"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_uuid_any_t {
    pub u: ble_uuid_t,
    pub u16: ble_uuid16_t,
    pub u32: ble_uuid32_t,
    pub u128: ble_uuid128_t,
    _bindgen_union_align: [u32; 5usize],
}
extern "C" {
    #[doc = " @brief Constructs a UUID object from a byte array."]
    #[doc = ""]
    #[doc = " @param uuid  On success, this gets populated with the constructed UUID."]
    #[doc = " @param buf   The source buffer to parse."]
    #[doc = " @param len   The size of the buffer, in bytes."]
    #[doc = ""]
    #[doc = " @return      0 on success, BLE_HS_EINVAL if the source buffer does not contain"]
    #[doc = "              a valid UUID."]
    pub fn ble_uuid_init_from_buf(
        uuid: *mut ble_uuid_any_t,
        buf: *const ::core::ffi::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Compares two Bluetooth UUIDs."]
    #[doc = ""]
    #[doc = " @param uuid1  The first UUID to compare."]
    #[doc = " @param uuid2  The second UUID to compare."]
    #[doc = ""]
    #[doc = " @return       0 if the two UUIDs are equal, nonzero if the UUIDs differ."]
    pub fn ble_uuid_cmp(
        uuid1: *const ble_uuid_t,
        uuid2: *const ble_uuid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Copy Bluetooth UUID"]
    #[doc = ""]
    #[doc = " @param dst    Destination UUID."]
    #[doc = " @param src    Source UUID."]
    pub fn ble_uuid_copy(dst: *mut ble_uuid_any_t, src: *const ble_uuid_t);
}
extern "C" {
    #[doc = " @brief Converts the specified UUID to its string representation."]
    #[doc = ""]
    #[doc = " Example string representations:"]
    #[doc = "     o 16-bit:  0x1234"]
    #[doc = "     o 32-bit:  0x12345678"]
    #[doc = "     o 128-bit: 12345678-1234-1234-1234-123456789abc"]
    #[doc = ""]
    #[doc = " @param uuid   The source UUID to convert."]
    #[doc = " @param dst    The destination buffer."]
    #[doc = ""]
    #[doc = " @return       A pointer to the supplied destination buffer."]
    pub fn ble_uuid_to_str(
        uuid: *const ble_uuid_t,
        dst: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Converts the specified 16-bit UUID to a uint16_t."]
    #[doc = ""]
    #[doc = " @param uuid   The source UUID to convert."]
    #[doc = ""]
    #[doc = " @return       The converted integer on success, NULL if the specified UUID is"]
    #[doc = "               not 16 bits."]
    pub fn ble_uuid_u16(uuid: *const ble_uuid_t) -> u16;
}
#[repr(C)]
#[derive(Debug)]
pub struct ble_hs_adv_field {
    pub length: u8,
    pub type_: u8,
    pub value: __IncompleteArrayField<u8>,
}
pub type ble_hs_adv_parse_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ble_hs_adv_field,
        arg2: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_hs_adv_fields {
    #[doc = " 0x01 - Flags."]
    pub flags: u8,
    #[doc = " 0x02,0x03 - 16-bit service class UUIDs."]
    pub uuids16: *mut ble_uuid16_t,
    pub num_uuids16: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = " 0x04,0x05 - 32-bit service class UUIDs."]
    pub uuids32: *mut ble_uuid32_t,
    pub num_uuids32: u8,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = " 0x06,0x07 - 128-bit service class UUIDs."]
    pub uuids128: *mut ble_uuid128_t,
    pub num_uuids128: u8,
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = " 0x08,0x09 - Local name."]
    pub name: *mut u8,
    pub name_len: u8,
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = " 0x0a - Tx power level."]
    pub tx_pwr_lvl: i8,
    pub _bitfield_5: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = " 0x0d - Slave connection interval range."]
    pub slave_itvl_range: *mut u8,
    #[doc = " 0x16 - Service data - 16-bit UUID."]
    pub svc_data_uuid16: *mut u8,
    pub svc_data_uuid16_len: u8,
    #[doc = " 0x17 - Public target address."]
    pub public_tgt_addr: *mut u8,
    pub num_public_tgt_addrs: u8,
    #[doc = " 0x19 - Appearance."]
    pub appearance: u16,
    pub _bitfield_6: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = " 0x1a - Advertising interval."]
    pub adv_itvl: u16,
    pub _bitfield_7: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = " 0x20 - Service data - 32-bit UUID."]
    pub svc_data_uuid32: *mut u8,
    pub svc_data_uuid32_len: u8,
    #[doc = " 0x21 - Service data - 128-bit UUID."]
    pub svc_data_uuid128: *mut u8,
    pub svc_data_uuid128_len: u8,
    #[doc = " 0x24 - URI."]
    pub uri: *mut u8,
    pub uri_len: u8,
    #[doc = " 0xff - Manufacturer specific data."]
    pub mfg_data: *mut u8,
    pub mfg_data_len: u8,
}
impl ble_hs_adv_fields {
    #[inline]
    pub fn uuids16_is_complete(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uuids16_is_complete(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        uuids16_is_complete: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let uuids16_is_complete: u32 = unsafe { ::core::mem::transmute(uuids16_is_complete) };
            uuids16_is_complete as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn uuids32_is_complete(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uuids32_is_complete(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        uuids32_is_complete: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let uuids32_is_complete: u32 = unsafe { ::core::mem::transmute(uuids32_is_complete) };
            uuids32_is_complete as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn uuids128_is_complete(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uuids128_is_complete(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        uuids128_is_complete: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let uuids128_is_complete: u32 = unsafe { ::core::mem::transmute(uuids128_is_complete) };
            uuids128_is_complete as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn name_is_complete(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_name_is_complete(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_4.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_4(
        name_is_complete: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let name_is_complete: u32 = unsafe { ::core::mem::transmute(name_is_complete) };
            name_is_complete as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn tx_pwr_lvl_is_present(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_5.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tx_pwr_lvl_is_present(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_5.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_5(
        tx_pwr_lvl_is_present: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tx_pwr_lvl_is_present: u32 =
                unsafe { ::core::mem::transmute(tx_pwr_lvl_is_present) };
            tx_pwr_lvl_is_present as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn appearance_is_present(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_6.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_appearance_is_present(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_6.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_6(
        appearance_is_present: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let appearance_is_present: u32 =
                unsafe { ::core::mem::transmute(appearance_is_present) };
            appearance_is_present as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn adv_itvl_is_present(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_7.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adv_itvl_is_present(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_7.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_7(
        adv_itvl_is_present: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let adv_itvl_is_present: u32 = unsafe { ::core::mem::transmute(adv_itvl_is_present) };
            adv_itvl_is_present as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn ble_hs_adv_set_fields_mbuf(
        adv_fields: *const ble_hs_adv_fields,
        om: *mut os_mbuf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_hs_adv_set_fields(
        adv_fields: *const ble_hs_adv_fields,
        dst: *mut u8,
        dst_len: *mut u8,
        max_len: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_hs_adv_parse_fields(
        adv_fields: *mut ble_hs_adv_fields,
        src: *mut u8,
        src_len: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_hs_adv_parse(
        data: *const u8,
        length: u8,
        func: ble_hs_adv_parse_func_t,
        user_data: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Connection security state"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_sec_state {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl ble_gap_sec_state {
    #[inline]
    pub fn encrypted(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_encrypted(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn authenticated(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_authenticated(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bonded(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bonded(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn key_size(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_key_size(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        encrypted: ::std::os::raw::c_uint,
        authenticated: ::std::os::raw::c_uint,
        bonded: ::std::os::raw::c_uint,
        key_size: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let encrypted: u32 = unsafe { ::core::mem::transmute(encrypted) };
            encrypted as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let authenticated: u32 = unsafe { ::core::mem::transmute(authenticated) };
            authenticated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bonded: u32 = unsafe { ::core::mem::transmute(bonded) };
            bonded as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let key_size: u32 = unsafe { ::core::mem::transmute(key_size) };
            key_size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Advertising parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_adv_params {
    #[doc = " Advertising mode. Can be one of following constants:"]
    #[doc = "  - BLE_GAP_CONN_MODE_NON (non-connectable; 3.C.9.3.2)."]
    #[doc = "  - BLE_GAP_CONN_MODE_DIR (directed-connectable; 3.C.9.3.3)."]
    #[doc = "  - BLE_GAP_CONN_MODE_UND (undirected-connectable; 3.C.9.3.4)."]
    pub conn_mode: u8,
    #[doc = " Discoverable mode. Can be one of following constants:"]
    #[doc = "  - BLE_GAP_DISC_MODE_NON  (non-discoverable; 3.C.9.2.2)."]
    #[doc = "  - BLE_GAP_DISC_MODE_LTD (limited-discoverable; 3.C.9.2.3)."]
    #[doc = "  - BLE_GAP_DISC_MODE_GEN (general-discoverable; 3.C.9.2.4)."]
    pub disc_mode: u8,
    #[doc = " Minimum advertising interval, if 0 stack use sane defaults"]
    pub itvl_min: u16,
    #[doc = " Maximum advertising interval, if 0 stack use sane defaults"]
    pub itvl_max: u16,
    #[doc = " Advertising channel map , if 0 stack use sane defaults"]
    pub channel_map: u8,
    #[doc = " Advertising  Filter policy"]
    pub filter_policy: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
impl ble_gap_adv_params {
    #[inline]
    pub fn high_duty_cycle(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_high_duty_cycle(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(high_duty_cycle: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let high_duty_cycle: u8 = unsafe { ::core::mem::transmute(high_duty_cycle) };
            high_duty_cycle as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " @brief Connection descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_conn_desc {
    #[doc = " Connection security state"]
    pub sec_state: ble_gap_sec_state,
    #[doc = " Local identity address"]
    pub our_id_addr: ble_addr_t,
    #[doc = " Peer identity address"]
    pub peer_id_addr: ble_addr_t,
    #[doc = " Local over-the-air address"]
    pub our_ota_addr: ble_addr_t,
    #[doc = " Peer over-the-air address"]
    pub peer_ota_addr: ble_addr_t,
    #[doc = " Connection handle"]
    pub conn_handle: u16,
    #[doc = " Connection interval"]
    pub conn_itvl: u16,
    #[doc = " Connection latency"]
    pub conn_latency: u16,
    #[doc = " Connection supervision timeout"]
    pub supervision_timeout: u16,
    #[doc = " Connection Role"]
    #[doc = " Possible values BLE_GAP_ROLE_SLAVE or BLE_GAP_ROLE_MASTER"]
    pub role: u8,
    #[doc = " Master clock accuracy"]
    pub master_clock_accuracy: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_conn_params {
    pub scan_itvl: u16,
    pub scan_window: u16,
    pub itvl_min: u16,
    pub itvl_max: u16,
    pub latency: u16,
    pub supervision_timeout: u16,
    pub min_ce_len: u16,
    pub max_ce_len: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_ext_disc_params {
    pub itvl: u16,
    pub window: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
impl ble_gap_ext_disc_params {
    #[inline]
    pub fn passive(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_passive(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(passive: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let passive: u8 = unsafe { ::core::mem::transmute(passive) };
            passive as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_disc_params {
    pub itvl: u16,
    pub window: u16,
    pub filter_policy: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl ble_gap_disc_params {
    #[inline]
    pub fn limited(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_limited(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn passive(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_passive(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filter_duplicates(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_filter_duplicates(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        limited: u8,
        passive: u8,
        filter_duplicates: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let limited: u8 = unsafe { ::core::mem::transmute(limited) };
            limited as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let passive: u8 = unsafe { ::core::mem::transmute(passive) };
            passive as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let filter_duplicates: u8 = unsafe { ::core::mem::transmute(filter_duplicates) };
            filter_duplicates as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_upd_params {
    pub itvl_min: u16,
    pub itvl_max: u16,
    pub latency: u16,
    pub supervision_timeout: u16,
    pub min_ce_len: u16,
    pub max_ce_len: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_passkey_params {
    pub action: u8,
    pub numcmp: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_disc_desc {
    #[doc = " Common fields."]
    pub event_type: u8,
    pub length_data: u8,
    pub addr: ble_addr_t,
    pub rssi: i8,
    pub data: *mut u8,
    #[doc = " LE direct advertising report fields; direct_addr is BLE_ADDR_ANY if"]
    #[doc = " direct address fields are not present."]
    pub direct_addr: ble_addr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_repeat_pairing {
    #[doc = " The handle of the relevant connection."]
    pub conn_handle: u16,
    #[doc = " Properties of the existing bond."]
    pub cur_key_size: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = " Properties of the imminent secure link if the pairing procedure is"]
    #[doc = " allowed to continue."]
    pub new_key_size: u8,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl ble_gap_repeat_pairing {
    #[inline]
    pub fn cur_authenticated(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cur_authenticated(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cur_sc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cur_sc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cur_authenticated: u8,
        cur_sc: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cur_authenticated: u8 = unsafe { ::core::mem::transmute(cur_authenticated) };
            cur_authenticated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cur_sc: u8 = unsafe { ::core::mem::transmute(cur_sc) };
            cur_sc as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_authenticated(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_new_authenticated(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_sc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_new_sc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bonding(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_new_bonding(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        new_authenticated: u8,
        new_sc: u8,
        new_bonding: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let new_authenticated: u8 = unsafe { ::core::mem::transmute(new_authenticated) };
            new_authenticated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let new_sc: u8 = unsafe { ::core::mem::transmute(new_sc) };
            new_sc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let new_bonding: u8 = unsafe { ::core::mem::transmute(new_bonding) };
            new_bonding as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Represents a GAP-related event.  When such an event occurs, the host"]
#[doc = " notifies the application by passing an instance of this structure to an"]
#[doc = " application-specified callback."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_gap_event {
    #[doc = " Indicates the type of GAP event that occurred.  This is one of the"]
    #[doc = " BLE_GAP_EVENT codes."]
    pub type_: u8,
    pub __bindgen_anon_1: ble_gap_event__bindgen_ty_1,
}
#[doc = " A discriminated union containing additional details concerning the GAP"]
#[doc = " event.  The 'type' field indicates which member of the union is valid."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_gap_event__bindgen_ty_1 {
    pub connect: ble_gap_event__bindgen_ty_1__bindgen_ty_1,
    pub disconnect: ble_gap_event__bindgen_ty_1__bindgen_ty_2,
    #[doc = " Represents an advertising report received during a discovery"]
    #[doc = " procedure.  Valid for the following event types:"]
    #[doc = "     o BLE_GAP_EVENT_DISC"]
    pub disc: ble_gap_disc_desc,
    pub disc_complete: ble_gap_event__bindgen_ty_1__bindgen_ty_3,
    pub adv_complete: ble_gap_event__bindgen_ty_1__bindgen_ty_4,
    pub conn_update: ble_gap_event__bindgen_ty_1__bindgen_ty_5,
    pub conn_update_req: ble_gap_event__bindgen_ty_1__bindgen_ty_6,
    pub term_failure: ble_gap_event__bindgen_ty_1__bindgen_ty_7,
    pub enc_change: ble_gap_event__bindgen_ty_1__bindgen_ty_8,
    pub passkey: ble_gap_event__bindgen_ty_1__bindgen_ty_9,
    pub notify_rx: ble_gap_event__bindgen_ty_1__bindgen_ty_10,
    pub notify_tx: ble_gap_event__bindgen_ty_1__bindgen_ty_11,
    pub subscribe: ble_gap_event__bindgen_ty_1__bindgen_ty_12,
    pub mtu: ble_gap_event__bindgen_ty_1__bindgen_ty_13,
    pub identity_resolved: ble_gap_event__bindgen_ty_1__bindgen_ty_14,
    #[doc = " Represents a peer's attempt to pair despite a bond already existing."]
    #[doc = " The application has two options for handling this event type:"]
    #[doc = "     o Retry: Return BLE_GAP_REPEAT_PAIRING_RETRY after deleting the"]
    #[doc = "              conflicting bond.  The stack will verify the bond has"]
    #[doc = "              been deleted and continue the pairing procedure.  If"]
    #[doc = "              the bond is still present, this event will be reported"]
    #[doc = "              again."]
    #[doc = "     o Ignore: Return BLE_GAP_REPEAT_PAIRING_IGNORE.  The stack will"]
    #[doc = "               silently ignore the pairing request."]
    #[doc = ""]
    #[doc = " Valid for the following event types:"]
    #[doc = "     o BLE_GAP_EVENT_REPEAT_PAIRING"]
    pub repeat_pairing: ble_gap_repeat_pairing,
    pub phy_updated: ble_gap_event__bindgen_ty_1__bindgen_ty_15,
    _bindgen_union_align: [u32; 12usize],
}
#[doc = " Represents a connection attempt.  Valid for the following event"]
#[doc = " types:"]
#[doc = "     o BLE_GAP_EVENT_CONNECT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " The status of the connection attempt;"]
    #[doc = "     o 0: the connection was successfully established."]
    #[doc = "     o BLE host error code: the connection attempt failed for"]
    #[doc = "       the specified reason."]
    pub status: ::std::os::raw::c_int,
    #[doc = " The handle of the relevant connection."]
    pub conn_handle: u16,
}
#[doc = " Represents a terminated connection.  Valid for the following event"]
#[doc = " types:"]
#[doc = "     o BLE_GAP_EVENT_DISCONNECT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " A BLE host return code indicating the reason for the"]
    #[doc = " disconnect."]
    pub reason: ::std::os::raw::c_int,
    #[doc = " Information about the connection prior to termination."]
    pub conn: ble_gap_conn_desc,
}
#[doc = " Represents a completed discovery procedure.  Valid for the following"]
#[doc = " event types:"]
#[doc = "     o BLE_GAP_EVENT_DISC_COMPLETE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " The reason the discovery procedure stopped.  Typical reason"]
    #[doc = " codes are:"]
    #[doc = "     o 0: Duration expired."]
    #[doc = "     o BLE_HS_EPREEMPTED: Host aborted procedure to configure a"]
    #[doc = "       peer's identity."]
    pub reason: ::std::os::raw::c_int,
}
#[doc = " Represents a completed advertise procedure.  Valid for the following"]
#[doc = " event types:"]
#[doc = "     o BLE_GAP_EVENT_ADV_COMPLETE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event__bindgen_ty_1__bindgen_ty_4 {
    #[doc = " The reason the advertise procedure stopped.  Typical reason"]
    #[doc = " codes are:"]
    #[doc = "     o 0: Terminated due to connection."]
    #[doc = "     o BLE_HS_ETIMEOUT: Duration expired."]
    #[doc = "     o BLE_HS_EPREEMPTED: Host aborted procedure to configure a"]
    #[doc = "       peer's identity."]
    pub reason: ::std::os::raw::c_int,
}
#[doc = " Represents an attempt to update a connection's parameters.  If the"]
#[doc = " attempt was successful, the connection's descriptor reflects the"]
#[doc = " updated parameters."]
#[doc = ""]
#[doc = " Valid for the following event types:"]
#[doc = "     o BLE_GAP_EVENT_CONN_UPDATE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event__bindgen_ty_1__bindgen_ty_5 {
    #[doc = " The result of the connection update attempt;"]
    #[doc = "     o 0: the connection was successfully updated."]
    #[doc = "     o BLE host error code: the connection update attempt failed"]
    #[doc = "       for the specified reason."]
    pub status: ::std::os::raw::c_int,
    #[doc = " The handle of the relevant connection."]
    pub conn_handle: u16,
}
#[doc = " Represents a peer's request to update the connection parameters."]
#[doc = " This event is generated when a peer performs any of the following"]
#[doc = " procedures:"]
#[doc = "     o L2CAP Connection Parameter Update Procedure"]
#[doc = "     o Link-Layer Connection Parameters Request Procedure"]
#[doc = ""]
#[doc = " To reject the request, return a non-zero HCI error code.  The value"]
#[doc = " returned is the reject reason given to the controller."]
#[doc = ""]
#[doc = " Valid for the following event types:"]
#[doc = "     o BLE_GAP_EVENT_L2CAP_UPDATE_REQ"]
#[doc = "     o BLE_GAP_EVENT_CONN_UPDATE_REQ"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event__bindgen_ty_1__bindgen_ty_6 {
    #[doc = " Indicates the connection parameters that the peer would like to"]
    #[doc = " use."]
    pub peer_params: *const ble_gap_upd_params,
    #[doc = " Indicates the connection parameters that the local device would"]
    #[doc = " like to use.  The application callback should fill this in.  By"]
    #[doc = " default, this struct contains the requested parameters (i.e.,"]
    #[doc = " it is a copy of 'peer_params')."]
    pub self_params: *mut ble_gap_upd_params,
    #[doc = " The handle of the relevant connection."]
    pub conn_handle: u16,
}
#[doc = " Represents a failed attempt to terminate an established connection."]
#[doc = " Valid for the following event types:"]
#[doc = "     o BLE_GAP_EVENT_TERM_FAILURE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event__bindgen_ty_1__bindgen_ty_7 {
    #[doc = " A BLE host return code indicating the reason for the failure."]
    pub status: ::std::os::raw::c_int,
    #[doc = " The handle of the relevant connection."]
    pub conn_handle: u16,
}
#[doc = " Represents an attempt to change the encrypted state of a"]
#[doc = " connection.  If the attempt was successful, the connection"]
#[doc = " descriptor reflects the updated encrypted state."]
#[doc = ""]
#[doc = " Valid for the following event types:"]
#[doc = "     o BLE_GAP_EVENT_ENC_CHANGE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event__bindgen_ty_1__bindgen_ty_8 {
    #[doc = " Indicates the result of the encryption state change attempt;"]
    #[doc = "     o 0: the encrypted state was successfully updated;"]
    #[doc = "     o BLE host error code: the encryption state change attempt"]
    #[doc = "       failed for the specified reason."]
    pub status: ::std::os::raw::c_int,
    #[doc = " The handle of the relevant connection."]
    pub conn_handle: u16,
}
#[doc = " Represents a passkey query needed to complete a pairing procedure."]
#[doc = ""]
#[doc = " Valid for the following event types:"]
#[doc = "     o BLE_GAP_EVENT_PASSKEY_ACTION"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event__bindgen_ty_1__bindgen_ty_9 {
    #[doc = " Contains details about the passkey query."]
    pub params: ble_gap_passkey_params,
    #[doc = " The handle of the relevant connection."]
    pub conn_handle: u16,
}
#[doc = " Represents a received ATT notification or indication."]
#[doc = ""]
#[doc = " Valid for the following event types:"]
#[doc = "     o BLE_GAP_EVENT_NOTIFY_RX"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event__bindgen_ty_1__bindgen_ty_10 {
    #[doc = " The contents of the notification or indication.  If the"]
    #[doc = " application wishes to retain this mbuf for later use, it must"]
    #[doc = " set this pointer to NULL to prevent the stack from freeing it."]
    pub om: *mut os_mbuf,
    #[doc = " The handle of the relevant ATT attribute."]
    pub attr_handle: u16,
    #[doc = " The handle of the relevant connection."]
    pub conn_handle: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl ble_gap_event__bindgen_ty_1__bindgen_ty_10 {
    #[inline]
    pub fn indication(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_indication(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(indication: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let indication: u8 = unsafe { ::core::mem::transmute(indication) };
            indication as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Represents a transmitted ATT notification or indication, or a"]
#[doc = " completed indication transaction."]
#[doc = ""]
#[doc = " Valid for the following event types:"]
#[doc = "     o BLE_GAP_EVENT_NOTIFY_TX"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event__bindgen_ty_1__bindgen_ty_11 {
    #[doc = " The status of the notification or indication transaction;"]
    #[doc = "     o 0:                 Command successfully sent;"]
    #[doc = "     o BLE_HS_EDONE:      Confirmation (indication ack) received;"]
    #[doc = "     o BLE_HS_ETIMEOUT:   Confirmation (indication ack) never"]
    #[doc = "                              received;"]
    #[doc = "     o Other return code: Error."]
    pub status: ::std::os::raw::c_int,
    #[doc = " The handle of the relevant connection."]
    pub conn_handle: u16,
    #[doc = " The handle of the relevant characteristic value."]
    pub attr_handle: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl ble_gap_event__bindgen_ty_1__bindgen_ty_11 {
    #[inline]
    pub fn indication(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_indication(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(indication: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let indication: u8 = unsafe { ::core::mem::transmute(indication) };
            indication as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Represents a state change in a peer's subscription status.  In this"]
#[doc = " comment, the term \"update\" is used to refer to either a notification"]
#[doc = " or an indication.  This event is triggered by any of the following"]
#[doc = " occurrences:"]
#[doc = "     o Peer enables or disables updates via a CCCD write."]
#[doc = "     o Connection is about to be terminated and the peer is"]
#[doc = "       subscribed to updates."]
#[doc = "     o Peer is now subscribed to updates after its state was restored"]
#[doc = "       from persistence.  This happens when bonding is restored."]
#[doc = ""]
#[doc = " Valid for the following event types:"]
#[doc = "     o BLE_GAP_EVENT_SUBSCRIBE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event__bindgen_ty_1__bindgen_ty_12 {
    #[doc = " The handle of the relevant connection."]
    pub conn_handle: u16,
    #[doc = " The value handle of the relevant characteristic."]
    pub attr_handle: u16,
    #[doc = " One of the BLE_GAP_SUBSCRIBE_REASON codes."]
    pub reason: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl ble_gap_event__bindgen_ty_1__bindgen_ty_12 {
    #[inline]
    pub fn prev_notify(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_prev_notify(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cur_notify(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cur_notify(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prev_indicate(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_prev_indicate(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cur_indicate(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cur_indicate(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        prev_notify: u8,
        cur_notify: u8,
        prev_indicate: u8,
        cur_indicate: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let prev_notify: u8 = unsafe { ::core::mem::transmute(prev_notify) };
            prev_notify as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cur_notify: u8 = unsafe { ::core::mem::transmute(cur_notify) };
            cur_notify as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let prev_indicate: u8 = unsafe { ::core::mem::transmute(prev_indicate) };
            prev_indicate as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cur_indicate: u8 = unsafe { ::core::mem::transmute(cur_indicate) };
            cur_indicate as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Represents a change in an L2CAP channel's MTU."]
#[doc = ""]
#[doc = " Valid for the following event types:"]
#[doc = "     o BLE_GAP_EVENT_MTU"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event__bindgen_ty_1__bindgen_ty_13 {
    #[doc = " The handle of the relevant connection."]
    pub conn_handle: u16,
    #[doc = " Indicates the channel whose MTU has been updated; either"]
    #[doc = " BLE_L2CAP_CID_ATT or the ID of a connection-oriented channel."]
    pub channel_id: u16,
    pub value: u16,
}
#[doc = " Represents a change in peer's identity. This is issued after"]
#[doc = " successful pairing when Identity Address Information was received."]
#[doc = ""]
#[doc = " Valid for the following event types:"]
#[doc = "     o BLE_GAP_EVENT_IDENTITY_RESOLVED"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event__bindgen_ty_1__bindgen_ty_14 {
    #[doc = " The handle of the relevant connection."]
    pub conn_handle: u16,
}
#[doc = " Represents a change of PHY. This is issue after successful"]
#[doc = " change on PHY."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event__bindgen_ty_1__bindgen_ty_15 {
    pub status: ::std::os::raw::c_int,
    pub conn_handle: u16,
    #[doc = " Indicates enabled TX/RX PHY. Possible values:"]
    #[doc = "     o BLE_GAP_LE_PHY_1M"]
    #[doc = "     o BLE_GAP_LE_PHY_2M"]
    #[doc = "     o BLE_GAP_LE_PHY_CODED"]
    pub tx_phy: u8,
    pub rx_phy: u8,
}
pub type ble_gap_event_fn = ::core::option::Option<
    unsafe extern "C" fn(
        event: *mut ble_gap_event,
        arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Searches for a connection with the specified handle.  If a matching"]
    #[doc = " connection is found, the supplied connection descriptor is filled"]
    #[doc = " correspondingly."]
    #[doc = ""]
    #[doc = " @param handle    The connection handle to search for."]
    #[doc = " @param out_desc  On success, this is populated with information relating to"]
    #[doc = "                  the matching connection.  Pass NULL if you don't need this"]
    #[doc = "                  information."]
    #[doc = ""]
    #[doc = " @return          0 on success, BLE_HS_ENOTCONN if no matching connection was"]
    #[doc = "                  found."]
    pub fn ble_gap_conn_find(
        handle: u16,
        out_desc: *mut ble_gap_conn_desc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Searches for a connection with a peer with the specified address."]
    #[doc = " If a matching connection is found, the supplied connection descriptor"]
    #[doc = " is filled correspondingly."]
    #[doc = ""]
    #[doc = " @param addr      The ble address of a connected peer device to search for."]
    #[doc = " @param out_desc  On success, this is populated with information relating to"]
    #[doc = "                  the matching connection.  Pass NULL if you don't need this"]
    #[doc = "                  information."]
    #[doc = ""]
    #[doc = " @return          0 on success, BLE_HS_ENOTCONN if no matching connection was"]
    #[doc = "                  found."]
    pub fn ble_gap_conn_find_by_addr(
        addr: *const ble_addr_t,
        out_desc: *mut ble_gap_conn_desc,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configures a connection to use the specified GAP event callback.  A"]
    #[doc = " connection's GAP event callback is first specified when the connection is"]
    #[doc = " created, either via advertising or initiation.  This function replaces the"]
    #[doc = " callback that was last configured."]
    #[doc = ""]
    #[doc = " @param conn_handle   The handle of the connection to configure."]
    #[doc = " @param cb            The callback to associate with the connection."]
    #[doc = " @param cb_arg        An optional argument that the callback receives."]
    #[doc = ""]
    #[doc = " @return              0 on success, BLE_HS_ENOTCONN if there is no connection"]
    #[doc = "                      with the specified handle."]
    pub fn ble_gap_set_event_cb(
        conn_handle: u16,
        cb: ble_gap_event_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Start advertising"]
    #[doc = ""]
    #[doc = " This function configures and start advertising procedure."]
    #[doc = ""]
    #[doc = " @param own_addr_type The type of address the stack should use for itself."]
    #[doc = "                      Valid values are:"]
    #[doc = "                         - BLE_OWN_ADDR_PUBLIC"]
    #[doc = "                         - BLE_OWN_ADDR_RANDOM"]
    #[doc = "                         - BLE_OWN_ADDR_RPA_PUBLIC_DEFAULT"]
    #[doc = "                         - BLE_OWN_ADDR_RPA_RANDOM_DEFAULT"]
    #[doc = " @param direct_addr   The peer's address for directed advertising. This"]
    #[doc = "                      parameter shall be non-NULL if directed advertising is"]
    #[doc = "                      being used."]
    #[doc = " @param duration_ms   The duration of the advertisement procedure. On"]
    #[doc = "                      expiration, the procedure ends and a"]
    #[doc = "                      BLE_GAP_EVENT_ADV_COMPLETE event is reported. Units are"]
    #[doc = "                      milliseconds. Specify BLE_HS_FOREVER for no expiration."]
    #[doc = " @param adv_params    Additional arguments specifying the particulars of the"]
    #[doc = "                      advertising procedure."]
    #[doc = " @param cb            The callback to associate with this advertising"]
    #[doc = "                      procedure.  If advertising ends, the event is reported"]
    #[doc = "                      through this callback.  If advertising results in a"]
    #[doc = "                      connection, the connection inherits this callback as its"]
    #[doc = "                      event-reporting mechanism."]
    #[doc = " @param cb_arg        The optional argument to pass to the callback function."]
    #[doc = ""]
    #[doc = " @return              0 on success, error code on failure."]
    pub fn ble_gap_adv_start(
        own_addr_type: u8,
        direct_addr: *const ble_addr_t,
        duration_ms: i32,
        adv_params: *const ble_gap_adv_params,
        cb: ble_gap_event_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stops the currently-active advertising procedure.  A success return"]
    #[doc = " code indicates that advertising has been fully aborted and a new advertising"]
    #[doc = " procedure can be initiated immediately."]
    #[doc = ""]
    #[doc = " NOTE: If the caller is running in the same task as the NimBLE host, or if it"]
    #[doc = " is running in a higher priority task than that of the host, care must be"]
    #[doc = " taken when restarting advertising.  Under these conditions, the following is"]
    #[doc = " *not* a reliable method to restart advertising:"]
    #[doc = "     ble_gap_adv_stop()"]
    #[doc = "     ble_gap_adv_start()"]
    #[doc = ""]
    #[doc = " Instead, the call to `ble_gap_adv_start()` must be made in a separate event"]
    #[doc = " context.  That is, `ble_gap_adv_start()` must be called asynchronously by"]
    #[doc = " enqueueing an event on the current task's event queue.  See"]
    #[doc = " https://github.com/apache/mynewt-nimble/pull/211 for more information."]
    #[doc = ""]
    #[doc = " @return  0 on success, BLE_HS_EALREADY if there is no active advertising"]
    #[doc = "          procedure, other error code on failure."]
    pub fn ble_gap_adv_stop() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Indicates whether an advertisement procedure is currently in progress."]
    #[doc = ""]
    #[doc = " @return 0 if no advertisement procedure in progress, 1 otherwise."]
    pub fn ble_gap_adv_active() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configures the data to include in subsequent advertisements."]
    #[doc = ""]
    #[doc = " @param data      Buffer containing the advertising data."]
    #[doc = " @param data_len  The size of the advertising data, in bytes."]
    #[doc = ""]
    #[doc = " @return          0 on succes,  BLE_HS_EBUSY if advertising is in progress,"]
    #[doc = "                  other error code on failure."]
    pub fn ble_gap_adv_set_data(
        data: *const u8,
        data_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configures the data to include in subsequent scan responses."]
    #[doc = ""]
    #[doc = " @param data      Buffer containing the scan response data."]
    #[doc = " @param data_len  The size of the response data, in bytes."]
    #[doc = ""]
    #[doc = " @return          0 on succes,  BLE_HS_EBUSY if advertising is in progress,"]
    #[doc = "                  other error code on failure."]
    pub fn ble_gap_adv_rsp_set_data(
        data: *const u8,
        data_len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configures the fields to include in subsequent advertisements.  This is a"]
    #[doc = " convenience wrapper for ble_gap_adv_set_data()."]
    #[doc = ""]
    #[doc = " @param adv_fields    Specifies the advertisement data."]
    #[doc = ""]
    #[doc = " @return              0 on success,"]
    #[doc = "                      BLE_HS_EBUSY if advertising is in progress,"]
    #[doc = "                      BLE_HS_EMSGSIZE if the specified data is too large to"]
    #[doc = "                      fit in an advertisement,"]
    #[doc = "                      other error code on failure."]
    pub fn ble_gap_adv_set_fields(rsp_fields: *const ble_hs_adv_fields) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configures the fields to include in subsequent scan responses.  This is a"]
    #[doc = " convenience wrapper for ble_gap_adv_rsp_set_data()."]
    #[doc = ""]
    #[doc = " @param adv_fields   Specifies the scan response data."]
    #[doc = ""]
    #[doc = " @return              0 on success,"]
    #[doc = "                      BLE_HS_EBUSY if advertising is in progress,"]
    #[doc = "                      BLE_HS_EMSGSIZE if the specified data is too large to"]
    #[doc = "                      fit in a scan response,"]
    #[doc = "                      other error code on failure."]
    pub fn ble_gap_adv_rsp_set_fields(
        rsp_fields: *const ble_hs_adv_fields,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Performs the Limited or General Discovery Procedures."]
    #[doc = ""]
    #[doc = " @param own_addr_type         The type of address the stack should use for"]
    #[doc = "                                  itself when sending scan requests.  Valid"]
    #[doc = "                                  values are:"]
    #[doc = "                                      - BLE_ADDR_TYPE_PUBLIC"]
    #[doc = "                                      - BLE_ADDR_TYPE_RANDOM"]
    #[doc = "                                      - BLE_ADDR_TYPE_RPA_PUB_DEFAULT"]
    #[doc = "                                      - BLE_ADDR_TYPE_RPA_RND_DEFAULT"]
    #[doc = "                                  This parameter is ignored unless active"]
    #[doc = "                                  scanning is being used."]
    #[doc = " @param duration_ms           The duration of the discovery procedure."]
    #[doc = "                                  On expiration, the procedure ends and a"]
    #[doc = "                                  BLE_GAP_EVENT_DISC_COMPLETE event is"]
    #[doc = "                                  reported.  Units are milliseconds.  Specify"]
    #[doc = "                                  BLE_HS_FOREVER for no expiration."]
    #[doc = " @param disc_params           Additional arguments specifying the particulars"]
    #[doc = "                                  of the discovery procedure."]
    #[doc = " @param cb                    The callback to associate with this discovery"]
    #[doc = "                                  procedure.  Advertising reports and"]
    #[doc = "                                  discovery termination events are reported"]
    #[doc = "                                  through this callback."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gap_disc(
        own_addr_type: u8,
        duration_ms: i32,
        disc_params: *const ble_gap_disc_params,
        cb: ble_gap_event_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_gap_ext_disc(
        own_addr_type: u8,
        duration: u16,
        period: u16,
        filter_duplicates: u8,
        filter_policy: u8,
        limited: u8,
        uncoded_params: *const ble_gap_ext_disc_params,
        coded_params: *const ble_gap_ext_disc_params,
        cb: ble_gap_event_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cancels the discovery procedure currently in progress.  A success return"]
    #[doc = " code indicates that scanning has been fully aborted; a new discovery or"]
    #[doc = " connect procedure can be initiated immediately."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_EALREADY if there is no discovery"]
    #[doc = "                                  procedure to cancel;"]
    #[doc = "                              Other nonzero on unexpected error."]
    pub fn ble_gap_disc_cancel() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Indicates whether a discovery procedure is currently in progress."]
    #[doc = ""]
    #[doc = " @return                      0: No discovery procedure in progress;"]
    #[doc = "                              1: Discovery procedure in progress."]
    pub fn ble_gap_disc_active() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates a connect procedure."]
    #[doc = ""]
    #[doc = " @param own_addr_type         The type of address the stack should use for"]
    #[doc = "                                  itself during connection establishment."]
    #[doc = "                                      - BLE_OWN_ADDR_PUBLIC"]
    #[doc = "                                      - BLE_OWN_ADDR_RANDOM"]
    #[doc = "                                      - BLE_OWN_ADDR_RPA_PUBLIC_DEFAULT"]
    #[doc = "                                      - BLE_OWN_ADDR_RPA_RANDOM_DEFAULT"]
    #[doc = " @param peer_addr             The address of the peer to connect to."]
    #[doc = "                                  If this parameter is NULL, the white list"]
    #[doc = "                                  is used."]
    #[doc = " @param duration_ms           The duration of the discovery procedure."]
    #[doc = "                                  On expiration, the procedure ends and a"]
    #[doc = "                                  BLE_GAP_EVENT_DISC_COMPLETE event is"]
    #[doc = "                                  reported.  Units are milliseconds."]
    #[doc = " @param conn_params           Additional arguments specifying the particulars"]
    #[doc = "                                  of the connect procedure.  Specify null for"]
    #[doc = "                                  default values."]
    #[doc = " @param cb                    The callback to associate with this connect"]
    #[doc = "                                  procedure.  When the connect procedure"]
    #[doc = "                                  completes, the result is reported through"]
    #[doc = "                                  this callback.  If the connect procedure"]
    #[doc = "                                  succeeds, the connection inherits this"]
    #[doc = "                                  callback as its event-reporting mechanism."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_EALREADY if a connection attempt is"]
    #[doc = "                                  already in progress;"]
    #[doc = "                              BLE_HS_EBUSY if initiating a connection is not"]
    #[doc = "                                  possible because scanning is in progress;"]
    #[doc = "                              BLE_HS_EDONE if the specified peer is already"]
    #[doc = "                                  connected;"]
    #[doc = "                              Other nonzero on error."]
    pub fn ble_gap_connect(
        own_addr_type: u8,
        peer_addr: *const ble_addr_t,
        duration_ms: i32,
        params: *const ble_gap_conn_params,
        cb: ble_gap_event_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates an extended connect procedure."]
    #[doc = ""]
    #[doc = " @param own_addr_type         The type of address the stack should use for"]
    #[doc = "                                  itself during connection establishment."]
    #[doc = "                                      - BLE_OWN_ADDR_PUBLIC"]
    #[doc = "                                      - BLE_OWN_ADDR_RANDOM"]
    #[doc = "                                      - BLE_OWN_ADDR_RPA_PUBLIC_DEFAULT"]
    #[doc = "                                      - BLE_OWN_ADDR_RPA_RANDOM_DEFAULT"]
    #[doc = " @param peer_addr             The address of the peer to connect to."]
    #[doc = "                                  If this parameter is NULL, the white list"]
    #[doc = "                                  is used."]
    #[doc = " @param duration_ms           The duration of the discovery procedure."]
    #[doc = "                                  On expiration, the procedure ends and a"]
    #[doc = "                                  BLE_GAP_EVENT_DISC_COMPLETE event is"]
    #[doc = "                                  reported.  Units are milliseconds."]
    #[doc = " @param phy_mask              Define on which PHYs connection attempt should"]
    #[doc = "                                  be done"]
    #[doc = " @param phy_1m_conn_params     Additional arguments specifying the"]
    #[doc = "                                  particulars of the connect procedure. When"]
    #[doc = "                                  BLE_GAP_LE_PHY_1M_MASK is set in phy_mask"]
    #[doc = "                                  this parameter can be specify to null for"]
    #[doc = "                                  default values."]
    #[doc = " @param phy_2m_conn_params     Additional arguments specifying the"]
    #[doc = "                                  particulars of the connect procedure. When"]
    #[doc = "                                  BLE_GAP_LE_PHY_2M_MASK is set in phy_mask"]
    #[doc = "                                  this parameter can be specify to null for"]
    #[doc = "                                  default values."]
    #[doc = " @param phy_coded_conn_params  Additional arguments specifying the"]
    #[doc = "                                  particulars of the connect procedure. When"]
    #[doc = "                                  BLE_GAP_LE_PHY_CODED_MASK is set in"]
    #[doc = "                                  phy_mask this parameter can be specify to"]
    #[doc = "                                  null for default values."]
    #[doc = " @param cb                    The callback to associate with this connect"]
    #[doc = "                                  procedure.  When the connect procedure"]
    #[doc = "                                  completes, the result is reported through"]
    #[doc = "                                  this callback.  If the connect procedure"]
    #[doc = "                                  succeeds, the connection inherits this"]
    #[doc = "                                  callback as its event-reporting mechanism."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_EALREADY if a connection attempt is"]
    #[doc = "                                  already in progress;"]
    #[doc = "                              BLE_HS_EBUSY if initiating a connection is not"]
    #[doc = "                                  possible because scanning is in progress;"]
    #[doc = "                              BLE_HS_EDONE if the specified peer is already"]
    #[doc = "                                  connected;"]
    #[doc = "                              Other nonzero on error."]
    pub fn ble_gap_ext_connect(
        own_addr_type: u8,
        peer_addr: *const ble_addr_t,
        duration_ms: i32,
        phy_mask: u8,
        phy_1m_conn_params: *const ble_gap_conn_params,
        phy_2m_conn_params: *const ble_gap_conn_params,
        phy_coded_conn_params: *const ble_gap_conn_params,
        cb: ble_gap_event_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Aborts a connect procedure in progress."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_EALREADY if there is no active connect"]
    #[doc = "                                  procedure."]
    #[doc = "                              Other nonzero on error."]
    pub fn ble_gap_conn_cancel() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Indicates whether a connect procedure is currently in progress."]
    #[doc = ""]
    #[doc = " @return                      0: No connect procedure in progress;"]
    #[doc = "                              1: Connect procedure in progress."]
    pub fn ble_gap_conn_active() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Terminates an established connection."]
    #[doc = ""]
    #[doc = " @param conn_handle           The handle corresponding to the connection to"]
    #[doc = "                                  terminate."]
    #[doc = " @param hci_reason            The HCI error code to indicate as the reason"]
    #[doc = "                                  for termination."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_ENOTCONN if there is no connection with"]
    #[doc = "                                  the specified handle;"]
    #[doc = "                              Other nonzero on failure."]
    pub fn ble_gap_terminate(conn_handle: u16, hci_reason: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Overwrites the controller's white list with the specified contents."]
    #[doc = ""]
    #[doc = " @param addrs                 The entries to write to the white list."]
    #[doc = " @param white_list_count      The number of entries in the white list."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gap_wl_set(addrs: *const ble_addr_t, white_list_count: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates a connection parameter update procedure."]
    #[doc = ""]
    #[doc = " @param conn_handle           The handle corresponding to the connection to"]
    #[doc = "                                  update."]
    #[doc = " @param params                The connection parameters to attempt to update"]
    #[doc = "                                  to."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_ENOTCONN if the there is no connection"]
    #[doc = "                                  with the specified handle;"]
    #[doc = "                              BLE_HS_EALREADY if a connection update"]
    #[doc = "                                  procedure for this connection is already in"]
    #[doc = "                                  progress;"]
    #[doc = "                              BLE_HS_EINVAL if requested parameters are"]
    #[doc = "                                  invalid;"]
    #[doc = "                              Other nonzero on error."]
    pub fn ble_gap_update_params(
        conn_handle: u16,
        params: *const ble_gap_upd_params,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates the GAP security procedure."]
    #[doc = ""]
    #[doc = " Depending on connection role and stored security information this function"]
    #[doc = " will start appropriate security procedure (pairing or encryption)."]
    #[doc = ""]
    #[doc = " @param conn_handle           The handle corresponding to the connection to"]
    #[doc = "                              secure."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_ENOTCONN if the there is no connection"]
    #[doc = "                                  with the specified handle;"]
    #[doc = "                              BLE_HS_EALREADY if an security procedure for"]
    #[doc = "                                  this connection is already in progress;"]
    #[doc = "                              Other nonzero on error."]
    pub fn ble_gap_security_initiate(conn_handle: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates the GAP pairing procedure as a master. This is for testing only and"]
    #[doc = " should not be used by application. Use ble_gap_security_initiate() instead."]
    #[doc = ""]
    #[doc = " @param conn_handle           The handle corresponding to the connection to"]
    #[doc = "                              start pairing on."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_ENOTCONN if the there is no connection"]
    #[doc = "                                  with the specified handle;"]
    #[doc = "                              BLE_HS_EALREADY if an pairing procedure for"]
    #[doc = "                                  this connection is already in progress;"]
    #[doc = "                              Other nonzero on error."]
    pub fn ble_gap_pair_initiate(conn_handle: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates the GAP encryption procedure as a master. This is for testing only"]
    #[doc = " and should not be used by application. Use ble_gap_security_initiate()"]
    #[doc = " instead."]
    #[doc = ""]
    #[doc = " @param conn_handle           The handle corresponding to the connection to"]
    #[doc = "                              start encryption."]
    #[doc = " @param key_size              Encryption key size"]
    #[doc = " @param ltk                   Long Term Key to be used for encryption."]
    #[doc = " @param udiv                  Encryption Diversifier for LTK"]
    #[doc = " @param rand_val              Random Value for EDIV and LTK"]
    #[doc = " @param auth                  If LTK provided is authenticated."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_ENOTCONN if the there is no connection"]
    #[doc = "                                  with the specified handle;"]
    #[doc = "                              BLE_HS_EALREADY if an encryption procedure for"]
    #[doc = "                                  this connection is already in progress;"]
    #[doc = "                              Other nonzero on error."]
    pub fn ble_gap_encryption_initiate(
        conn_handle: u16,
        key_size: u8,
        ltk: *const u8,
        ediv: u16,
        rand_val: u64,
        auth: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieves the most-recently measured RSSI for the specified connection.  A"]
    #[doc = " connection's RSSI is updated whenever a data channel PDU is received."]
    #[doc = ""]
    #[doc = " @param conn_handle           Specifies the connection to query."]
    #[doc = " @param out_rssi              On success, the retrieved RSSI is written here."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              A BLE host HCI return code if the controller"]
    #[doc = "                                  rejected the request;"]
    #[doc = "                              A BLE host core return code on unexpected"]
    #[doc = "                                  error."]
    pub fn ble_gap_conn_rssi(conn_handle: u16, out_rssi: *mut i8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unpairs a device with the specified address. The keys related to that peer"]
    #[doc = " device are removed from storage and peer address is removed from the resolve"]
    #[doc = " list from the controller. If a peer is connected, the connection is terminated."]
    #[doc = ""]
    #[doc = " @param peer_addr             Address of the device to be unpaired"]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              A BLE host HCI return code if the controller"]
    #[doc = "                                  rejected the request;"]
    #[doc = "                              A BLE host core return code on unexpected"]
    #[doc = "                                  error."]
    pub fn ble_gap_unpair(peer_addr: *const ble_addr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unpairs the oldest bonded peer device. The keys related to that peer"]
    #[doc = " device are removed from storage and peer address is removed from the resolve"]
    #[doc = " list from the controller. If a peer is connected, the connection is terminated."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              A BLE host HCI return code if the controller"]
    #[doc = "                                  rejected the request;"]
    #[doc = "                              A BLE host core return code on unexpected"]
    #[doc = "                                  error."]
    pub fn ble_gap_unpair_oldest_peer() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_gap_set_priv_mode(
        peer_addr: *const ble_addr_t,
        priv_mode: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_gap_read_le_phy(
        conn_handle: u16,
        tx_phy: *mut u8,
        rx_phy: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_gap_set_prefered_default_le_phy(
        tx_phys_mask: u8,
        rx_phys_mask: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_gap_set_prefered_le_phy(
        conn_handle: u16,
        tx_phys_mask: u8,
        rx_phys_mask: u8,
        phy_opts: u16,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Event listener structure"]
#[doc = ""]
#[doc = " This should be used as an opaque structure and not modified manually."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event_listener {
    pub fn_: ble_gap_event_fn,
    pub arg: *mut ::core::ffi::c_void,
    pub link: ble_gap_event_listener__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gap_event_listener__bindgen_ty_1 {
    pub sle_next: *mut ble_gap_event_listener,
}
extern "C" {
    #[doc = " Registers listener for GAP events"]
    #[doc = ""]
    #[doc = " On success listener structure will be initialized automatically and does not"]
    #[doc = " need to be initialized prior to calling this function. To change callback"]
    #[doc = " and/or argument unregister listener first and register it again."]
    #[doc = ""]
    #[doc = " @param listener      Listener structure"]
    #[doc = " @param fn            Callback function"]
    #[doc = " @param arg           Callback argument"]
    #[doc = ""]
    #[doc = " @return              0 on success"]
    #[doc = "                      BLE_HS_EINVAL if no callback is specified"]
    #[doc = "                      BLE_HS_EALREADY if listener is already registered"]
    pub fn ble_gap_event_listener_register(
        listener: *mut ble_gap_event_listener,
        fn_: ble_gap_event_fn,
        arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregisters listener for GAP events"]
    #[doc = ""]
    #[doc = " @param listener      Listener structure"]
    #[doc = ""]
    #[doc = " @return              0 on success"]
    #[doc = "                      BLE_HS_ENOENT if listener was not registered"]
    pub fn ble_gap_event_listener_unregister(
        listener: *mut ble_gap_event_listener,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_hs_conn {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_att_error_rsp {
    _unused: [u8; 0],
}
#[doc = " @client."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatt_error {
    pub status: u16,
    pub att_handle: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_gatt_svc {
    pub start_handle: u16,
    pub end_handle: u16,
    pub uuid: ble_uuid_any_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatt_attr {
    pub handle: u16,
    pub offset: u16,
    pub om: *mut os_mbuf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_gatt_chr {
    pub def_handle: u16,
    pub val_handle: u16,
    pub properties: u8,
    pub uuid: ble_uuid_any_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_gatt_dsc {
    pub handle: u16,
    pub uuid: ble_uuid_any_t,
}
pub type ble_gatt_mtu_fn = ::core::option::Option<
    unsafe extern "C" fn(
        conn_handle: u16,
        error: *const ble_gatt_error,
        mtu: u16,
        arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type ble_gatt_disc_svc_fn = ::core::option::Option<
    unsafe extern "C" fn(
        conn_handle: u16,
        error: *const ble_gatt_error,
        service: *const ble_gatt_svc,
        arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " The host will free the attribute mbuf automatically after the callback is"]
#[doc = " executed.  The application can take ownership of the mbuf and prevent it"]
#[doc = " from being freed by assigning NULL to attr->om."]
pub type ble_gatt_attr_fn = ::core::option::Option<
    unsafe extern "C" fn(
        conn_handle: u16,
        error: *const ble_gatt_error,
        attr: *mut ble_gatt_attr,
        arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " The host will free the attribute mbufs automatically after the callback is"]
#[doc = " executed.  The application can take ownership of the mbufs and prevent them"]
#[doc = " from being freed by assigning NULL to each attribute's om field."]
pub type ble_gatt_reliable_attr_fn = ::core::option::Option<
    unsafe extern "C" fn(
        conn_handle: u16,
        error: *const ble_gatt_error,
        attrs: *mut ble_gatt_attr,
        num_attrs: u8,
        arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type ble_gatt_chr_fn = ::core::option::Option<
    unsafe extern "C" fn(
        conn_handle: u16,
        error: *const ble_gatt_error,
        chr: *const ble_gatt_chr,
        arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type ble_gatt_dsc_fn = ::core::option::Option<
    unsafe extern "C" fn(
        conn_handle: u16,
        error: *const ble_gatt_error,
        chr_val_handle: u16,
        dsc: *const ble_gatt_dsc,
        arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Initiates GATT procedure: Exchange MTU."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param cb                    The function to call to report procedure status"]
    #[doc = "                                  updates; null for no callback."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_exchange_mtu(
        conn_handle: u16,
        cb: ble_gatt_mtu_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates GATT procedure: Discover All Primary Services."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param cb                    The function to call to report procedure status"]
    #[doc = "                                  updates; null for no callback."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    pub fn ble_gattc_disc_all_svcs(
        conn_handle: u16,
        cb: ble_gatt_disc_svc_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates GATT procedure: Discover Primary Service by Service UUID."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param service_uuid128       The 128-bit UUID of the service to discover."]
    #[doc = " @param cb                    The function to call to report procedure status"]
    #[doc = "                                  updates; null for no callback."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_disc_svc_by_uuid(
        conn_handle: u16,
        uuid: *const ble_uuid_t,
        cb: ble_gatt_disc_svc_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates GATT procedure: Find Included Services."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param start_handle          The handle to begin the search at (generally"]
    #[doc = "                                  the service definition handle)."]
    #[doc = " @param end_handle            The handle to end the search at (generally the"]
    #[doc = "                                  last handle in the service)."]
    #[doc = " @param cb                    The function to call to report procedure status"]
    #[doc = "                                  updates; null for no callback."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_find_inc_svcs(
        conn_handle: u16,
        start_handle: u16,
        end_handle: u16,
        cb: ble_gatt_disc_svc_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates GATT procedure: Discover All Characteristics of a Service."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param start_handle          The handle to begin the search at (generally"]
    #[doc = "                                  the service definition handle)."]
    #[doc = " @param end_handle            The handle to end the search at (generally the"]
    #[doc = "                                  last handle in the service)."]
    #[doc = " @param cb                    The function to call to report procedure status"]
    #[doc = "                                  updates; null for no callback."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_disc_all_chrs(
        conn_handle: u16,
        start_handle: u16,
        end_handle: u16,
        cb: ble_gatt_chr_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates GATT procedure: Discover Characteristics by UUID."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param start_handle          The handle to begin the search at (generally"]
    #[doc = "                                  the service definition handle)."]
    #[doc = " @param end_handle            The handle to end the search at (generally the"]
    #[doc = "                                  last handle in the service)."]
    #[doc = " @param chr_uuid128           The 128-bit UUID of the characteristic to"]
    #[doc = "                                  discover."]
    #[doc = " @param cb                    The function to call to report procedure status"]
    #[doc = "                                  updates; null for no callback."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_disc_chrs_by_uuid(
        conn_handle: u16,
        start_handle: u16,
        end_handle: u16,
        uuid: *const ble_uuid_t,
        cb: ble_gatt_chr_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates GATT procedure: Discover All Characteristic Descriptors."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param chr_val_handle        The handle of the characteristic value"]
    #[doc = "                                  attribute."]
    #[doc = " @param chr_end_handle        The last handle in the characteristic"]
    #[doc = "                                  definition."]
    #[doc = " @param cb                    The function to call to report procedure status"]
    #[doc = "                                  updates; null for no callback."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_disc_all_dscs(
        conn_handle: u16,
        start_handle: u16,
        end_handle: u16,
        cb: ble_gatt_dsc_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates GATT procedure: Read Characteristic Value."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param attr_handle           The handle of the characteristic value to read."]
    #[doc = " @param cb                    The function to call to report procedure status"]
    #[doc = "                                  updates; null for no callback."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_read(
        conn_handle: u16,
        attr_handle: u16,
        cb: ble_gatt_attr_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates GATT procedure: Read Using Characteristic UUID."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param start_handle          The first handle to search (generally the"]
    #[doc = "                                  handle of the service definition)."]
    #[doc = " @param end_handle            The last handle to search (generally the"]
    #[doc = "                                  last handle in the service definition)."]
    #[doc = " @param cb                    The function to call to report procedure status"]
    #[doc = "                                  updates; null for no callback."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_read_by_uuid(
        conn_handle: u16,
        start_handle: u16,
        end_handle: u16,
        uuid: *const ble_uuid_t,
        cb: ble_gatt_attr_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates GATT procedure: Read Long Characteristic Values."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param handle                The handle of the characteristic value to read."]
    #[doc = " @param cb                    The function to call to report procedure status"]
    #[doc = "                                  updates; null for no callback."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_read_long(
        conn_handle: u16,
        handle: u16,
        offset: u16,
        cb: ble_gatt_attr_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates GATT procedure: Read Multiple Characteristic Values."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param handles               An array of 16-bit attribute handles to read."]
    #[doc = " @param num_handles           The number of entries in the \"handles\" array."]
    #[doc = " @param cb                    The function to call to report procedure status"]
    #[doc = "                                  updates; null for no callback."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_read_mult(
        conn_handle: u16,
        handles: *const u16,
        num_handles: u8,
        cb: ble_gatt_attr_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates GATT procedure: Write Without Response.  This function consumes"]
    #[doc = " the supplied mbuf regardless of the outcome."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param attr_handle           The handle of the characteristic value to write"]
    #[doc = "                                  to."]
    #[doc = " @param txom                  The value to write to the characteristic."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_write_no_rsp(
        conn_handle: u16,
        attr_handle: u16,
        om: *mut os_mbuf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates GATT procedure: Write Without Response.  This function consumes"]
    #[doc = " the supplied mbuf regardless of the outcome."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param attr_handle           The handle of the characteristic value to write"]
    #[doc = "                                  to."]
    #[doc = " @param value                 The value to write to the characteristic."]
    #[doc = " @param value_len             The number of bytes to write."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_write_no_rsp_flat(
        conn_handle: u16,
        attr_handle: u16,
        data: *const ::core::ffi::c_void,
        data_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates GATT procedure: Write Characteristic Value.  This function"]
    #[doc = " consumes the supplied mbuf regardless of the outcome."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param attr_handle           The handle of the characteristic value to write"]
    #[doc = "                                  to."]
    #[doc = " @param txom                  The value to write to the characteristic."]
    #[doc = " @param cb                    The function to call to report procedure status"]
    #[doc = "                                  updates; null for no callback."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_write(
        conn_handle: u16,
        attr_handle: u16,
        om: *mut os_mbuf,
        cb: ble_gatt_attr_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates GATT procedure: Write Characteristic Value (flat buffer version)."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param attr_handle           The handle of the characteristic value to write"]
    #[doc = "                                  to."]
    #[doc = " @param value                 The value to write to the characteristic."]
    #[doc = " @param value_len             The number of bytes to write."]
    #[doc = " @param cb                    The function to call to report procedure status"]
    #[doc = "                                  updates; null for no callback."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_write_flat(
        conn_handle: u16,
        attr_handle: u16,
        data: *const ::core::ffi::c_void,
        data_len: u16,
        cb: ble_gatt_attr_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates GATT procedure: Write Long Characteristic Values.  This function"]
    #[doc = " consumes the supplied mbuf regardless of the outcome."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param attr_handle           The handle of the characteristic value to write"]
    #[doc = "                                  to."]
    #[doc = " @param txom                  The value to write to the characteristic."]
    #[doc = " @param cb                    The function to call to report procedure status"]
    #[doc = "                                  updates; null for no callback."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_write_long(
        conn_handle: u16,
        attr_handle: u16,
        offset: u16,
        om: *mut os_mbuf,
        cb: ble_gatt_attr_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initiates GATT procedure: Reliable Writes.  This function consumes the"]
    #[doc = " supplied mbufs regardless of the outcome."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param attrs                 An array of attribute descriptors; specifies"]
    #[doc = "                                  which characteristics to write to and what"]
    #[doc = "                                  data to write to them.  The mbuf pointer in"]
    #[doc = "                                  each attribute is set to NULL by this"]
    #[doc = "                                  function."]
    #[doc = " @param num_attrs             The number of characteristics to write; equal"]
    #[doc = "                                  to the number of elements in the 'attrs'"]
    #[doc = "                                  array."]
    #[doc = " @param cb                    The function to call to report procedure status"]
    #[doc = "                                  updates; null for no callback."]
    #[doc = " @param cb_arg                The optional argument to pass to the callback"]
    #[doc = "                                  function."]
    pub fn ble_gattc_write_reliable(
        conn_handle: u16,
        attrs: *mut ble_gatt_attr,
        num_attrs: ::std::os::raw::c_int,
        cb: ble_gatt_reliable_attr_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sends a \"free-form\" characteristic notification.  This function consumes the"]
    #[doc = " supplied mbuf regardless of the outcome."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param chr_val_handle        The attribute handle to indicate in the"]
    #[doc = "                                  outgoing notification."]
    #[doc = " @param txom                  The value to write to the characteristic."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_notify_custom(
        conn_handle: u16,
        att_handle: u16,
        om: *mut os_mbuf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sends a characteristic notification.  The content of the message is read"]
    #[doc = " from the specified characteristic."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param chr_val_handle        The value attribute handle of the"]
    #[doc = "                                  characteristic to include in the outgoing"]
    #[doc = "                                  notification."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_notify(conn_handle: u16, chr_val_handle: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sends a \"free-form\" characteristic indication.  The provided mbuf contains"]
    #[doc = " the indication payload.  This function consumes the supplied mbuf regardless"]
    #[doc = " of the outcome."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param chr_val_handle        The value attribute handle of the"]
    #[doc = "                                  characteristic to include in the outgoing"]
    #[doc = "                                  indication."]
    #[doc = " @param txom                  The data to include in the indication."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_indicate_custom(
        conn_handle: u16,
        chr_val_handle: u16,
        txom: *mut os_mbuf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sends a characteristic indication.  The content of the message is read from"]
    #[doc = " the specified characteristic."]
    #[doc = ""]
    #[doc = " @param conn_handle           The connection over which to execute the"]
    #[doc = "                                  procedure."]
    #[doc = " @param chr_val_handle        The value attribute handle of the"]
    #[doc = "                                  characteristic to include in the outgoing"]
    #[doc = "                                  indication."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_gattc_indicate(conn_handle: u16, chr_val_handle: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_gattc_init() -> ::std::os::raw::c_int;
}
pub type ble_gatt_access_fn = ::core::option::Option<
    unsafe extern "C" fn(
        conn_handle: u16,
        attr_handle: u16,
        ctxt: *mut ble_gatt_access_ctxt,
        arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type ble_gatt_chr_flags = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatt_chr_def {
    #[doc = " Pointer to characteristic UUID; use BLE_UUIDxx_DECLARE macros to declare"]
    #[doc = " proper UUID; NULL if there are no more characteristics in the service."]
    pub uuid: *const ble_uuid_t,
    #[doc = " Callback that gets executed when this characteristic is read or"]
    #[doc = " written."]
    pub access_cb: ble_gatt_access_fn,
    #[doc = " Optional argument for callback."]
    pub arg: *mut ::core::ffi::c_void,
    #[doc = " Array of this characteristic's descriptors.  NULL if no descriptors."]
    #[doc = " Do not include CCCD; it gets added automatically if this"]
    #[doc = " characteristic's notify or indicate flag is set."]
    pub descriptors: *mut ble_gatt_dsc_def,
    #[doc = " Specifies the set of permitted operations for this characteristic."]
    pub flags: ble_gatt_chr_flags,
    #[doc = " Specifies minimum required key size to access this characteristic."]
    pub min_key_size: u8,
    #[doc = " At registration time, this is filled in with the characteristic's value"]
    #[doc = " attribute handle."]
    pub val_handle: *mut u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatt_svc_def {
    #[doc = " One of the following:"]
    #[doc = "     o BLE_GATT_SVC_TYPE_PRIMARY - primary service"]
    #[doc = "     o BLE_GATT_SVC_TYPE_SECONDARY - secondary service"]
    #[doc = "     o 0 - No more services in this array."]
    pub type_: u8,
    #[doc = " Pointer to service UUID; use BLE_UUIDxx_DECLARE macros to declare"]
    #[doc = " proper UUID; NULL if there are no more characteristics in the service."]
    pub uuid: *const ble_uuid_t,
    #[doc = " Array of pointers to other service definitions.  These services are"]
    #[doc = " reported as \"included services\" during service discovery.  Terminate the"]
    #[doc = " array with NULL."]
    pub includes: *mut *const ble_gatt_svc_def,
    #[doc = " Array of characteristic definitions corresponding to characteristics"]
    #[doc = " belonging to this service."]
    pub characteristics: *const ble_gatt_chr_def,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatt_dsc_def {
    #[doc = " Pointer to descriptor UUID; use BLE_UUIDxx_DECLARE macros to declare"]
    #[doc = " proper UUID; NULL if there are no more characteristics in the service."]
    pub uuid: *const ble_uuid_t,
    #[doc = " Specifies the set of permitted operations for this descriptor."]
    pub att_flags: u8,
    #[doc = " Specifies minimum required key size to access this descriptor."]
    pub min_key_size: u8,
    #[doc = " Callback that gets executed when the descriptor is read or written."]
    pub access_cb: ble_gatt_access_fn,
    #[doc = " Optional argument for callback."]
    pub arg: *mut ::core::ffi::c_void,
}
#[doc = " @server."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_gatt_access_ctxt {
    #[doc = " Indicates the gatt operation being performed.  This is equal to one of"]
    #[doc = " the following values:"]
    #[doc = "     o  BLE_GATT_ACCESS_OP_READ_CHR"]
    #[doc = "     o  BLE_GATT_ACCESS_OP_WRITE_CHR"]
    #[doc = "     o  BLE_GATT_ACCESS_OP_READ_DSC"]
    #[doc = "     o  BLE_GATT_ACCESS_OP_WRITE_DSC"]
    pub op: u8,
    #[doc = " A container for the GATT access data."]
    #[doc = "     o For reads: The application populates this with the value of the"]
    #[doc = "       characteristic or descriptor being read."]
    #[doc = "     o For writes: This is already populated with the value being written"]
    #[doc = "       by the peer.  If the application wishes to retain this mbuf for"]
    #[doc = "       later use, the access callback must set this pointer to NULL to"]
    #[doc = "       prevent the stack from freeing it."]
    pub om: *mut os_mbuf,
    pub __bindgen_anon_1: ble_gatt_access_ctxt__bindgen_ty_1,
}
#[doc = " The GATT operation being performed dictates which field in this union is"]
#[doc = " valid.  If a characteristic is being accessed, the chr field is valid."]
#[doc = " Otherwise a descriptor is being accessed, in which case the dsc field"]
#[doc = " is valid."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_gatt_access_ctxt__bindgen_ty_1 {
    #[doc = " The characteristic definition corresponding to the characteristic"]
    #[doc = " being accessed.  This is what the app registered at startup."]
    pub chr: *const ble_gatt_chr_def,
    #[doc = " The descriptor definition corresponding to the descriptor being"]
    #[doc = " accessed.  This is what the app registered at startup."]
    pub dsc: *const ble_gatt_dsc_def,
    _bindgen_union_align: u32,
}
#[doc = " Context passed to the registration callback; represents the GATT service,"]
#[doc = " characteristic, or descriptor being registered."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_gatt_register_ctxt {
    #[doc = " Indicates the gatt registration operation just performed.  This is"]
    #[doc = " equal to one of the following values:"]
    #[doc = "     o BLE_GATT_REGISTER_OP_SVC"]
    #[doc = "     o BLE_GATT_REGISTER_OP_CHR"]
    #[doc = "     o BLE_GATT_REGISTER_OP_DSC"]
    pub op: u8,
    pub __bindgen_anon_1: ble_gatt_register_ctxt__bindgen_ty_1,
}
#[doc = " The value of the op field determines which field in this union is valid."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_gatt_register_ctxt__bindgen_ty_1 {
    pub svc: ble_gatt_register_ctxt__bindgen_ty_1__bindgen_ty_1,
    pub chr: ble_gatt_register_ctxt__bindgen_ty_1__bindgen_ty_2,
    pub dsc: ble_gatt_register_ctxt__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u32; 4usize],
}
#[doc = " Service; valid if op == BLE_GATT_REGISTER_OP_SVC."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatt_register_ctxt__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " The ATT handle of the service definition attribute."]
    pub handle: u16,
    #[doc = " The service definition representing the service being"]
    #[doc = " registered."]
    pub svc_def: *const ble_gatt_svc_def,
}
#[doc = " Characteristic; valid if op == BLE_GATT_REGISTER_OP_CHR."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatt_register_ctxt__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " The ATT handle of the characteristic definition attribute."]
    pub def_handle: u16,
    #[doc = " The ATT handle of the characteristic value attribute."]
    pub val_handle: u16,
    #[doc = " The characteristic definition representing the characteristic"]
    #[doc = " being registered."]
    pub chr_def: *const ble_gatt_chr_def,
    #[doc = " The service definition corresponding to the characteristic's"]
    #[doc = " parent service."]
    pub svc_def: *const ble_gatt_svc_def,
}
#[doc = " Descriptor; valid if op == BLE_GATT_REGISTER_OP_DSC."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_gatt_register_ctxt__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " The ATT handle of the descriptor definition attribute."]
    pub handle: u16,
    #[doc = " The descriptor definition corresponding to the descriptor being"]
    #[doc = " registered."]
    pub dsc_def: *const ble_gatt_dsc_def,
    #[doc = " The characteristic definition corresponding to the descriptor's"]
    #[doc = " parent characteristic."]
    pub chr_def: *const ble_gatt_chr_def,
    #[doc = " The service definition corresponding to the descriptor's"]
    #[doc = " grandparent service"]
    pub svc_def: *const ble_gatt_svc_def,
}
pub type ble_gatt_register_fn = ::core::option::Option<
    unsafe extern "C" fn(ctxt: *mut ble_gatt_register_ctxt, arg: *mut ::core::ffi::c_void),
>;
extern "C" {
    #[doc = " Queues a set of service definitions for registration.  All services queued"]
    #[doc = " in this manner get registered when ble_gatts_start() is called."]
    #[doc = ""]
    #[doc = " @param svcs                  An array of service definitions to queue for"]
    #[doc = "                                  registration.  This array must be"]
    #[doc = "                                  terminated with an entry whose 'type'"]
    #[doc = "                                  equals 0."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_ENOMEM on heap exhaustion."]
    pub fn ble_gatts_add_svcs(svcs: *const ble_gatt_svc_def) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set visibility of local GATT service. Invisible services are not removed"]
    #[doc = " from database but are not discoverable by peer devices. Service Changed"]
    #[doc = " should be handled by application when needed by calling"]
    #[doc = " ble_svc_gatt_changed()."]
    #[doc = ""]
    #[doc = " @param handle                Handle of service"]
    #[doc = " @param visible               non-zero if service should be visible"]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_ENOENT if service wasn't found."]
    pub fn ble_gatts_svc_set_visibility(
        handle: u16,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Adjusts a host configuration object's settings to accommodate the specified"]
    #[doc = " service definition array.  This function adds the counts to the appropriate"]
    #[doc = " fields in the supplied configuration object without clearing them first, so"]
    #[doc = " it can be called repeatedly with different inputs to calculate totals.  Be"]
    #[doc = " sure to zero the GATT server settings prior to the first call to this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " @param defs                  The service array containing the resource"]
    #[doc = "                                  definitions to be counted."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_EINVAL if the svcs array contains an"]
    #[doc = "                                  invalid resource definition."]
    pub fn ble_gatts_count_cfg(defs: *const ble_gatt_svc_def) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send notification (or indication) to any connected devices that have"]
    #[doc = " subscribed for notification (or indication) for specified characteristic."]
    #[doc = ""]
    #[doc = " @param chr_val_handle        Characteristic value handle"]
    pub fn ble_gatts_chr_updated(chr_val_handle: u16);
}
extern "C" {
    #[doc = " Retrieves the attribute handle associated with a local GATT service."]
    #[doc = ""]
    #[doc = " @param uuid                  The UUID of the service to look up."]
    #[doc = " @param out_handle            On success, populated with the handle of the"]
    #[doc = "                                  service attribute.  Pass null if you don't"]
    #[doc = "                                  need this value."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_ENOENT if the specified service could"]
    #[doc = "                                  not be found."]
    pub fn ble_gatts_find_svc(
        uuid: *const ble_uuid_t,
        out_handle: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieves the pair of attribute handles associated with a local GATT"]
    #[doc = " characteristic."]
    #[doc = ""]
    #[doc = " @param svc_uuid              The UUID of the parent service."]
    #[doc = " @param chr_uuid              The UUID of the characteristic to look up."]
    #[doc = " @param out_def_handle        On success, populated with the handle"]
    #[doc = "                                  of the characteristic definition attribute."]
    #[doc = "                                  Pass null if you don't need this value."]
    #[doc = " @param out_val_handle        On success, populated with the handle"]
    #[doc = "                                  of the characteristic value attribute."]
    #[doc = "                                  Pass null if you don't need this value."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_ENOENT if the specified service or"]
    #[doc = "                                  characteristic could not be found."]
    pub fn ble_gatts_find_chr(
        svc_uuid: *const ble_uuid_t,
        chr_uuid: *const ble_uuid_t,
        out_def_handle: *mut u16,
        out_val_handle: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieves the attribute handle associated with a local GATT descriptor."]
    #[doc = ""]
    #[doc = " @param svc_uuid              The UUID of the grandparent service."]
    #[doc = " @param chr_uuid              The UUID of the parent characteristic."]
    #[doc = " @param dsc_uuid              The UUID of the descriptor ro look up."]
    #[doc = " @param out_handle            On success, populated with the handle"]
    #[doc = "                                  of the descriptor attribute.  Pass null if"]
    #[doc = "                                  you don't need this value."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_ENOENT if the specified service,"]
    #[doc = "                                  characteristic, or descriptor could not be"]
    #[doc = "                                  found."]
    pub fn ble_gatts_find_dsc(
        svc_uuid: *const ble_uuid_t,
        chr_uuid: *const ble_uuid_t,
        dsc_uuid: *const ble_uuid_t,
        out_dsc_handle: *mut u16,
    ) -> ::std::os::raw::c_int;
}
pub type ble_gatt_svc_foreach_fn = ::core::option::Option<
    unsafe extern "C" fn(
        svc: *const ble_gatt_svc_def,
        handle: u16,
        end_group_handle: u16,
        arg: *mut ::core::ffi::c_void,
    ),
>;
extern "C" {
    #[doc = " Prints dump of local GATT database. This is useful to log local state of"]
    #[doc = " database in human readable form."]
    pub fn ble_gatts_show_local();
}
extern "C" {
    #[doc = " Resets the GATT server to its initial state.  On success, this function"]
    #[doc = " removes all supported services, characteristics, and descriptors.  This"]
    #[doc = " function requires that:"]
    #[doc = "     o No peers are connected, and"]
    #[doc = "     o No GAP operations are active (advertise, discover, or connect)."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_EBUSY if the GATT server could not be"]
    #[doc = "                                  reset due to existing connections or active"]
    #[doc = "                                  GAP procedures."]
    pub fn ble_gatts_reset() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Makes all registered services available to peers.  This function gets called"]
    #[doc = " automatically by the NimBLE host on startup; manual calls are only necessary"]
    #[doc = " for replacing the set of supported services with a new one.  This function"]
    #[doc = " requires that:"]
    #[doc = "     o No peers are connected, and"]
    #[doc = "     o No GAP operations are active (advertise, discover, or connect)."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              A BLE host core return code on unexpected"]
    #[doc = "                                  error."]
    pub fn ble_gatts_start() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Resets the GATT configuration parameters and deallocates the memory of attributes."]
    #[doc = ""]
    pub fn ble_gatts_stop();
}
extern "C" {
    #[doc = " Generates a new random address.  This function does not configure the device"]
    #[doc = " with the new address; the caller can use the address in subsequent"]
    #[doc = " operations."]
    #[doc = ""]
    #[doc = " @param nrpa                  The type of random address to generate:"]
    #[doc = "                                  0: static"]
    #[doc = "                                  1: non-resolvable private"]
    #[doc = " @param out_addr              On success, the generated address gets written"]
    #[doc = "                                  here."]
    #[doc = ""]
    #[doc = " @return                      0 on success; nonzero on failure."]
    pub fn ble_hs_id_gen_rnd(
        nrpa: ::std::os::raw::c_int,
        out_addr: *mut ble_addr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the device's random address.  The address type (static vs."]
    #[doc = " non-resolvable private) is inferred from the most-significant byte of the"]
    #[doc = " address.  The address is specified in host byte order (little-endian!)."]
    #[doc = ""]
    #[doc = " @param rnd_addr              The random address to set."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_EINVAL if the specified address is not a"]
    #[doc = "                                  valid static random or non-resolvable"]
    #[doc = "                                  private address."]
    #[doc = "                              Other nonzero on error."]
    pub fn ble_hs_id_set_rnd(rnd_addr: *const u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieves one of the device's identity addresses.  The device can have two"]
    #[doc = " identity addresses: one public and one random.  The id_addr_type argument"]
    #[doc = " specifies which of these two addresses to retrieve."]
    #[doc = ""]
    #[doc = " @param id_addr_type          The type of identity address to retrieve."]
    #[doc = "                                  Valid values are:"]
    #[doc = "                                      o BLE_ADDR_PUBLIC"]
    #[doc = "                                      o BLE_ADDR_RANDOM"]
    #[doc = " @param out_id_addr           On success, the requested identity address is"]
    #[doc = "                                  copied into this buffer.  The buffer must"]
    #[doc = "                                  be at least six bytes in size.  Pass NULL"]
    #[doc = "                                  if you do not require this information."]
    #[doc = " @param out_is_nrpa           On success, the pointed-to value indicates"]
    #[doc = "                                  whether the retrieved address is a"]
    #[doc = "                                  non-resolvable private address.  Pass NULL"]
    #[doc = "                                  if you do not require this information."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_EINVAL if an invalid address type was"]
    #[doc = "                                  specified;"]
    #[doc = "                              BLE_HS_ENOADDR if the device does not have an"]
    #[doc = "                                  identity address of the requested type;"]
    #[doc = "                              Other BLE host core code on error."]
    pub fn ble_hs_id_copy_addr(
        id_addr_type: u8,
        out_id_addr: *mut u8,
        out_is_nrpa: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determines the best address type to use for automatic address type"]
    #[doc = " resolution.  Calculation of the best address type is done as follows:"]
    #[doc = ""]
    #[doc = " if privacy requested:"]
    #[doc = "     if we have a random static address:"]
    #[doc = "          --> RPA with static random ID"]
    #[doc = "     else"]
    #[doc = "          --> RPA with public ID"]
    #[doc = "     end"]
    #[doc = " else"]
    #[doc = "     if we have a random static address:"]
    #[doc = "          --> random static address"]
    #[doc = "     else"]
    #[doc = "          --> public address"]
    #[doc = "     end"]
    #[doc = " end"]
    #[doc = ""]
    #[doc = " @param privacy               (0/1) Whether to use a private address."]
    #[doc = " @param out_addr_type         On success, the \"own addr type\" code gets"]
    #[doc = "                                  written here."]
    #[doc = ""]
    #[doc = " @return                      0 if an address type was successfully inferred."]
    #[doc = "                              BLE_HS_ENOADDR if the device does not have a"]
    #[doc = "                                  suitable address."]
    #[doc = "                              Other BLE host core code on error."]
    pub fn ble_hs_id_infer_auto(
        privacy: ::std::os::raw::c_int,
        out_addr_type: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queries the controller for the channel map used with the specified"]
    #[doc = " connection.  The channel map is represented as an array of five bytes, with"]
    #[doc = " each bit corresponding to an individual channel.  The array is interpreted"]
    #[doc = " as little-endian, such that:"]
    #[doc = "     map[0] & 0x01 --> Channel 0."]
    #[doc = "     map[0] & 0x02 --> Channel 1."]
    #[doc = "     ..."]
    #[doc = "     map[1] & 0x01 --> Channel 8."]
    #[doc = ""]
    #[doc = " As there are 37 channels, only the first 37 bits get written."]
    #[doc = ""]
    #[doc = " If a bit is 1, the corresponding channel is used.  Otherwise, the channel is"]
    #[doc = " unused."]
    #[doc = ""]
    #[doc = " @param conn_handle           The handle of the connection whose channel map"]
    #[doc = "                                  is being read."]
    #[doc = " @param out_chan_map          On success, the retrieved channel map gets"]
    #[doc = "                                  written here.  This buffer must have a size"]
    #[doc = "                                  >= 5 bytes."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              A BLE host HCI return code if the controller"]
    #[doc = "                                  rejected the request;"]
    #[doc = "                              A BLE host core return code on unexpected"]
    #[doc = "                                  error."]
    pub fn ble_hs_hci_read_chan_map(
        conn_handle: u16,
        out_chan_map: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Instructs the controller to use the specified channel map.  The channel map"]
    #[doc = " is represented as an array of five bytes, with each bit corresponding to an"]
    #[doc = " individual channel.  The array is interpreted as little-endian, such that:"]
    #[doc = "     map[0] & 0x01 --> Channel 0."]
    #[doc = "     map[0] & 0x02 --> Channel 1."]
    #[doc = "     ..."]
    #[doc = "     map[1] & 0x01 --> Channel 8."]
    #[doc = ""]
    #[doc = " As there are 37 channels, only the first 37 bits should be written are used."]
    #[doc = ""]
    #[doc = " If a bit is 1, the corresponding channel can be used.  Otherwise, the"]
    #[doc = " channel should not be used."]
    #[doc = ""]
    #[doc = " @param chan_map              The channel map to configure.  This buffer"]
    #[doc = "                                  should have a size of 5 bytes."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              A BLE host HCI return code if the controller"]
    #[doc = "                                  rejected the request;"]
    #[doc = "                              A BLE host core return code on unexpected"]
    #[doc = "                                  error."]
    pub fn ble_hs_hci_set_chan_class(chan_map: *const u8) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct log {}
extern "C" {
    pub fn ble_hs_log_mbuf(om: *const os_mbuf);
}
extern "C" {
    pub fn ble_hs_log_flat_buf(data: *const ::core::ffi::c_void, len: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Allocates an mbuf suitable for an ATT command packet.  The resulting packet"]
    #[doc = " has sufficient leading space for:"]
    #[doc = "  - ACL data header"]
    #[doc = "  - L2CAP B-frame header"]
    #[doc = "  - Largest ATT command base (prepare write request / response)."]
    #[doc = ""]
    #[doc = " @return An empty mbuf on success, NULL on error."]
    pub fn ble_hs_mbuf_att_pkt() -> *mut os_mbuf;
}
extern "C" {
    #[doc = " Allocates an mbuf and fills it with the contents of the specified flat"]
    #[doc = " buffer."]
    #[doc = ""]
    #[doc = " @param buf The flat buffer to copy from."]
    #[doc = " @param len The length of the flat buffer."]
    #[doc = ""]
    #[doc = " @return A newly-allocated mbuf on success, NULL on error."]
    pub fn ble_hs_mbuf_from_flat(buf: *const ::core::ffi::c_void, len: u16) -> *mut os_mbuf;
}
extern "C" {
    #[doc = " Copies the contents of an mbuf into the specified flat buffer.  If the flat"]
    #[doc = " buffer is too small to contain the mbuf's contents, it is filled to capacity"]
    #[doc = " and BLE_HS_EMSGSIZE is returned."]
    #[doc = ""]
    #[doc = " @param om            The mbuf to copy from."]
    #[doc = " @param flat          The destination flat buffer."]
    #[doc = " @param max_len       The size of the flat buffer."]
    #[doc = " @param out_copy_len  The number of bytes actually copied gets written here."]
    #[doc = ""]
    #[doc = " @return               0 on success or BLE host core return code on error."]
    pub fn ble_hs_mbuf_to_flat(
        om: *const os_mbuf,
        flat: *mut ::core::ffi::c_void,
        max_len: u16,
        out_copy_len: *mut u16,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @typedef ble_hs_stop_fn"]
#[doc = " @brief Callback function; reports the result of a host stop procedure."]
#[doc = ""]
#[doc = " @param status                The result of the host stop procedure.  One of"]
#[doc = "                                  the HAL_RESET_[...] codes or an"]
#[doc = "                                  implementation-defined value."]
#[doc = " @param arg                   Optional argument specified when the stop"]
#[doc = "                                  procedure was initiated."]
#[doc = ""]
pub type ble_hs_stop_fn = ::core::option::Option<
    unsafe extern "C" fn(status: ::std::os::raw::c_int, arg: *mut ::core::ffi::c_void),
>;
#[doc = " @brief Used to report the result of a stop procedure."]
#[doc = ""]
#[doc = " This should be used as an opaque structure and not modified manually."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_hs_stop_listener {
    pub fn_: ble_hs_stop_fn,
    pub arg: *mut ::core::ffi::c_void,
    pub link: ble_hs_stop_listener__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_hs_stop_listener__bindgen_ty_1 {
    pub sle_next: *mut ble_hs_stop_listener,
}
extern "C" {
    #[doc = " @brief Stops the BLE host."]
    #[doc = ""]
    #[doc = " Aborts all active GAP procedures and terminates all open connections."]
    #[doc = " Connection termination is performed asynchronously, so this function's"]
    #[doc = " result is reported via the provided listener."]
    #[doc = ""]
    #[doc = " @param listener              A listener to populate.  This object's initial"]
    #[doc = "                                  value doesn't matter, but its lifetime must"]
    #[doc = "                                  extend until the stop procedure completes."]
    #[doc = " @param fn                    The callback to execute when the stop procedure"]
    #[doc = "                                  completes."]
    #[doc = " @param arg                   Optional argument to pass to the callback."]
    #[doc = ""]
    #[doc = " @return                      0: Stop procedure successfully initiated."]
    #[doc = "                              BLE_HS_EBUSY: Stop procedure already in"]
    #[doc = "                                  progress; the provided callback gets called"]
    #[doc = "                                  when the procedure completes."]
    #[doc = "                              BLE_HS_EALREADY: Host already stopped; the"]
    #[doc = "                                  provided callback does *not* get called."]
    pub fn ble_hs_stop(
        listener: *mut ble_hs_stop_listener,
        fn_: ble_hs_stop_fn,
        arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_ibeacon_set_adv_data(
        uuid128: *mut ::core::ffi::c_void,
        major: u16,
        minor: u16,
        measured_power: i8,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_sig_update_req {
    _unused: [u8; 0],
}
pub type ble_l2cap_sig_update_fn = ::core::option::Option<
    unsafe extern "C" fn(
        conn_handle: u16,
        status: ::std::os::raw::c_int,
        arg: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_sig_update_params {
    pub itvl_min: u16,
    pub itvl_max: u16,
    pub slave_latency: u16,
    pub timeout_multiplier: u16,
}
extern "C" {
    pub fn ble_l2cap_sig_update(
        conn_handle: u16,
        params: *mut ble_l2cap_sig_update_params,
        cb: ble_l2cap_sig_update_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_chan {
    _unused: [u8; 0],
}
#[doc = " Represents a L2CAP-related event."]
#[doc = " When such an event occurs, the host notifies the application by passing an"]
#[doc = " instance of this structure to an application-specified callback."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_l2cap_event {
    #[doc = " Indicates the type of L2CAP event that occurred.  This is one of the"]
    #[doc = " BLE_L2CAP_EVENT codes."]
    pub type_: u8,
    pub __bindgen_anon_1: ble_l2cap_event__bindgen_ty_1,
}
#[doc = " A discriminated union containing additional details concerning the L2CAP"]
#[doc = " event.  The 'type' field indicates which member of the union is valid."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_l2cap_event__bindgen_ty_1 {
    pub connect: ble_l2cap_event__bindgen_ty_1__bindgen_ty_1,
    pub disconnect: ble_l2cap_event__bindgen_ty_1__bindgen_ty_2,
    pub accept: ble_l2cap_event__bindgen_ty_1__bindgen_ty_3,
    pub receive: ble_l2cap_event__bindgen_ty_1__bindgen_ty_4,
    _bindgen_union_align: [u32; 3usize],
}
#[doc = " Represents a connection attempt. Valid for the following event"]
#[doc = " types:"]
#[doc = "     o BLE_L2CAP_EVENT_COC_CONNECTED"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_event__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " The status of the connection attempt;"]
    #[doc = "     o 0: the connection was successfully established."]
    #[doc = "     o BLE host error code: the connection attempt failed for"]
    #[doc = "       the specified reason."]
    pub status: ::std::os::raw::c_int,
    #[doc = " Connection handle of the relevant connection"]
    pub conn_handle: u16,
    #[doc = " The L2CAP channel of the relevant L2CAP connection."]
    pub chan: *mut ble_l2cap_chan,
}
#[doc = " Represents a terminated connection. Valid for the following event"]
#[doc = " types:"]
#[doc = "     o BLE_L2CAP_EVENT_COC_DISCONNECTED"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_event__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " Connection handle of the relevant connection"]
    pub conn_handle: u16,
    #[doc = " Information about the L2CAP connection prior to termination."]
    pub chan: *mut ble_l2cap_chan,
}
#[doc = " Represents connection accept. Valid for the following event"]
#[doc = " types:"]
#[doc = "     o BLE_L2CAP_EVENT_COC_ACCEPT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_event__bindgen_ty_1__bindgen_ty_3 {
    #[doc = " Connection handle of the relevant connection"]
    pub conn_handle: u16,
    #[doc = " MTU supported by peer device on the channel"]
    pub peer_sdu_size: u16,
    #[doc = " The L2CAP channel of the relevant L2CAP connection."]
    pub chan: *mut ble_l2cap_chan,
}
#[doc = " Represents received data. Valid for the following event"]
#[doc = " types:"]
#[doc = "     o BLE_L2CAP_EVENT_COC_DATA_RECEIVED"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_l2cap_event__bindgen_ty_1__bindgen_ty_4 {
    #[doc = " Connection handle of the relevant connection"]
    pub conn_handle: u16,
    #[doc = " The L2CAP channel of the relevant L2CAP connection."]
    pub chan: *mut ble_l2cap_chan,
    #[doc = " The mbuf with received SDU."]
    pub sdu_rx: *mut os_mbuf,
}
pub type ble_l2cap_event_fn = ::core::option::Option<
    unsafe extern "C" fn(
        event: *mut ble_l2cap_event,
        arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn ble_l2cap_get_conn_handle(chan: *mut ble_l2cap_chan) -> u16;
}
extern "C" {
    pub fn ble_l2cap_create_server(
        psm: u16,
        mtu: u16,
        cb: ble_l2cap_event_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_l2cap_connect(
        conn_handle: u16,
        psm: u16,
        mtu: u16,
        sdu_rx: *mut os_mbuf,
        cb: ble_l2cap_event_fn,
        cb_arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_l2cap_disconnect(chan: *mut ble_l2cap_chan) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_l2cap_send(chan: *mut ble_l2cap_chan, sdu_tx: *mut os_mbuf)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_l2cap_recv_ready(
        chan: *mut ble_l2cap_chan,
        sdu_rx: *mut os_mbuf,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_l2cap_get_scid(chan: *mut ble_l2cap_chan) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_l2cap_get_dcid(chan: *mut ble_l2cap_chan) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_l2cap_get_our_mtu(chan: *mut ble_l2cap_chan) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_l2cap_get_peer_mtu(chan: *mut ble_l2cap_chan) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_sm_io {
    pub action: u8,
    pub __bindgen_anon_1: ble_sm_io__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_sm_io__bindgen_ty_1 {
    pub passkey: u32,
    pub oob: [u8; 16usize],
    pub numcmp_accept: u8,
    _bindgen_union_align: [u32; 4usize],
}
extern "C" {
    pub fn ble_sm_inject_io(conn_handle: u16, pkey: *mut ble_sm_io) -> ::std::os::raw::c_int;
}
#[doc = " Used as a key for lookups of security material.  This struct corresponds to"]
#[doc = " the following store object types:"]
#[doc = "     o BLE_STORE_OBJ_TYPE_OUR_SEC"]
#[doc = "     o BLE_STORE_OBJ_TYPE_PEER_SEC"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_store_key_sec {
    #[doc = " Key by peer identity address;"]
    #[doc = " peer_addr=BLE_ADDR_NONE means don't key off peer."]
    pub peer_addr: ble_addr_t,
    #[doc = " Key by ediv; ediv_rand_present=0 means don't key off ediv."]
    pub ediv: u16,
    #[doc = " Key by rand_num; ediv_rand_present=0 means don't key off rand_num."]
    pub rand_num: u64,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = " Number of results to skip; 0 means retrieve the first match."]
    pub idx: u8,
}
impl ble_store_key_sec {
    #[inline]
    pub fn ediv_rand_present(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ediv_rand_present(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ediv_rand_present: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ediv_rand_present: u32 = unsafe { ::core::mem::transmute(ediv_rand_present) };
            ediv_rand_present as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Represents stored security material.  This struct corresponds to the"]
#[doc = " following store object types:"]
#[doc = "     o BLE_STORE_OBJ_TYPE_OUR_SEC"]
#[doc = "     o BLE_STORE_OBJ_TYPE_PEER_SEC"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_store_value_sec {
    pub peer_addr: ble_addr_t,
    pub key_size: u8,
    pub ediv: u16,
    pub rand_num: u64,
    pub ltk: [u8; 16usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub irk: [u8; 16usize],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub csrk: [u8; 16usize],
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
impl ble_store_value_sec {
    #[inline]
    pub fn ltk_present(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ltk_present(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ltk_present: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ltk_present: u8 = unsafe { ::core::mem::transmute(ltk_present) };
            ltk_present as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn irk_present(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_irk_present(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(irk_present: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let irk_present: u8 = unsafe { ::core::mem::transmute(irk_present) };
            irk_present as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn csrk_present(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csrk_present(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn authenticated(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_authenticated(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        csrk_present: u8,
        authenticated: ::std::os::raw::c_uint,
        sc: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let csrk_present: u8 = unsafe { ::core::mem::transmute(csrk_present) };
            csrk_present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let authenticated: u32 = unsafe { ::core::mem::transmute(authenticated) };
            authenticated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sc: u8 = unsafe { ::core::mem::transmute(sc) };
            sc as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Used as a key for lookups of stored client characteristic configuration"]
#[doc = " descriptors (CCCDs).  This struct corresponds to the BLE_STORE_OBJ_TYPE_CCCD"]
#[doc = " store object type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_store_key_cccd {
    #[doc = " Key by peer identity address;"]
    #[doc = " peer_addr=BLE_ADDR_NONE means don't key off peer."]
    pub peer_addr: ble_addr_t,
    #[doc = " Key by characteristic value handle;"]
    #[doc = " chr_val_handle=0 means don't key off characteristic handle."]
    pub chr_val_handle: u16,
    #[doc = " Number of results to skip; 0 means retrieve the first match."]
    pub idx: u8,
}
#[doc = " Represents a stored client characteristic configuration descriptor (CCCD)."]
#[doc = " This struct corresponds to the BLE_STORE_OBJ_TYPE_CCCD store object type."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ble_store_value_cccd {
    pub peer_addr: ble_addr_t,
    pub chr_val_handle: u16,
    pub flags: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl ble_store_value_cccd {
    #[inline]
    pub fn value_changed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_value_changed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        value_changed: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let value_changed: u32 = unsafe { ::core::mem::transmute(value_changed) };
            value_changed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Used as a key for store lookups.  This union must be accompanied by an"]
#[doc = " object type code to indicate which field is valid."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_store_key {
    pub sec: ble_store_key_sec,
    pub cccd: ble_store_key_cccd,
    _bindgen_union_align: [u32; 6usize],
}
#[doc = " Represents stored data.  This union must be accompanied by an object type"]
#[doc = " code to indicate which field is valid."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_store_value {
    pub sec: ble_store_value_sec,
    pub cccd: ble_store_value_cccd,
    _bindgen_union_align: [u32; 18usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ble_store_status_event {
    #[doc = " The type of event being reported; one of the BLE_STORE_EVENT_TYPE_[...]"]
    #[doc = " codes."]
    pub event_code: ::std::os::raw::c_int,
    pub __bindgen_anon_1: ble_store_status_event__bindgen_ty_1,
}
#[doc = " Additional data related to the event; the valid field is inferred from"]
#[doc = " the obj_type,event_code pair."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union ble_store_status_event__bindgen_ty_1 {
    pub overflow: ble_store_status_event__bindgen_ty_1__bindgen_ty_1,
    pub full: ble_store_status_event__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 2usize],
}
#[doc = " Represents a write that failed due to storage exhaustion.  Valid for"]
#[doc = " the following event types:"]
#[doc = "     o BLE_STORE_EVENT_OVERFLOW"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_store_status_event__bindgen_ty_1__bindgen_ty_1 {
    #[doc = " The type of object that failed to be written."]
    pub obj_type: ::std::os::raw::c_int,
    #[doc = " The object that failed to be written."]
    pub value: *const ble_store_value,
}
#[doc = " Represents the possibility that a scheduled write will fail due to"]
#[doc = " storage exhaustion.  Valid for the following event types:"]
#[doc = "     o BLE_STORE_EVENT_FULL"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_store_status_event__bindgen_ty_1__bindgen_ty_2 {
    #[doc = " The type of object that may fail to be written."]
    pub obj_type: ::std::os::raw::c_int,
    #[doc = " The handle of the connection which prompted the write."]
    pub conn_handle: u16,
}
#[doc = " Searches the store for an object matching the specified criteria.  If a"]
#[doc = " match is found, it is read from the store and the dst parameter is populated"]
#[doc = " with the retrieved object."]
#[doc = ""]
#[doc = " @param obj_type              The type of object to search for; one of the"]
#[doc = "                                  BLE_STORE_OBJ_TYPE_[...] codes."]
#[doc = " @param key                   Specifies properties of the object to search"]
#[doc = "                                  for.  An object is retrieved if it matches"]
#[doc = "                                  these criteria."]
#[doc = " @param dst                   On success, this is populated with the"]
#[doc = "                                  retrieved object."]
#[doc = ""]
#[doc = " @return                      0 if an object was successfully retreived;"]
#[doc = "                              BLE_HS_ENOENT if no matching object was found;"]
#[doc = "                              Other nonzero on error."]
pub type ble_store_read_fn = ::core::option::Option<
    unsafe extern "C" fn(
        obj_type: ::std::os::raw::c_int,
        key: *const ble_store_key,
        dst: *mut ble_store_value,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Writes the specified object to the store.  If an object with the same"]
#[doc = " identity is already in the store, it is replaced.  If the store lacks"]
#[doc = " sufficient capacity to write the object, this function may remove previously"]
#[doc = " stored values to make room."]
#[doc = ""]
#[doc = " @param obj_type              The type of object being written; one of the"]
#[doc = "                                  BLE_STORE_OBJ_TYPE_[...] codes."]
#[doc = " @param val                   The object to persist."]
#[doc = ""]
#[doc = " @return                      0 if the object was successfully written;"]
#[doc = "                              Other nonzero on error."]
pub type ble_store_write_fn = ::core::option::Option<
    unsafe extern "C" fn(
        obj_type: ::std::os::raw::c_int,
        val: *const ble_store_value,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Searches the store for the first object matching the specified criteria.  If"]
#[doc = " a match is found, it is deleted from the store."]
#[doc = ""]
#[doc = " @param obj_type              The type of object to delete; one of the"]
#[doc = "                                  BLE_STORE_OBJ_TYPE_[...] codes."]
#[doc = " @param key                   Specifies properties of the object to search"]
#[doc = "                                  for.  An object is deleted if it matches"]
#[doc = "                                  these criteria."]
#[doc = " @return                      0 if an object was successfully retrieved;"]
#[doc = "                              BLE_HS_ENOENT if no matching object was found;"]
#[doc = "                              Other nonzero on error."]
pub type ble_store_delete_fn = ::core::option::Option<
    unsafe extern "C" fn(
        obj_type: ::std::os::raw::c_int,
        key: *const ble_store_key,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Indicates an inability to perform a store operation.  This callback should"]
#[doc = " do one of two things:"]
#[doc = "     o Address the problem and return 0, indicating that the store operation"]
#[doc = "       should proceed."]
#[doc = "     o Return nonzero to indicate that the store operation should be aborted."]
#[doc = ""]
#[doc = " @param event                 Describes the store event being reported."]
#[doc = " @param arg                   Optional user argument."]
#[doc = ""]
#[doc = " @return                      0 if the store operation should proceed;"]
#[doc = "                              nonzero if the store operation should be"]
#[doc = "                                  aborted."]
pub type ble_store_status_fn = ::core::option::Option<
    unsafe extern "C" fn(
        event: *mut ble_store_status_event,
        arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn ble_store_read(
        obj_type: ::std::os::raw::c_int,
        key: *const ble_store_key,
        val: *mut ble_store_value,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_write(
        obj_type: ::std::os::raw::c_int,
        val: *const ble_store_value,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_delete(
        obj_type: ::std::os::raw::c_int,
        key: *const ble_store_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_overflow_event(
        obj_type: ::std::os::raw::c_int,
        value: *const ble_store_value,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_full_event(
        obj_type: ::std::os::raw::c_int,
        conn_handle: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_read_our_sec(
        key_sec: *const ble_store_key_sec,
        value_sec: *mut ble_store_value_sec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_write_our_sec(value_sec: *const ble_store_value_sec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_delete_our_sec(key_sec: *const ble_store_key_sec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_read_peer_sec(
        key_sec: *const ble_store_key_sec,
        value_sec: *mut ble_store_value_sec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_write_peer_sec(value_sec: *const ble_store_value_sec)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_delete_peer_sec(key_sec: *const ble_store_key_sec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_read_cccd(
        key: *const ble_store_key_cccd,
        out_value: *mut ble_store_value_cccd,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_write_cccd(value: *const ble_store_value_cccd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_delete_cccd(key: *const ble_store_key_cccd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_key_from_value_sec(
        out_key: *mut ble_store_key_sec,
        value: *const ble_store_value_sec,
    );
}
extern "C" {
    pub fn ble_store_key_from_value_cccd(
        out_key: *mut ble_store_key_cccd,
        value: *const ble_store_value_cccd,
    );
}
extern "C" {
    pub fn ble_store_key_from_value(
        obj_type: ::std::os::raw::c_int,
        out_key: *mut ble_store_key,
        value: *const ble_store_value,
    );
}
pub type ble_store_iterator_fn = ::core::option::Option<
    unsafe extern "C" fn(
        obj_type: ::std::os::raw::c_int,
        val: *mut ble_store_value,
        cookie: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn ble_store_iterate(
        obj_type: ::std::os::raw::c_int,
        callback: ble_store_iterator_fn,
        cookie: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_clear() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Utility functions."]
    pub fn ble_store_util_bonded_peers(
        out_peer_id_addrs: *mut ble_addr_t,
        out_num_peers: *mut ::std::os::raw::c_int,
        max_peers: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_util_delete_all(
        type_: ::std::os::raw::c_int,
        key: *const ble_store_key,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_util_delete_peer(peer_id_addr: *const ble_addr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_util_delete_oldest_peer() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_util_count(
        type_: ::std::os::raw::c_int,
        out_count: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_store_util_status_rr(
        event: *mut ble_store_status_event,
        arg: *mut ::core::ffi::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @brief Stack reset callback"]
#[doc = ""]
#[doc = " @param reason Reason code for reset"]
pub type ble_hs_reset_fn =
    ::core::option::Option<unsafe extern "C" fn(reason: ::std::os::raw::c_int)>;
#[doc = " @brief Stack sync callback"]
pub type ble_hs_sync_fn = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " @brief Bluetooth Host main configuration structure"]
#[doc = ""]
#[doc = " Those can be used by application to configure stack."]
#[doc = ""]
#[doc = " The only reason Security Manager (sm_ members) is configurable at runtime is"]
#[doc = " to simplify security testing. Defaults for those are configured by selecting"]
#[doc = " proper options in application's syscfg."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ble_hs_cfg {
    #[doc = " An optional callback that gets executed upon registration of each GATT"]
    #[doc = " resource (service, characteristic, or descriptor)."]
    pub gatts_register_cb: ble_gatt_register_fn,
    #[doc = " An optional argument that gets passed to the GATT registration"]
    #[doc = " callback."]
    pub gatts_register_arg: *mut ::core::ffi::c_void,
    #[doc = " Security Manager Local Input Output Capabilities"]
    pub sm_io_cap: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = " @brief Security Manager Local Key Distribution Mask"]
    pub sm_our_key_dist: u8,
    #[doc = " @brief Security Manager Remote Key Distribution Mask"]
    pub sm_their_key_dist: u8,
    #[doc = " @brief Stack reset callback"]
    #[doc = ""]
    #[doc = " This callback is executed when the host resets itself and the controller"]
    #[doc = " due to fatal error."]
    pub reset_cb: ble_hs_reset_fn,
    #[doc = " @brief Stack sync callback"]
    #[doc = ""]
    #[doc = " This callback is executed when the host and controller become synced."]
    #[doc = " This happens at startup and after a reset."]
    pub sync_cb: ble_hs_sync_fn,
    #[doc = " Storage Read callback handles read of security material"]
    pub store_read_cb: ble_store_read_fn,
    #[doc = " Storage Write callback handles write of security material"]
    pub store_write_cb: ble_store_write_fn,
    #[doc = " Storage Delete callback handles deletion of security material"]
    pub store_delete_cb: ble_store_delete_fn,
    #[doc = " @brief Storage Status callback."]
    #[doc = ""]
    #[doc = " This callback gets executed when a persistence operation cannot be"]
    #[doc = " performed or a persistence failure is imminent. For example, if is"]
    #[doc = " insufficient storage capacity for a record to be persisted, this"]
    #[doc = " function gets called to give the application the opportunity to make"]
    #[doc = " room."]
    pub store_status_cb: ble_store_status_fn,
    #[doc = " An optional argument that gets passed to the storage status callback."]
    pub store_status_arg: *mut ::core::ffi::c_void,
}
impl ble_hs_cfg {
    #[inline]
    pub fn sm_oob_data_flag(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sm_oob_data_flag(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sm_bonding(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sm_bonding(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sm_mitm(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sm_mitm(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sm_sc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sm_sc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sm_keypress(&self) -> ::std::os::raw::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sm_keypress(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sm_oob_data_flag: ::std::os::raw::c_uint,
        sm_bonding: ::std::os::raw::c_uint,
        sm_mitm: ::std::os::raw::c_uint,
        sm_sc: ::std::os::raw::c_uint,
        sm_keypress: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sm_oob_data_flag: u32 = unsafe { ::core::mem::transmute(sm_oob_data_flag) };
            sm_oob_data_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sm_bonding: u32 = unsafe { ::core::mem::transmute(sm_bonding) };
            sm_bonding as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sm_mitm: u32 = unsafe { ::core::mem::transmute(sm_mitm) };
            sm_mitm as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sm_sc: u32 = unsafe { ::core::mem::transmute(sm_sc) };
            sm_sc as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sm_keypress: u32 = unsafe { ::core::mem::transmute(sm_keypress) };
            sm_keypress as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static mut ble_hs_cfg: ble_hs_cfg;
}
extern "C" {
    #[doc = " @brief Indicates whether the host is enabled.  The host is enabled if it is"]
    #[doc = " starting or fully started.  It is disabled if it is stopping or stopped."]
    #[doc = ""]
    #[doc = " @return 1 if the host is enabled;"]
    #[doc = "         0 if the host is disabled."]
    pub fn ble_hs_is_enabled() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Indicates whether the host has synchronized with the controller."]
    #[doc = " Synchronization must occur before any host procedures can be performed."]
    #[doc = ""]
    #[doc = " @return 1 if the host and controller are in sync;"]
    #[doc = "         0 if the host and controller are out of sync."]
    pub fn ble_hs_synced() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Synchronizes the host with the controller by sending a sequence of HCI"]
    #[doc = " commands.  This function must be called before any other host functionality"]
    #[doc = " is used, but it must be called after both the host and controller are"]
    #[doc = " initialized.  Typically, the host-parent-task calls this function at the top"]
    #[doc = " of its task routine.  This function must only be called in the host parent"]
    #[doc = " task.  A safe alternative for starting the stack from any task is to call"]
    #[doc = " `ble_hs_sched_start()`."]
    #[doc = ""]
    #[doc = " If the host fails to synchronize with the controller (if the controller is"]
    #[doc = " not fully booted, for example), the host will attempt to resynchronize every"]
    #[doc = " 100 ms. For this reason, an error return code is not necessarily fatal."]
    #[doc = ""]
    #[doc = " @return 0 on success; nonzero on error."]
    pub fn ble_hs_start() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enqueues a host start event to the default event queue.  The actual host"]
    #[doc = " startup is performed in the host parent task, but using the default queue"]
    #[doc = " here ensures the event won't run until the end of main() when this is"]
    #[doc = " called during system initialization.  This allows the application to"]
    #[doc = " configure the host package in the meantime."]
    #[doc = ""]
    #[doc = " If auto-start is disabled, the application should use this function to start"]
    #[doc = " the BLE stack.  This function can be called at any time as long as the host"]
    #[doc = " is stopped.  When the host successfully starts, the application is notified"]
    #[doc = " via the ble_hs_cfg.sync_cb callback."]
    pub fn ble_hs_sched_start();
}
extern "C" {
    #[doc = " Causes the host to reset the NimBLE stack as soon as possible.  The"]
    #[doc = " application is notified when the reset occurs via the host reset callback."]
    #[doc = ""]
    #[doc = " @param reason The host error code that gets passed to the reset callback."]
    pub fn ble_hs_sched_reset(reason: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Designates the specified event queue for NimBLE host work. By default, the"]
    #[doc = " host uses the default event queue and runs in the main task. This function"]
    #[doc = " is useful if you want the host to run in a different task."]
    #[doc = ""]
    #[doc = " @param evq The event queue to use for host work."]
    pub fn ble_hs_evq_set(evq: *mut ble_npl_eventq);
}
extern "C" {
    #[doc = " Initializes the NimBLE host. This function must be called before the OS is"]
    #[doc = " started. The NimBLE stack requires an application task to function.  One"]
    #[doc = " application task in particular is designated as the \"host parent task\". In"]
    #[doc = " addition to application-specific work, the host parent task does work for"]
    #[doc = " NimBLE by processing events generated by the host."]
    pub fn ble_hs_init();
}
extern "C" {
    #[doc = " Deinitializes the NimBLE host. This function must be called after the"]
    #[doc = " NimBLE host stop procedure is complete."]
    pub fn ble_hs_deinit();
}
extern "C" {
    #[doc = " @brief Called when the system is shutting down.  Stops the BLE host."]
    #[doc = ""]
    #[doc = " @param reason                The reason for the shutdown.  One of the"]
    #[doc = "                                  HAL_RESET_[...] codes or an"]
    #[doc = "                                  implementation-defined value."]
    #[doc = ""]
    #[doc = " @return                      SYSDOWN_IN_PROGRESS."]
    pub fn ble_hs_shutdown(reason: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tries to configure the device with at least one Bluetooth address."]
    #[doc = " Addresses are restored in a hardware-specific fashion."]
    #[doc = ""]
    #[doc = " @param prefer_random         Whether to attempt to restore a random address"]
    #[doc = "                                  before checking if a public address has"]
    #[doc = "                                  already been configured."]
    #[doc = ""]
    #[doc = " @return                      0 on success;"]
    #[doc = "                              BLE_HS_ENOADDR if the device does not have any"]
    #[doc = "                                  available addresses."]
    #[doc = "                              Other BLE host core code on error."]
    pub fn ble_hs_util_ensure_addr(prefer_random: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type ble_svc_gap_chr_changed_fn = ::core::option::Option<unsafe extern "C" fn(uuid: u16)>;
extern "C" {
    pub fn ble_svc_gap_set_chr_changed_cb(cb: ble_svc_gap_chr_changed_fn);
}
extern "C" {
    pub fn ble_svc_gap_device_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ble_svc_gap_device_name_set(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_svc_gap_device_appearance() -> u16;
}
extern "C" {
    pub fn ble_svc_gap_device_appearance_set(appearance: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ble_svc_gap_init();
}
extern "C" {
    pub fn ble_svc_gatt_changed(start_handle: u16, end_handle: u16);
}
extern "C" {
    pub fn ble_svc_gatt_init();
}
pub type __builtin_va_list = __va_list_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub __va_stk: *mut ::std::os::raw::c_int,
    pub __va_reg: *mut ::std::os::raw::c_int,
    pub __va_ndx: ::std::os::raw::c_int,
}
